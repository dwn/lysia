<!doctype html>
<html lang="en">
<head>
  <script>
const defaultContent = `
//t d
04|88 ca 05 d5 59 91 10 02|
//k g
88 c8 62 88 04|88 c8 01 a5 19 d1 6a
//m n
88 c8 40 60 04

||88
//trinity
98 03 91|1d d5 30|dd 00|8a 00|ae 51 11|88 98 03 91|2e a2 ef 00|
//u^n
ca 08|cd 02|d5 81 20|
//in
2e a2|e9 00|
//esens
88 a8 30 64 88|c8 98 50 82 10|50 82 10|d9 00|88 c8 8a 50 82 10|
//@nd
87|8c 00|88 ca 05 d5 59 91 10 02|
//undivaid&d
88 ba 02|d5 81 20|88 aa 05 d5 59 91 10 01 91|2e a2|88 20 62 88 04|8e 40 20|fd 02|88 b8 9a 05 d5 59 91 10 02|8e b2|88 9a 05 d5 59 91 10 02

//janlwk
||88
19 03 91|88 da 40|e9 00|88 c8 60 03 02|88 8b 28 e1 40|88 a8 62 88 04|

//picard
88 b8 10 09 50 10 09 50 88 03 91|2e a2|88 a8 62 88 04|88 8a 10 19 91|10 1d d5 30|88 9a 05 d5 59 91 10 02

//uili^m
||88
9b 08|8e 00|88 c8 60 03 91|2e a2|ee 02 91|88 40 e8 04|

//ty
88 b8 03 91|2e a2 88 dd 51 30|

//raikr
88 19 d1 50 02|8e 40 20|ed 02|88 c8 62 88 03 91|1d d5 30

//dy@n^
||88
aa 05 d5 59 91 10 01 91|2e a2 ef 00|88 c8 a8 74|30|88 9a 02|

//troi
88 a8 03 91|1d d5 30|88 b8 84 2e e6|8a 00

//uorf
||88
9b 08|88 c8 84 2e e6 59 b3 10|1d d5 30|88 d8 28 a0 e8 04

//ded^
||88
aa 05 d5 59 91 10 02|88 8a 40 10 f8 e8 89 40 10|88 8a 05 d5 59 91 10 02|88 aa 02

//u&sly
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
`;
const defaultSvgBackground = `https://vault.biltmoretoday.com/storage/v1/object/public/image/tree.svg`;
</script>
  <meta charset="utf-8" />
  <title>Wfo Writer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23000'/><circle cx='50' cy='50' r='25' fill='%23fff'/></svg>">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    /* CSS Variables for dark mode support */
    :root { 
      --canvas-bg: #fff;
      --grid-color: #ddd;
      --border-color: #ccc;
      --button-bg: #f8f8f8;
      --button-border: #ddd;
    }
    
    /* Override Pico CSS for dropdown display */
    #bgColorSelect {
      color: inherit !important;
    }
    
    #bgColorSelect option {
      color: inherit !important;
    }
    
    /* 3D flip animation for presentation card */
    .canvas-only {
      perspective: 1000px;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .canvas-only .grid {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    
    .canvas-only .grid > div:first-child {
      transform-style: preserve-3d;
      animation: cardFlipIn 1.5s ease-out forwards;
      position: relative;
    }
    
    /* Glow effect emanating from behind the card */
    .canvas-only .grid > div:first-child::before {
      content: '';
      position: absolute;
      top: -80px;
      left: -30px;
      right: -30px;
      bottom: -80px;
      background: radial-gradient(ellipse, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.4) 20%, rgba(255, 255, 255, 0.2) 40%, transparent 70%);
      border-radius: 30px;
      z-index: -1;
      opacity: 0;
      animation: glowAppear 1.5s ease-out forwards;
      filter: blur(10px);
    }
    
    @keyframes cardFlipIn {
      0% {
        transform: rotateX(90deg) rotateY(90deg);
        opacity: 0;
      }
      50% {
        transform: rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
      100% {
        transform: rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
    }
    
    @keyframes glowAppear {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      20% {
        opacity: 1;
        transform: scale(1.5);
      }
      100% {
        opacity: 0.6;
        transform: scale(1);
      }
    }
    
    :root.dark {
      --canvas-bg: #2a2a2a;
      --grid-color: #555;
      --border-color: #666;
      --button-bg: #333;
      --button-border: #666;
    }
    
    /* Canvas-specific styles only */
    canvas { 
      width: 400px; 
      height: 1000px; 
      display: block;
      position: relative;
      z-index: 1;
    }
    
    /* Specific class for custom backgrounds */
    canvas.has-custom-background {
      background: var(--custom-bg) !important;
    }
    
    .mono-grid{ 
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; 
      white-space: pre; 
    }

    .ce-editor {
      font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      white-space: pre-wrap; 
      word-break: break-word; 
      tab-size: 2;
      min-height: 20em;
      padding: 6px 8px;
      border: 1px solid var(--border-color); 
      border-radius: 6px;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: auto;
      user-select: text; /* Ensure text selection is enabled */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    .hex-hit {
      outline: 1px solid rgba(0, 230, 255, 0.6);
      border-radius: 3px;
    }
    
    .current-letter {
      /* Bold text is handled by <strong> tag, no additional styling needed */
    }
    
    .byte { font-weight: 600; }
    
    /* Size subscript alignment */
    sub { vertical-align: sub; font-size: 0.8em; }
    
    /* Responsive layout fixes */
    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
    }
    
    /* Prevent overlap in edit mode at medium widths */
    @media (max-width: 1000px) and (min-width: 769px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 1rem;
      }
      
      aside {
        min-width: 300px;
      }
    }
    
    /* Ensure canvas doesn't shrink below its natural width */
    canvas {
      min-width: 400px;
    }
    
    /* Better grid behavior for wider screens */
    @media (min-width: 1001px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 2rem;
      }
    }
    
    /* Fix grid height to prevent scroll */
    .grid {
      height: auto !important;
      min-height: auto !important;
    }
    
    /* Canvas centering when sidebar is hidden */
    .canvas-only .grid {
      display: flex;
      justify-content: center;
    }
    
    .canvas-only aside {
      display: none !important;
    }
    
    /* Monitor/glossy effect for presentation mode */
    .canvas-only canvas {
      background: linear-gradient(135deg, 
        rgba(109,191,232,0.8) 0%, 
        rgba(40,161,222,0.6) 25%, 
        rgba(31,140,194,0.4) 50%, 
        rgba(51,160,214,0.2) 75%, 
        rgba(20,120,180,0.1) 100%);
      box-shadow: 
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.1),
        0 8px 32px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255,255,255,0.1);
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
      border-radius: 16px;
      padding: 1.5rem;
      position: relative;
    }
    
    /* Add a subtle screen reflection effect */
    .canvas-only canvas::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, 
        rgba(255,255,255,0.1) 0%, 
        rgba(255,255,255,0.05) 50%, 
        transparent 100%);
      border-radius: 16px 16px 0 0;
      pointer-events: none;
    }
    
    /* Soft roaming light effect on page background - only in presentation mode */
    body {
      position: relative;
      overflow-x: hidden;
    }
    
    body.canvas-only::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: 
        radial-gradient(ellipse 400px 200px at 30% 40%, rgba(109,191,232,0.06) 0%, transparent 60%),
        radial-gradient(ellipse 300px 150px at 70% 20%, rgba(40,161,222,0.04) 0%, transparent 60%),
        radial-gradient(ellipse 350px 180px at 20% 80%, rgba(109,191,232,0.05) 0%, transparent 60%);
      pointer-events: none;
      z-index: -1;
      animation: fluidRoamLight 25s ease-in-out infinite;
    }
    
    @keyframes fluidRoamLight {
      0% {
        transform: translate(0%, 0%) rotate(0deg) scale(1);
      }
      25% {
        transform: translate(15%, -10%) rotate(90deg) scale(1.1);
      }
      50% {
        transform: translate(-10%, 20%) rotate(180deg) scale(0.9);
      }
      75% {
        transform: translate(20%, 5%) rotate(270deg) scale(1.05);
      }
      100% {
        transform: translate(0%, 0%) rotate(360deg) scale(1);
      }
    }
  </style>
</head>
<body>
  <main class="container-fluid">
    <div class="grid">
      <div>
        <div id="canvasWrapper" style="position: relative; overflow: hidden; padding-bottom: 1.5rem; border-radius: 16px;">
          <canvas id="board" width="400" height="1000" aria-label="drawing canvas"></canvas>
        </div>
</div>
      <aside>
        <details>
          <summary>Instruction</summary>
      <small>
        <strong>Encoding:</strong> Each byte is <code>axxxbyyy</code> (MSBâ†’LSB), where <code>xxx</code> and <code>yyy</code> are 3-bit values mapped via <code>(v<=4?v:4-v)</code>.
        <br>
        <div class="mono-grid">bit7 bit6..4 bit3 bit2..0
a     xxx    b    yyy</div>
        <br>
        <strong>Line type (<code>ab</code>):</strong>
        <br>
        <div class="mono-grid">00 line
01 elliptical arc type 1
10 elliptical arc type 2
11 invisible (move only)</div>
        <br>
        <strong>Zero move:</strong> If <code>xxx=000</code> and <code>yyy=000</code>, behavior depends on ab:
        <div class="mono-grid">00 point
01 circle radius 1
10 circle radius 1/2
11 snap to top of textline (move only)</div>
        <br>
            <strong>Pipes:</strong>
            <br>
            <code>|</code> cycles color
            <br>
            <code>||</code> moves to next text line
            <br>
            <br>
            <strong>Shortcuts:</strong>
            <br>
            <code>Ctrl+E / Cmd+E</code> toggles editor
      </small>
        </details>
        
        <details>
          <summary>Option</summary>
          <div class="grid">
            <div>
              <label for="sInput">Size <span id="sValue">5</span></label>
              <input id="sInput" type="range" min="2" max="20" value="5"/>
            </div>
            <div>
              <label for="bgColorSelect">Background <span id="bgColorIndicator" style="display: inline-block; width: 12px; height: 12px; background-color: #000000; border: 1px solid #ccc; margin-left: 4px; vertical-align: middle;"></span></label>
              <select id="bgColorSelect">
                <option value="transparent">Transparent</option>
              </select>
            </div>
            <div>
              <input id="italicsCheckbox" type="checkbox" checked/>
              <label for="italicsCheckbox">Italics</label>
            </div>
          </div>
        </details>
        
        <details>
          <summary>Svg</summary>
          <div>
            <label for="svgInput"><sub>Background Svg</sub></label>
            <input id="svgInput" type="url" placeholder="https://example.com/image.svg or paste SVG code directly">
            <div id="svgPreview" style="margin-top: 1rem; padding: 1rem; border: 1px solid #ccc; border-radius: 4px; background: white; min-height: 100px; display: none;">
              <div id="svgPreviewContent"></div>
            </div>
          </div>
        </details>
        
        <details>
          <summary>Rule</summary>
          <div id="strRule" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details>
          <summary>Input</summary>
          <div id="strInput" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details>
          <summary>Output</summary>
          <div id="strOutput" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
    </aside>
  </div>
  </main>
  <script>
    let italicsMode = true; // toggled by italics checkbox
    let editorVisible = false; // toggled by E key
    let maxDrawnY = 0; // track the lowest point of drawn content
    let s=5;let thickness=s/10;const pad={left:1,top:1,right:1};const start={xi:pad.left,yi:pad.top};
    const canvas=document.getElementById('board');const ctx=canvas.getContext('2d', { alpha: true });
    const cssW=400,cssH=1000;
    let currentCanvasHeight = 200; // start small for smooth expansion
    let targetCanvasHeight = cssH; // target height for smooth animation
    let animationStartTime = 0; // when height animation started
    const dpr=window.devicePixelRatio||1;
    if(dpr!==1){canvas.width=cssW*dpr;canvas.height=cssH*dpr;canvas.style.width=cssW+'px';canvas.style.height=cssH+'px';ctx.scale(dpr,dpr);}    
    const width=cssW,height=cssH;let gridX=Math.floor(width/s);
    
    // Configure canvas for round line caps
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Color palette (cycles each time a SINGLE '|' is encountered)
    const COLORS = ['#000000','#8c0004','#f00007','#f34001','#f8af00','#d9ce00','#0ccc0e','#00dfd8','#3441fc','#5020e0','#8000f0','#350063','#808080','#ffffff'];

    function getColors() {
      return COLORS;
    }
    
    // Drawing constants
    const OUTLINE_THICKNESS_MULTIPLIER = 6;
    const MAIN_THICKNESS_MULTIPLIER = 4;
    const POINT_OUTLINE_THICKNESS_MULTIPLIER = 2;
    const POINT_RADIUS_MULTIPLIER = 4;
    const END_MARKER_RADIUS_MULTIPLIER = 3;
    
    // UI constants
    const DEFAULT_PANEL_COLOR_INDEX = 1;
    
    // Helper function to draw outline with consistent styling
    function drawOutline(isPoint = false) {
      // Skip outlines in editor mode
      if (editorVisible) return;
      
      const bgColorSelectEl = document.getElementById('bgColorSelect');
      const backgroundColor = bgColorSelectEl.value;
      
      // Blend background color with #404040 (50% interpolation)
      const blendedColor = blendColors(backgroundColor, '#404040', 0.5);
      
      ctx.strokeStyle = blendedColor;
      ctx.lineWidth = thickness * (isPoint ? POINT_OUTLINE_THICKNESS_MULTIPLIER : OUTLINE_THICKNESS_MULTIPLIER);
      ctx.stroke();
    }
    
    // Helper function to draw point outline with stroke
    function drawPointOutline() {
      // Skip outlines in editor mode
      if (editorVisible) return;
      
      const bgColorSelectEl = document.getElementById('bgColorSelect');
      const backgroundColor = bgColorSelectEl.value;
      
      // Blend background color with #404040 (50% interpolation)
      const blendedColor = blendColors(backgroundColor, '#404040', 0.5);
      
      ctx.strokeStyle = blendedColor;
      ctx.lineWidth = thickness * POINT_OUTLINE_THICKNESS_MULTIPLIER;
      ctx.stroke();
    }
    
    // Helper function to blend two colors
    function blendColors(color1, color2, ratio) {
      // Convert hex to RGB
      const hex1 = color1.replace('#', '');
      const hex2 = color2.replace('#', '');
      
      const r1 = parseInt(hex1.substr(0, 2), 16);
      const g1 = parseInt(hex1.substr(2, 2), 16);
      const b1 = parseInt(hex1.substr(4, 2), 16);
      
      const r2 = parseInt(hex2.substr(0, 2), 16);
      const g2 = parseInt(hex2.substr(2, 2), 16);
      const b2 = parseInt(hex2.substr(4, 2), 16);
      
      // Interpolate
      const r = Math.round(r1 + (r2 - r1) * ratio);
      const g = Math.round(g1 + (g2 - g1) * ratio);
      const b = Math.round(b1 + (b2 - b1) * ratio);
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    const toCanvas=(p)=>({x:p.xi*s,y:p.yi*s});
    
    // Apply italics skew transformation to a point
    function applyItalicsTransform(point) {
      if (!italicsMode) return point;
      
      // Calculate which text line this point belongs to (each text line is 8 grid units tall)
      const textLineHeight = 8 * s;
      const textLineIndex = Math.floor(point.y / textLineHeight);
      
      // Calculate the skew offset for this text line
      // Each text line gets skewed by its own height within that line
      const skewFactor = -0.15;
      const yWithinTextLine = point.y - (textLineIndex * textLineHeight);
      const skewOffset = s + yWithinTextLine * skewFactor;
      
      return {
        x: point.x + skewOffset,
        y: point.y
      };
    }
    
    function preCalculateHeight() {
      // Count the number of "||" to determine how many text lines we have
      const text = getEditorValue();
      const lineCount = (text.match(/\|\|/g) || []).length;
      
      // Calculate target height: (number of "||" + 1) * 8 * s
      targetCanvasHeight = (lineCount + 1) * 8 * s + 24; // +24px for padding-bottom
      currentCanvasHeight = 200; // Start small for smooth expansion
      animationStartTime = performance.now();
      
      // Set initial wrapper height
      const wrapper = document.getElementById('canvasWrapper');
      wrapper.style.height = currentCanvasHeight + 'px';
    }
    
    function updateCanvasHeight() {
      if (!editorVisible && targetCanvasHeight > 0) {
        // Smooth S-curve animation from current to target height
        const now = performance.now();
        const elapsed = now - animationStartTime;
        const duration = 4000;
        
        if (elapsed < duration) {
          // S-curve easing function (smooth acceleration and deceleration)
          const t = elapsed / duration;
          const sCurve = t * t * (3 - 2 * t); // smoothstep function
          
          const newHeight = currentCanvasHeight + (targetCanvasHeight - currentCanvasHeight) * sCurve;
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.style.height = newHeight + 'px';
          // Canvas stays at full height - wrapper clips it
          
          // Reposition SVG background
        } else {
          // Animation complete
          currentCanvasHeight = targetCanvasHeight;
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.style.height = targetCanvasHeight + 'px';
        }
      }
    }
    
    
    async function drawSvgBackground() {
      const svgValue = svgInputEl.value.trim();
      if (!svgValue) return;
      
      let svgContent;
      
      // Check if it's a URL (starts with http/https) or SVG code
      if (svgValue.startsWith('http://') || svgValue.startsWith('https://')) {
        try {
          const response = await fetch(svgValue);
          svgContent = await response.text();
        } catch (error) {
          console.error('Failed to fetch SVG from URL:', error);
          return;
        }
      } else {
        // It's SVG code directly
        svgContent = svgValue;
      }
      
      // Process SVG content
      let processedSvg = svgContent;
      
      // Remove SVG animations when in edit mode
      if (editorVisible) {
        // Remove all animation elements (both self-closing and with content)
        processedSvg = processedSvg.replace(/<animate[^>]*(?:\/>|>.*?<\/animate>)/g, '');
        processedSvg = processedSvg.replace(/<animateTransform[^>]*(?:\/>|>.*?<\/animateTransform>)/g, '');
        processedSvg = processedSvg.replace(/<animateMotion[^>]*(?:\/>|>.*?<\/animateMotion>)/g, '');
      }
      
      // Remove explicit width and height attributes to allow proper container sizing
      // But preserve dimensions for rect elements that define backgrounds
      processedSvg = processedSvg.replace(/width="[^"]*"/g, '');
      processedSvg = processedSvg.replace(/height="[^"]*"/g, '');
      
      // Restore width and height for rect elements that have fill colors (backgrounds)
      // More flexible approach: find any rect with fill and extract width/height separately
      const originalSvg = svgContent;
      const widthMatch = originalSvg.match(/<rect[^>]*?width="([^"]*)"[^>]*?>/);
      const heightMatch = originalSvg.match(/<rect[^>]*?height="([^"]*)"[^>]*?>/);
      const fillMatch = originalSvg.match(/<rect[^>]*?style="[^"]*fill:[^"]*"[^>]*?>/);
      
      if (widthMatch && heightMatch && fillMatch) {
        processedSvg = processedSvg.replace(/<rect([^>]*?)style="([^"]*fill:[^"]*)"([^>]*?)>/g, 
          `<rect$1width="${widthMatch[1]}" height="${heightMatch[1]}" style="$2"$3>`);
      }
      
      // Normalize viewBox attribute (fix lowercase viewbox to proper viewBox)
      processedSvg = processedSvg.replace(/viewbox="([^"]*)"/g, 'viewBox="$1"');
      
      // Keep original viewBox - CSS object-fit will handle the scaling
      //processedSvg = processedSvg.replace(/viewBox="[^"]*"/g, `viewBox="0 0 1200 1200"`);
      
      if (editorVisible) {
        // Show SVG in preview box when in editor mode
        const svgPreview = document.getElementById('svgPreview');
        const svgPreviewContent = document.getElementById('svgPreviewContent');
        
        if (svgPreview && svgPreviewContent) {
          svgPreview.style.display = 'block';
          svgPreviewContent.innerHTML = `
            <style>
              #svgPreviewContent svg {
                width: 100%;
                max-width: 200px;
                height: auto;
                display: block;
                margin: 0 auto;
              }
            </style>
            ${processedSvg}
          `;
        }
        
        // Hide background SVG when in editor mode
        const svgBackground = document.getElementById('svgBackground');
        if (svgBackground) {
          svgBackground.style.display = 'none';
        }
      } else {
        // Show SVG as background when not in editor mode
        const svgPreview = document.getElementById('svgPreview');
        if (svgPreview) {
          svgPreview.style.display = 'none';
        }
      
      // Create or update background SVG element
      let svgBackground = document.getElementById('svgBackground');
      const canvas = document.getElementById('board');
      
      if (!svgBackground) {
        svgBackground = document.createElement('div');
        svgBackground.id = 'svgBackground';
          svgBackground.style.position = 'absolute';
          svgBackground.style.top = '0';
          svgBackground.style.left = '0';
          svgBackground.style.width = '100%';
          svgBackground.style.height = '100%';
        svgBackground.style.zIndex = '-1';
          svgBackground.style.pointerEvents = 'none';

          // Add it as a child of the wrapper
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.appendChild(svgBackground);
      }
        
        svgBackground.style.display = 'block';
      
      // Position and size exactly like the canvas
      
        // Get current background color for glow
        const bgColorSelectEl = document.getElementById('bgColorSelect');
        const selectedColor = bgColorSelectEl.value;
        
        // Convert hex to RGB for glow
        const hex = selectedColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
      
      svgBackground.innerHTML = `
        <style>
          #svgBackground svg {
              width: 100%;
              height: 100%;
              display: block;
              object-fit: contain;
              object-position: center;
              transform: scale(0.707);
              /* filter: drop-shadow(0 0 10px rgba(${r}, ${g}, ${b}, 0.4)) drop-shadow(0 0 20px rgba(${r}, ${g}, ${b}, 0.3)) drop-shadow(0 0 30px rgba(${r}, ${g}, ${b}, 0.2)); */
          }
        </style>
        ${processedSvg}
      `;
      }
    }
    
    function drawSvgElement(element, scaleX, scaleY, offsetX, offsetY) {
      const tagName = element.tagName.toLowerCase();
      
      if (tagName === 'rect') {
        const x = parseFloat(element.getAttribute('x') || 0) * scaleX + offsetX;
        const y = parseFloat(element.getAttribute('y') || 0) * scaleY + offsetY;
        const w = parseFloat(element.getAttribute('width')) * scaleX;
        const h = parseFloat(element.getAttribute('height')) * scaleY;
        const fill = element.getAttribute('fill') || '#000';
        
        ctx.fillStyle = fill;
        ctx.fillRect(x, y, w, h);
      }
      else if (tagName === 'circle') {
        const cx = parseFloat(element.getAttribute('cx')) * scaleX + offsetX;
        const cy = parseFloat(element.getAttribute('cy')) * scaleY + offsetY;
        const r = parseFloat(element.getAttribute('r')) * Math.min(scaleX, scaleY);
        const fill = element.getAttribute('fill') || '#000';
        const stroke = element.getAttribute('stroke');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        }
      }
      else if (tagName === 'path') {
        const d = element.getAttribute('d');
        const stroke = element.getAttribute('stroke') || '#000';
        const fill = element.getAttribute('fill');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        if (d) {
          // Use proper SVG path parser with offsets
          drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY);
        }
      }
    }
    
    function drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY) {
      // Parse SVG path data
      const commands = parseSvgPath(d);
      
      ctx.beginPath();
      
      let currentX = 0, currentY = 0;
      let startX = 0, startY = 0;
      
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        
        switch (cmd.type) {
          case 'M': // Move to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'm': // Move to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'L': // Line to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'l': // Line to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'C': // Cubic curve (absolute)
            ctx.bezierCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x2 * scaleX + offsetX, cmd.y2 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'c': // Cubic curve (relative)
            ctx.bezierCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x2 * scaleX, currentY + cmd.y2 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Q': // Quadratic curve (absolute)
            ctx.quadraticCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'q': // Quadratic curve (relative)
            ctx.quadraticCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Z': // Close path
          case 'z':
            ctx.closePath();
            currentX = startX;
            currentY = startY;
            break;
        }
      }
      
      // Fill and stroke
      if (fill && fill !== 'none') {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      
      if (stroke && stroke !== 'none') {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
      }
    }
    
    function parseSvgPath(d) {
      // Simple SVG path parser
      const commands = [];
      const tokens = d.match(/[MmLlHhVvCcSsQqTtAaZz]|[+-]?[0-9]*\.?[0-9]+/g) || [];
      
      let i = 0;
      while (i < tokens.length) {
        const token = tokens[i];
        
        if (/[MmLlHhVvCcSsQqTtAaZz]/.test(token)) {
          const command = token;
          i++;
          
          switch (command) {
            case 'M':
            case 'm':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'L':
            case 'l':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'C':
            case 'c':
              if (i + 5 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x2: parseFloat(tokens[i + 2]),
                  y2: parseFloat(tokens[i + 3]),
                  x: parseFloat(tokens[i + 4]),
                  y: parseFloat(tokens[i + 5])
                });
                i += 6;
              }
              break;
              
            case 'Q':
            case 'q':
              if (i + 3 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x: parseFloat(tokens[i + 2]),
                  y: parseFloat(tokens[i + 3])
                });
                i += 4;
              }
              break;
              
            case 'Z':
            case 'z':
              commands.push({ type: command });
              i++;
              break;
              
            default:
              i++; // Skip unknown commands
              break;
          }
        } else {
          i++;
        }
      }
      
      return commands;
    }
    
    function drawGridPoints(spacing=s){
      // Only clear the canvas content if we're drawing grid points (edit mode)
      if (editorVisible) {
        ctx.clearRect(0,0,width,height);
        ctx.save();
        const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
        const r=thickness*3;
        
        for(let y=0;y<=height;y+=spacing){
          // Determine if this row is in an even or odd text row space
          const textRowIndex = Math.floor(y / (8 * s));
          const isEvenTextRow = textRowIndex % 2 === 0;
          
          // Slightly adjust brightness for alternating text rows
          const brightness = isEvenTextRow ? 0.15 : 0.1;
          
          ctx.fillStyle = baseColor;
          ctx.globalAlpha = brightness;
          
          ctx.beginPath();
          for(let x=0;x<=width;x+=spacing){
            const point = applyItalicsTransform({x,y});
            ctx.moveTo(point.x+r,point.y);
            ctx.arc(point.x,point.y,r,0,Math.PI*2);
          }
          ctx.fill();
        }
        ctx.restore();
      }
    }
    function preMoveWrap(xi,yi,dx){const maxX=gridX-pad.right;if(dx>0&&(xi+dx)>maxX){xi=pad.left;yi+=8;}return{xi,yi};}
    function snapToLineTop(yi){return pad.top+8*Math.floor((yi-pad.top)/8);}    
    function normAngle(a){const twoPI=Math.PI*2;while(a<=-Math.PI)a+=twoPI;while(a>Math.PI)a-=twoPI;return a;}
    function anticlockwiseForShortest(a0,a1){const twoPI=Math.PI*2;let cw=(a1-a0)%twoPI;if(cw<0)cw+=twoPI;let ccw=(a0-a1)%twoPI;if(ccw<0)ccw+=twoPI;return ccw<=cw;}
    function angleOnEllipse(cx,cy,rx,ry,x,y){return Math.atan2((y-cy)/ry,(x-cx)/rx);}    

    // Parse while preserving newline at '||'
    function parseBytesWithColors(str){
      const out=[]; let buf='';
      const isHex = c => /[0-9a-fA-F]/.test(c);

      for(let i=0;i<(str?str.length:0);i++){
        const ch = str[i];
        
        // Handle comments: skip everything after "//" until end of line
        if(ch === '/' && str[i + 1] === '/'){
          // Skip to end of line (newline or end of string)
          while(i < str.length && str[i] !== '\n'){
            i++;
          }
          // Don't skip the newline character itself, let it be processed normally
          if(i < str.length && str[i] === '\n'){
            i--; // Back up one so the newline gets processed in the next iteration
          }
          continue;
        }
        
        if(ch==='|'){
          const next = str[i+1];
          if(next==='|'){
            out.push({newline:true});
            i++;
          }else{
            // emit the literal pipe as a non-byte token so caret offsets match textContent
            out.push({pipe:true});
          }
          continue;
        }
        if(isHex(ch)){
          buf += ch;
          if(buf.length===2){
            out.push({byte:parseInt(buf,16), text:buf});
            buf='';
          }
          continue;
        } else {
          // reset partial hex if we hit a non-hex separator mid-token
          if (buf) out.push({text:buf});
          out.push({text:ch});
          buf = '';
        }
      }
      if (buf) out.push({text:buf});
      return out;
    }

    function triBitsToSigned(v3){return(v3<=4)?v3:(4-v3);}    

    // --- Animation state ---
    let currentAnim = null; // { timer, ops, idx, visited }
    const STEP_DELAY_MS = 20; // delay between each drawing command
    const DRAW_MS = STEP_DELAY_MS;       // how long each piece takes to draw
    
    function stopAnim(){
      if (currentAnim && currentAnim.rafId) cancelAnimationFrame(currentAnim.rafId);
      currentAnim = null;
    }
    
    function startAnim(ops, visited){
      stopAnim();
      const animStart = performance.now();

      // When each op *starts* becoming visible
      const theFirstVisibleAt = ops.map((_, i) => animStart + i * STEP_DELAY_MS);

      currentAnim = {
        ops, visited,
        animStart, firstVisibleAt: theFirstVisibleAt,
        rafId: null
      };

      const tick = (now) => {
        if (!currentAnim) return;

        // How many ops have "started" by now?
        let started = 0;
        while (started < ops.length && now >= currentAnim.firstVisibleAt[started]) started++;

        // Draw frame with progressive drawing
        drawFrameProgressive(now, started, ops, currentAnim.firstVisibleAt, visited);

        // Done when the last op has fully drawn
        const allDone = ops.length === 0 || (now >= currentAnim.firstVisibleAt[ops.length - 1] + DRAW_MS);
        if (!allDone) {
          currentAnim.rafId = requestAnimationFrame(tick);
        } else {
          // Save firstVisibleAt before stopping animation
          const firstVisibleAt = currentAnim.firstVisibleAt;
          stopAnim();
          drawFrameProgressive(now, ops.length, ops, firstVisibleAt, visited, /*isAnimating=*/false);
        }
      };

      currentAnim.rafId = requestAnimationFrame(tick);
    }

    function drawFrameProgressive(now, startedCount, ops, firstVisibleAt, visited, isAnimating = true){
      // Reset max Y tracking
      maxDrawnY = 0;
      
      // Only draw grid points in edit mode
      if (editorVisible) {
      drawGridPoints(s);
      }
      // Don't set lineWidth here - let each drawOp set its own thickness

      // First pass: draw all outlines
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0â†’1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpOutline(op, progress);
      }
      
      // Second pass: draw all main strokes on top
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0â†’1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpMain(op, progress);
      }

      // Show ONLY the red end marker when NOT animating AND in edit mode
      if (!isAnimating && editorVisible && visited && visited.length) {
        const endPix = applyItalicsTransform(toCanvas(visited[visited.length - 1]));
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(endPix.x, endPix.y, thickness * END_MARKER_RADIUS_MULTIPLIER, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Update canvas height progressively during animation (only in presentation mode)
      if (!editorVisible) {
        updateCanvasHeight();
      }
    }

    function drawOpOutline(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        // Track maximum Y coordinate
        maxDrawnY = Math.max(maxDrawnY, p1.y, p2.y);
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          maxDrawnY = Math.max(maxDrawnY, intermediate.y);
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw outline only - always black outline
        drawOutline();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Track maximum Y coordinate for arc
        maxDrawnY = Math.max(maxDrawnY, transformedCenter.y + op.ry);
        
        // Check if this is a complete circle (start=0, end=2Ï€)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw outline only - always black outline
        drawOutline();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Track maximum Y coordinate
          maxDrawnY = Math.max(maxDrawnY, transformedStart.y, transformedEnd.y);
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw outline only
          drawOutline();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        // Track maximum Y coordinate for point
        maxDrawnY = Math.max(maxDrawnY, c.y + thickness * POINT_RADIUS_MULTIPLIER);
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw outline only - always black outline (thinner for points)
        drawPointOutline();
      }
    }

    function drawOpMain(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Check if this is a complete circle (start=0, end=2Ï€)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw main stroke
          ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
          ctx.stroke();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw main fill
        ctx.fillStyle = op.color;
        ctx.fill();
      }
    }

    function drawOp(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        // Track maximum Y coordinate
        maxDrawnY = Math.max(maxDrawnY, p1.y, p2.y);
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          maxDrawnY = Math.max(maxDrawnY, intermediate.y);
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw outline for better visibility
        drawOutline();
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Track maximum Y coordinate for arc
        maxDrawnY = Math.max(maxDrawnY, transformedCenter.y + op.ry);
        
        // Check if this is a complete circle (start=0, end=2Ï€)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw outline for better visibility
        drawOutline();
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Track maximum Y coordinate
          maxDrawnY = Math.max(maxDrawnY, transformedStart.y, transformedEnd.y);
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw outline for better visibility
          drawOutline();
        
          // Draw main stroke
        ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        // Track maximum Y coordinate for point
        maxDrawnY = Math.max(maxDrawnY, c.y + thickness * POINT_RADIUS_MULTIPLIER);
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw outline for better visibility
        ctx.fillStyle = '#000000';
        ctx.fill();
        
        // Draw main fill
        ctx.fillStyle = op.color;
        ctx.fill();
      }
    }

    // Build ops (line/arc/point) in encounter order
    function buildOps(coloredItems){
      let xi=start.xi,yi=start.yi;
      const ops=[]; const visited=[{xi,yi}];
      let currentLetterIndex = getCurrentLetterIndex();
      let letterIndex = 0;

      for(const item of coloredItems){
        if(item.newline){
          // Move to the next text row boundary, regardless of current position
          yi = pad.top + 8 * (Math.floor((yi - pad.top) / 8) + 1);
          xi = pad.left; 
          visited.push({xi,yi});
          // Newline counts as a new letter
          letterIndex++;
          continue;
        }
        if (item.pipe) {
          // literal single '|', increment letter index
          letterIndex++;
          continue;
        }
        if (item.text && item.byte === undefined) {
          // free text / separators â€” ignore for drawing
          continue;
        }

        const b = item.byte;
        const bgColorSelectEl = document.getElementById('bgColorSelect');
        const backgroundColor = bgColorSelectEl.value;
        // Highlight current letter with red color only when Input field is focused, others with white
        const isInputFocused = document.activeElement === inputEl;
        const isCurrentLetter = letterIndex === currentLetterIndex && isInputFocused;
        // In editor mode, always use pure white. In presentation mode, blend with background
        const textColor = editorVisible ? '#ffffff' : blendColors(backgroundColor, '#ffffff', 0.62);
        const stroke = isCurrentLetter ? '#ff0000' : textColor;

        const a=(b>>7)&1;
        const xxx=(b>>4)&0b111;
        const bitB=(b>>3)&1;
        const yyy=b&0b111;
        const isZero=(xxx===0&&yyy===0);
        const ab=(a<<1)|bitB;

        if(isZero){
          if(ab===0b00){ ops.push({type:'point', xi, yi, color:stroke}); }
          else if(ab===0b01){ ops.push({type:'arc', cx:toCanvas({xi,yi}).x, cy:toCanvas({xi,yi}).y, rx:s, ry:s, start:0, end:Math.PI*2, acw:false, color:stroke}); }
          else if(ab===0b10){ ops.push({type:'arc', cx:toCanvas({xi,yi}).x, cy:toCanvas({xi,yi}).y, rx:s*0.5, ry:s*0.5, start:0, end:Math.PI*2, acw:false, color:stroke}); }
          else { yi=snapToLineTop(yi); }
          visited.push({xi,yi});
          continue;
        }

        const dx=triBitsToSigned(xxx),dy=triBitsToSigned(yyy);
        ({xi,yi}=preMoveWrap(xi,yi,Math.max(0,dx)));
        const from={xi,yi};
        const to={xi:xi+dx,yi:yi+dy};

        if(ab===0b11){
          // Invisible move
          xi=to.xi; yi=to.yi; visited.push({xi,yi});
          continue;
        }

        if(ab===0b00){
          ops.push({type:'line', from, to, color:stroke});
        }else{
          const p0=toCanvas(from),p1=toCanvas(to);
          let cx,cy,rx,ry,a0,a1; let semi=false;
          if(dx!==0&&dy!==0){
            rx=Math.abs(dx)*s; ry=Math.abs(dy)*s;
            if(ab===0b01){ cx=p0.x; cy=p0.y+dy*s; }
            else{          cx=p0.x+dx*s; cy=p0.y; }
            a0=angleOnEllipse(cx,cy,rx,ry,p0.x,p0.y);
            a1=angleOnEllipse(cx,cy,rx,ry,p1.x,p1.y);
          }else if(dx!==0&&dy===0){
            const r=Math.abs(dx)*s/2; rx=r; ry=r;
            cx=(p0.x+p1.x)/2; cy=p0.y;
            const movingRight = dx>0;
            a0 = movingRight ? Math.PI : 0;
            a1 = movingRight ? 0 : Math.PI;
            semi = true;
          }else if(dx===0&&dy!==0){
            const r=Math.abs(dy)*s/2; rx=r; ry=r;
            cx=p0.x; cy=(p0.y+p1.y)/2;
            const movingDown = dy>0;
            a0 = movingDown ? -Math.PI/2 : Math.PI/2;
            a1 = movingDown ?  Math.PI/2 : -Math.PI/2;
            semi = true;
          }
          if(rx&&ry){
            a0=normAngle(a0); a1=normAngle(a1);
            const acw = semi ? ((ab===0b01)?false:true) : anticlockwiseForShortest(a0,a1);
            ops.push({type:'arc', cx,cy,rx,ry,start:a0,end:a1,acw,color:stroke});
          }
        }

        xi=to.xi; yi=to.yi; visited.push({xi,yi});
      }
      return { ops, visited };
    }

    function renderInstant(ops, visited, skipHeightUpdate = false){
      // Reset max Y tracking
      maxDrawnY = 0;
      
      // Only draw grid points in edit mode
      if (editorVisible) {
      drawGridPoints(s);
      }
      // Don't set lineWidth here - let each drawOp set its own thickness
      
      // First pass: draw all outlines
      for(const op of ops){ drawOpOutline(op); }
      
      // Second pass: draw all main strokes on top
      for(const op of ops){ drawOpMain(op); }
      if(visited && visited.length){
        // Show only the ending marker (red) when in edit mode
        if (editorVisible) {
          const endPix=applyItalicsTransform(toCanvas(visited[visited.length-1]));
          ctx.fillStyle='red';ctx.beginPath();ctx.arc(endPix.x,endPix.y,thickness*3,0,Math.PI*2);ctx.fill();
        }
      }
      
      // Update canvas height based on drawn content (only in presentation mode and when not skipping)
      if (!editorVisible && !skipHeightUpdate) {
        updateCanvasHeight();
      }
    }

    // --- Contenteditable highlighting helpers ---
    const inputEl=document.getElementById('strInput');
    const ruleEl=document.getElementById('strRule');
    const outputEl=document.getElementById('strOutput');
    const sInputEl = document.getElementById('sInput');
    const sValueEl = document.getElementById('sValue');

    const escapeHTML = s => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    function getPlainText(el){ return el.textContent.replace(/\r/g,''); }

    function getCaretOffset(root){
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return 0;
      const range = sel.getRangeAt(0);
      const pre = document.createRange();
      pre.selectNodeContents(root);
      pre.setEnd(range.endContainer, range.endOffset);
      return pre.toString().length;
    }

    function setCaretOffset(root, target){
      target = Math.max(0, target);
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (target <= next) {
          const sel = getSelection();
          const range = document.createRange();
          range.setStart(node, target - count);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      const sel = getSelection();
      const r = document.createRange();
      r.selectNodeContents(root);
      r.collapse(false);
      sel.removeAllRanges(); sel.addRange(r);
    }


    // Basic "hex-hit" highlighter with current letter highlighting
    const HEX_CHAR_RE = /[0-9A-Fa-f]/;
    function basicHighlightHTML(raw){
      const currentLetterIndex = getCurrentLetterIndex();
      const esc = escapeHTML(raw);
      
      let letterIndex = 0;
      let html = '';
      let i = 0;
      let inComment = false;
      
      while(i < esc.length){
        const ch = esc[i];
        
        // Handle comment detection
        if(ch === '/' && esc[i+1] === '/'){
          inComment = true;
          html += '//';
          i += 2;
          continue;
        }
        if(inComment && (ch === '\n' || ch === '\r')){
          inComment = false;
          html += ch;
          i++;
          continue;
        }
        
        if(ch === '|'){
          const next = esc[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter
            letterIndex++;
            html += '||';
            i += 2;
          } else {
            // Letter separator
            letterIndex++;
            html += '|';
            i++;
          }
        } else if(HEX_CHAR_RE.test(ch) && HEX_CHAR_RE.test(esc[i+1])){
          // Found a hex pair
          const pair = esc.substr(i, 2);
          const isCurrentLetter = letterIndex === currentLetterIndex;
          
          // Check if this is an invisible move
          const byte = parseInt(pair, 16);
          const a = (byte >> 7) & 1;
          const xxx = (byte >> 4) & 0b111;
          const bitB = (byte >> 3) & 1;
          const yyy = byte & 0b111;
          const isZero = (xxx === 0 && yyy === 0);
          const ab = (a << 1) | bitB;
          
          // Invisible moves: ab===0b11 (both a and bitB are 1)
          const isInvisibleMove = ab === 0b11;
          
          if(isCurrentLetter){
            html += `<strong>${pair}</strong>`;
          } else if(isInvisibleMove && !inComment){
            html += `<span class="hex-hit">${pair}</span>`;
          } else {
            html += pair;
          }
          i += 2;
        } else {
          html += ch;
          i++;
        }
      }
      
      return html;
    }

    // Use basic highlighting
    function highlightEditor(){
      const raw = getPlainText(inputEl);
      const caret = getCaretOffset(inputEl);
      const html = basicHighlightHTML(raw);
      inputEl.innerHTML = html;
      setCaretOffset(inputEl, caret);
    }

    // Plain-text value getter used by renderer
    function getEditorValue(){ return getPlainText(inputEl); }

    // Get the current letter index (which space between | characters the cursor is in)
    function getCurrentLetterIndex(){
      const raw = getPlainText(inputEl);
      const caret = getCaretOffset(inputEl);
      
      let letterIndex = 0;
      let currentPos = 0;
      
      for(let i = 0; i < raw.length && currentPos < caret; i++){
        const ch = raw[i];
        
        if(ch === '|'){
          const next = raw[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter
            letterIndex++;
            i++;
            currentPos += 2;
          } else {
            // This is a letter separator
            letterIndex++;
            currentPos++;
          }
        } else {
          currentPos++;
        }
      }
      
      return letterIndex;
    }

    // Insert plain text at the current caret (collapses selection)
    function insertTextAtCaret(root, text) {
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return;

      const range = sel.getRangeAt(0);
      range.deleteContents();

      const tn = document.createTextNode(text);
      range.insertNode(tn);

      // move caret after the inserted text node
      range.setStartAfter(tn);
      range.setEndAfter(tn);
      sel.removeAllRanges();
      sel.addRange(range);

      // trigger highlight & render
      highlightEditor();
      renderNow();
    }

    // --- Lightweight undo/redo history ---
    const HISTORY_LIMIT = 100;
    const history = [];
    const redo = [];
    let snapshotTimer = null;

    function getState() {
      return { text: getEditorValue(), caret: getCaretOffset(inputEl) };
    }

    function applyState(st) {
      inputEl.textContent = st.text;  // plain text
      highlightEditor();
      setCaretOffset(inputEl, st.caret);
      renderNow();
    }

    function pushHistory() {
      const st = getState();
      const prev = history[history.length - 1];
      if (!prev || prev.text !== st.text || prev.caret !== st.caret) {
        history.push(st);
        if (history.length > HISTORY_LIMIT) history.shift();
        redo.length = 0; // clear redo on new branch
      }
    }

    function scheduleSnapshot() {
      clearTimeout(snapshotTimer);
      snapshotTimer = setTimeout(pushHistory, 250); // coalesce rapid edits
    }

    function undo() {
      if (history.length <= 1) return;
      const cur = history.pop();
      redo.push(cur);
      applyState(history[history.length - 1]);
    }

    function redoAction() {
      if (!redo.length) return;
      const st = redo.pop();
      history.push(st);
      applyState(st);
    }

    // --- Enter & clipboard behaviors ---
    // Intercept default paragraph for plain newline
    inputEl.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph') {
        e.preventDefault();
        insertTextAtCaret(inputEl, '\n');
        scheduleSnapshot();
      }
    });

    // Keydown fallback for Enter
    inputEl.addEventListener('keydown', (e) => {
      const mod = e.metaKey || e.ctrlKey;

      // Redo (Cmd+Shift+Z or Ctrl+Y)
      if (mod && ((e.key.toLowerCase() === 'z' && e.shiftKey) || e.key.toLowerCase() === 'y')) {
        e.preventDefault();
        redoAction();
        return;
      }

      // Undo (Cmd/Ctrl+Z without Shift)
      if (mod && e.key.toLowerCase() === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
        return;
      }

      // Plain Enter inserts '\n'
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
        e.preventDefault();
        insertTextAtCaret(inputEl, '\n');
        scheduleSnapshot();
      }
    });

    // Sanitize paste to plain text
    inputEl.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');
      console.log('Pasting text:', text);
      insertTextAtCaret(inputEl, text);
      // Delay highlighting to allow selection to be preserved
      setTimeout(() => {
        highlightEditor();
        renderNow();
        scheduleSnapshot();
      }, 0);
    });

    // --- Wiring (render + highlight) ---
    function renderNow(){
      try{
        const coloredItems = parseBytesWithColors(getEditorValue());
        const { ops, visited } = buildOps(coloredItems);
        stopAnim();
        
        // Always use static rendering in renderNow (animation is handled elsewhere)
        renderInstant(ops, visited);
        
        // Delay canvas expansion for 3D flip animation (only on first load)
        if (!editorVisible && currentCanvasHeight === 200) {
          setTimeout(() => {
            animationStartTime = performance.now();
          }, 1500); // Wait for flip animation to complete
        }
      }catch(e){
        console.error('Render error:',e);
        stopAnim();
      }
    }

    // Live update on every edit (typing, delete, IME commits, etc.)
    inputEl.addEventListener('input', () => {
      highlightEditor();   // rebuild colored spans
      renderNow();         // rebuild ops + redraw canvas
      scheduleSnapshot();  // coalesce undo snapshots
    });

    // Update highlighting when cursor position changes (click, arrow keys, etc.)
    document.addEventListener('selectionchange', () => {
      if (document.activeElement === inputEl) {
        // Only update if there's no active selection (just cursor movement)
        const sel = getSelection();
        if (!sel || sel.rangeCount === 0 || sel.isCollapsed) {
          highlightEditor();
          renderNow();
        }
      }
    });

    
    // Background color functionality
    const bgColorSelectEl = document.getElementById('bgColorSelect');
    
    // Populate color options dynamically
    function populateColorOptions() {
      const colors = getColors();
      const initialColor = colors[DEFAULT_PANEL_COLOR_INDEX]; // Default to yellowish color
      
      // Clear existing options
      bgColorSelectEl.innerHTML = '';
      
      // Add color options with hex values
      colors.forEach((color, index) => {
        const option = document.createElement('option');
        option.value = color;
        option.textContent = color; // Show the hex value
        if (color === initialColor) {
          option.selected = true;
        }
        bgColorSelectEl.appendChild(option);
      });
    }
    
    // Generate gradient from base color
    function generateGradientFromColor(baseColor) {
      // Convert hex to RGB
      const hex = baseColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // Create gradient with varying opacity
      return `linear-gradient(135deg, 
        rgba(${r},${g},${b},0.8) 0%, 
        rgba(${r},${g},${b},0.6) 25%, 
        rgba(${r},${g},${b},0.4) 50%, 
        rgba(${r},${g},${b},0.2) 75%, 
        rgba(${r},${g},${b},0.1) 100%)`;
    }
    
    // Update canvas background based on editor mode and selected color
    function updateCanvasBackground(selectedColor) {
      const canvasElement = document.getElementById('board');
      if (!editorVisible) {
        canvasElement.style.background = generateGradientFromColor(selectedColor);
      } else {
        canvasElement.style.background = '';
      }
    }
    
    // Initialize color options and set defaults
    populateColorOptions();
    
    const initialColor = getColors()[DEFAULT_PANEL_COLOR_INDEX];
    const colorIndicator = document.getElementById('bgColorIndicator');
    
    // Set initial values
    colorIndicator.style.backgroundColor = initialColor;
    updateCanvasBackground(initialColor);
    
    bgColorSelectEl.addEventListener('change', async () => {
      const selectedColor = bgColorSelectEl.value;
      const colorIndicator = document.getElementById('bgColorIndicator');
      
      // Update canvas background
      updateCanvasBackground(selectedColor);
      
      // Update color indicator
      colorIndicator.style.backgroundColor = selectedColor;
      
      // Update SVG glow to match
      await drawSvgBackground();
    });
    
    sInputEl.addEventListener('input', () => {
      s = parseInt(sInputEl.value, 10);
      thickness = s/10;
      sValueEl.textContent = s;
      renderNow();
    });

    // SVG input functionality
    const svgInputEl = document.getElementById('svgInput');
    svgInputEl.addEventListener('input', async () => {
      // Always update SVG display (preview in editor mode, background in non-editor mode)
        await drawSvgBackground();
    });
    

    // Hotkey listener for editor toggle (Ctrl+E or Cmd+E)
    document.addEventListener('keydown', async (e) => {
      if (e.key.toLowerCase() === 'e' && (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey) {
        // Only toggle if not typing in the editor
        if (document.activeElement !== inputEl && document.activeElement !== ruleEl && document.activeElement !== outputEl) {
          e.preventDefault();
          editorVisible = !editorVisible;
          
          // Toggle canvas-only mode for proper centering
          document.body.classList.toggle('canvas-only', !editorVisible);
          
          // Update canvas background based on new mode
          const bgColorSelectEl = document.getElementById('bgColorSelect');
          const selectedColor = bgColorSelectEl.value;
          
          updateCanvasBackground(selectedColor);
            await drawSvgBackground();
          
          // Clear canvas when switching modes to remove any lingering grid points
          ctx.clearRect(0, 0, width, height);
          
          // Reset wrapper height when switching modes  
          const wrapper = document.getElementById('canvasWrapper');
          if (editorVisible) {
            wrapper.style.height = cssH + 'px'; // Full height in edit mode
          }
          
          // Always animate in non-edit mode, static in edit mode
          if (!editorVisible) {
            preCalculateHeight(); // Pre-calculate height for smooth animation
            const coloredItems = parseBytesWithColors(getEditorValue());
            const { ops, visited } = buildOps(coloredItems);
            startAnim(ops, visited);
          } else {
            renderNow(); // redraw canvas (grid visibility will be handled in drawGridPoints)
          }
        }
      }
    });

    // Window resize listener to reposition SVG background
    window.addEventListener('resize', () => {
      if (!editorVisible) {
      }
    });

    // Initial
    window.addEventListener('load', async () => {
      // Start in non-edit mode (canvas-only)
      document.body.classList.add('canvas-only');
      // Load default content
      inputEl.textContent = defaultContent;
      // Initialize SVG background
      svgInputEl.value = defaultSvgBackground;
      highlightEditor();
      // Update color options for background
      populateColorOptions();
      // Pre-calculate height for smooth animation
      preCalculateHeight();
      // Start with animated rendering instead of static
      const coloredItems = parseBytesWithColors(getEditorValue());
      const { ops, visited } = buildOps(coloredItems);
      startAnim(ops, visited);
      pushHistory(); // seed history
      
      // Initialize background for non-edit mode
      await drawSvgBackground();
      
      // Add event listeners after DOM is ready
      const italicsCheckboxEl = document.getElementById('italicsCheckbox');
      
      if (italicsCheckboxEl) {
        italicsCheckboxEl.addEventListener('change', ()=>{
          italicsMode = italicsCheckboxEl.checked;
          renderNow();       // redraw canvas with new italics mode
        });
      }
    });
  </script>
</body>
</html>
