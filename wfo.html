<!doctype html>
<html lang="en">
<head>
  <script>
const defaultContent = `
//t d
04|88 ca 05 d5 59 91 10 02|
//k g
88 c8 62 88 04|88 c8 02 38 e2

||88
//trinity
98 03 91|1d d5 30|dd 00|8a 00|ae 51 11|88 98 03 91|2e a2 ef 00|
//u^n
ca 08|cd 02|d5 81 20|
//in
2e a2|e9 00|
//esens
88 a8 30 64 88|c8 98 50 82 10|50 82 10|d9 00|88 c8 8a 50 82 10|
//@nd
87|8c 00|88 ca 05 d5 59 91 10 02|
//undivaid&d
88 ba 02|d5 81 20|88 aa 05 d5 59 91 10 01 91|2e a2|88 20 62 88 04|8e 40 20|fd 02|88 b8 9a 05 d5 59 91 10 02|8e b2|88 9a 05 d5 59 91 10 02

//janlwk
||88
19 03 91|88 da 40|e9 00|88 c8 60 03 02|88 8b 28 e1 40|88 a8 62 88 04|

//picard
88 b8 10 09 50 10 09 50 88 03 91|2e a2|88 a8 62 88 04|88 8a 10 19 91|10 1d d5 30|88 9a 05 d5 59 91 10 02

//uili^m
||88
9b 08|8e 00|88 c8 60 03 91|2e a2|ee 02 91|88 40 e8 04|

//ty
88 b8 03 91|2e a2 88 dd 51 30|

//raikr
88 19 d1 50 02|8e 40 20|ed 02|88 c8 62 88 03 91|1d d5 30

//dy@n^
||88
aa 05 d5 59 91 10 01 91|2e a2 ef 00|88 c8 a8 74|30|88 9a 02|

//troi
88 a8 03 91|1d d5 30|88 b8 84 2e e6|8a 00

//uorf
||88
9b 08|88 c8 84 2e e6 59 b3 10|1d d5 30|88 d8 28 a0 e8 04

//ded^
||88
aa 05 d5 59 91 10 02|88 8a 40 10 f8 e8 89 40 10|88 8a 05 d5 59 91 10 02|88 aa 02

//u&sly
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
||88
9b 08 8d b2|88 b8 8a 50 82 10 61|88 8d 02 05 28 01
`;
const defaultSvgBackground =`
<svg version="1.1" viewBox="0 0 1200 1200" xmlns="http://www.w3.org/2000/svg">
  <g>
  <animateTransform
    attributeName="transform"
    type="rotate"
    from="0 600 600"
    to="360 600 600"
    dur="6s"
    repeatCount="indefinite" />
    <path d="m599.14 360.49c-28.715 0-56.715 5.168-84 15.508-17.23-39.918-31.945-74.668-44.152-104.25-12.203-29.578-18.738-47.383-19.602-53.414-2.582-15.508 2.5859-53.559 15.508-114.16 36.188-9.4766 72.082-15.074 107.7-16.801l-0.86328 12.492 7.3242 4.3086 3.4453 5.6016 31.879 0.42969 2.582-5.168 7.7539-5.6016 2.5859-11.629c69.211 4.3086 134.25 21.395 195.14 51.262l-3.0156 11.629 3.8789 8.6172-0.42969 5.5977 28 15.508 6.0273-3.4453h8.6172l5.168-10.77c61.746 39.344 113.01 89.312 153.79 149.91l-8.6133 7.75-1.293 9.4805-3.0156 4.7383 16.801 27.566 6.4609 0.43359 7.3242 4.3047 10.336-6.8906c18.094 35.035 31.734 70.359 40.922 105.97-46.234 41.066-75.957 64.043-89.168 68.922-6.0312 2.0117-25.055 5.2422-57.078 9.6953-32.02 4.4492-69.855 9.2617-113.51 14.43-11.773-72.945-49.535-128.8-113.29-167.57l3.4453-6.0312c0.85938-1.4336 0.57422-2.582-0.86328-3.4453l-4.3047-2.5859c-2.0117-0.57422-3.1602-0.14062-3.4492 1.293l-3.4453 5.6016c-35.898-19.527-74.094-29.293-114.59-29.293zm-77.105 397.17-7.3242 12.492 1.293 0.86328 2.5859 1.293-0.86328 3.0156-7.3242 22.828-0.42969 0.43359v0.42969l-158.52 274.4-1.7227 3.4492-3.0156-2.1562-33.168-18.953-3.0156-1.7227 1.7227-3.4453 158.52-274.4 0.42969-0.42969 16.371-18.094 2.1523-2.1523 2.1523 1.293 1.7266 0.85938 6.8906-12.492 1.7227-3.0156 3.4453 1.7227 15.078 8.6172 3.0156 1.7227zm-15.508 12.062 7.3242-12.922-8.6172-4.7383-7.3242 12.492-1.7227 3.0156-3.4453-1.7227-1.7227-1.293-14.215 15.508-156.37 271.38 26.707 15.078 156.37-270.95 6.4609-19.816-2.1523-1.293-3.0156-1.7227zm-5.6016-315.32-7.3203-12.492-0.86328 0.86328-3.0156 1.293-1.7227-2.1562-16.371-17.66-0.42969-0.42969v-0.43359l-158.52-274.4-1.7227-3.0156 3.0156-2.1523 33.168-18.953 3.0156-1.7266 1.7227 3.0156 158.52 274.4 0.43359 0.42969v0.42969l7.3203 23.262 0.86328 2.5859-2.5859 1.7227-1.293 0.42969 7.3242 12.492 1.7227 3.4492-3.0156 1.7227-15.074 8.6133-3.4492 2.1562zm-2.582-19.383 7.3203 12.492 8.6172-4.7383-7.3242-12.922-1.7227-3.0156 3.0156-1.7227 1.7227-1.293-6.0312-19.816-156.37-270.95-26.707 15.508 156.37 270.52 14.215 15.508 1.7227-0.86328 3.4492-1.7227zm275.69 152.92h14.215v-4.7383l3.0156-0.42969 23.691-5.168h321.36v45.66h-320.93l-0.42969-0.42969-23.691-5.1719-3.0156-0.42969v-4.7383h-18.094v-24.555zm18.094 7.3242h-14.648v9.9062h18.523v6.0312l20.246 4.3086h312.74v-30.586h-312.74l-20.246 4.3086v6.0312zm-192.99-24.555c7.7539 0 14.793 2.8711 21.109 8.6172 5.7422 6.3164 8.6172 13.352 8.6172 21.105 0 8.043-2.875 14.934-8.6172 20.68-6.0312 6.0273-13.066 9.043-21.109 9.043-8.3281 0-15.219-3.0156-20.676-9.043-5.7422-5.1719-8.6133-12.062-8.6133-20.68 0-8.3281 2.8711-15.363 8.6133-21.105 5.7461-5.7461 12.637-8.6172 20.676-8.6172zm0 7.3242c-6.0273 0-11.199 2.1523-15.508 6.4609-4.3047 4.3086-6.4609 9.6211-6.4609 15.938 0 6.6055 2.1562 11.777 6.4609 15.508 3.7344 4.3086 8.9062 6.4609 15.508 6.4609 6.3203 0 11.488-2.1523 15.508-6.4609 4.5977-4.0195 6.8945-9.1875 6.8945-15.508 0-6.0312-2.2969-11.344-6.8945-15.938-4.3047-4.3086-9.4766-6.4609-15.508-6.4609zm0-43.078c17.809 0 33.172 6.4609 46.094 19.387 12.637 12.633 18.953 28 18.953 46.09 0 17.805-6.3164 33.172-18.953 46.094-13.211 12.637-28.574 18.953-46.094 18.953-17.805 0-33.168-6.3164-46.09-18.953-12.637-12.922-18.953-28.289-18.953-46.094 0-18.09 6.3164-33.457 18.953-46.09 12.922-12.926 28.285-19.387 46.09-19.387zm0 7.3242c-15.508 0-29.148 5.7422-40.922 17.23-11.199 11.199-16.801 24.84-16.801 40.922 0 15.797 5.6016 29.293 16.801 40.492 11.488 11.488 25.129 17.23 40.922 17.23 15.797 0 29.438-5.7422 40.926-17.23 11.199-11.199 16.801-24.695 16.801-40.492 0-16.082-5.6016-29.723-16.801-40.922-12.062-11.488-25.703-17.23-40.926-17.23zm0-56.863c-12.348 0-23.836 1.7227-34.461 5.1719-7.4648-16.371-16.367-36.617-26.707-60.738 18.379-7.1797 38.77-10.77 61.168-10.77 22.977 0 44.371 3.875 64.188 11.629l1.7227 12.492-2.5859 16.801-15.938 35.754c-14.359-6.8906-30.152-10.34-47.387-10.34zm64.617 19.816 25.414-32.738 12.062-9.0469 12.492-3.4453c34.75 28.719 56.145 65.191 64.184 109.41-11.199 1.4375-22.328 2.7305-33.383 3.8789-11.059 1.1484-22.043 2.2969-32.953 3.4453-6.3203-30.152-22.258-53.988-47.816-71.508zm47.816 118.03c10.91 1.4375 21.895 2.8008 32.953 4.0938 11.055 1.2891 22.184 2.5117 33.383 3.6602-7.4648 43.363-28.285 79.406-62.461 108.12l-11.199-4.7383-13.785-10.77-22.832-31.445c23.262-16.941 37.91-39.918 43.941-68.922zm-60.309 79.262 15.078 37.906 1.7227 15.078-3.4453 13.785c-21.254 8.0391-43.078 12.062-65.48 12.062-20.961 0-41.496-3.5898-61.598-10.77 8.0391-19.531 16.941-39.918 26.707-61.172 12.062 3.7344 23.691 5.6016 34.891 5.6016 18.383 0 35.754-4.1641 52.125-12.492zm-127.94-15.938c-15.223 20.676-28.434 38.48-39.633 53.414-34.746-29.004-55.711-65.191-62.891-108.55l11.629-9.0469 15.941-6.0273 36.613-3.8789c2.8711 29.867 15.652 54.562 38.34 74.094zm-38.77-94.34-38.77-5.168-14.215-6.0312-11.199-11.199c7.7539-43.941 29.004-80.41 63.754-109.42 6.6016 8.9023 13.137 17.805 19.598 26.707 6.4609 8.9062 13.141 17.809 20.031 26.711-24.125 20.961-37.191 47.098-39.199 78.398zm351.51 45.66c43.363 5.1719 80.984 9.9805 112.86 14.434 31.879 4.4492 50.688 7.6797 56.434 9.6914 14.355 5.168 44.367 28.145 90.027 68.922-9.4766 35.898-22.398 69.93-38.766 102.09l-9.9102-6.4609-7.3242 4.3047h-6.4609l-16.367 28 3.0156 4.7383 0.85938 9.4805 8.1875 7.3203c-37.047 56.863-84.145 104.82-141.29 143.88l-8.1875-8.6172-9.4766-0.85938-4.7383-3.0156-27.566 16.801v6.4609l-4.3086 7.7539 6.8906 10.336c-64.039 34.461-132.82 54.133-206.34 59.016l-3.0156-12.922-7.3242-5.6016-3.0156-5.168-31.875 0.86328-3.4492 5.5977-7.3203 4.3086 0.85938 13.785c-39.629-1.7227-76.965-7.4688-112-17.23-12.922-61.457-17.949-99.363-15.078-113.72 0.86328-5.7461 7.3242-23.406 19.387-52.984 12.062-29.582 26.707-64.617 43.938-105.11 26.996 10.625 55.141 15.938 84.43 15.938 41.645 0 80.988-10.48 118.03-31.445l3.4492 5.6016c0.57422 1.7227 1.7227 2.0078 3.4453 0.85938l4.3086-2.582c0.85938-0.86328 1.0039-2.0117 0.42969-3.4492l-3.0156-5.5977c61.742-38.195 98.504-93.336 110.28-165.42zm-387.26 148.62c-25.848 34.75-48.605 64.688-68.277 89.816-19.672 25.125-31.805 39.559-36.398 43.289-12.062 10.34-47.531 24.988-106.4 43.941-24.984-24.41-47.957-52.555-68.922-84.434l12.062-6.0273v-8.6172l3.0117-5.6016-15.938-28h-5.168l-9.0469-3.4453-12.492 3.8789c-31.301-61.457-49.25-126.36-53.848-194.71l13.355-3.0156 5.6016-7.7539 5.168-2.5859-0.86328-32.309-5.5977-3.4453-4.3086-7.3242-14.215 0.86328c2.2969-72.945 19.957-142.44 52.984-208.49l13.355 3.875 8.6133-3.4453h5.6016l15.938-28-3.4453-6.0312v-8.6133l-12.926-6.0312c20.68-31.879 44.516-61.312 71.508-88.309 58.012 18.953 93.336 33.457 105.97 43.508 4.3047 4.0195 16.367 18.668 36.184 43.938 19.816 25.273 42.789 55.281 68.922 90.031-58.586 47.387-88.449 108.55-89.602 183.51h-4.7383c-1.7227 0-2.582 0.86328-2.582 2.5859l0.42969 5.168c0 1.4375 0.71875 2.1523 2.1523 2.1523h4.7383c2.0117 73.52 31.734 133.4 89.172 179.63zm641.84 71.938 24.555 6.4609 2.1562-3.875 9.9062 1.7227c6.6055-13.496 12.062-25.273 16.367-35.324l-4.7383-7.3203h8.1875c5.7422-14.934 10.77-28.145 15.074-39.633l-6.8906-7.7539 9.9062-1.293c4.5977-14.934 8.4727-28.574 11.633-40.922l-6.8945-5.6016 8.6172-3.4453c3.4453-15.793 5.7422-29.578 6.8906-41.352l-8.1836-4.7422-0.85938-3.4453-31.449-14.645c1.1484-9.4766 2.0117-19.672 2.5859-30.586h9.9062c2.875 0 4.3086-1.4336 4.3086-4.3086v-4.3047h-14.215c0.28516-3.7344 0.42969-9.6211 0.42969-17.664 0-8.0391-0.14453-14.07-0.42969-18.09h14.215v-4.3086c0-2.5859-1.4336-3.8789-4.3086-3.8789h-9.9062c-1.1484-16.082-2.1523-28-3.0156-35.754l29.723-13.781 0.86328-3.8789 8.6133-4.3086c-1.7227-12.922-4.1641-26.852-7.3203-41.785l-8.6172-3.0156 6.4609-6.0273c-4.0195-14.648-7.8984-28.145-11.629-40.492l-9.9102-1.7266 6.8945-7.3203c-5.7461-16.082-10.914-29.293-15.508-39.633h-7.7539l4.7383-7.7539c-5.1719-12.059-10.77-23.691-16.801-34.891l-9.9062 1.7227-2.1562-3.8789-24.121 6.4648-4.3086-7.7539 6.8906-3.8789-2.582-4.3086-6.8945 3.8789-6.4609-11.633 6.8945-4.7383-2.5859-3.875-6.8906 4.3086-2.1562-4.3086 16.801-19.816-0.86328-3.875 5.6016-7.7539c-7.1797-11.203-15.219-22.688-24.125-34.465l-10.766 1.293 4.7383-8.1836c-10.055-12.637-19.098-23.406-27.141-32.309l-9.0469 1.7227 2.5859-8.6133c-9.7656-9.7656-19.961-19.527-30.586-29.293l-9.043 3.8789 2.1523-9.9102c-7.4688-6.3164-18.668-15.219-33.602-26.707l-6.4609 4.3086v-9.0469c-9.1875-6.3164-19.816-13.641-31.875-21.969l-7.7539 6.8906-3.8789-2.582-18.09 18.09-5.6016-3.875 3.875-6.4609-4.3047-2.5859-4.3086 6.8906-11.199-6.8906 3.4453-7.3242-4.3086-2.1523-3.4453 6.8906-3.8789-1.7227 4.7383-26.277-2.582-3.0156 0.85938-9.4766c-12.922-6.6055-25.699-12.492-38.336-17.66l-8.6172 6.4609v-9.4766c-15.508-6.3164-28.574-11.059-39.199-14.215l-7.3242 6.0312-1.7227-9.0469c-12.348-3.4453-26.133-6.6055-41.352-9.4766l-6.0312 7.7539-3.4492-9.9102c-15.219-2.582-29.148-4.5938-41.781-6.0312l-3.8789 6.8945-4.3086-7.7539c-11.484-1.4375-24.41-2.4414-38.77-3.0156l-3.4453 9.4766h-4.3086l-6.4609 24.125h-2.1523l0.42969-7.7539-5.168-0.43359-0.42969 8.6172h-12.926l-0.42969-7.7539h-4.7383v7.7539h-8.1836l-6.4609-24.125h-4.3086l-3.8789-9.9062c-7.4648 0.57422-20.387 1.7227-38.77 3.4453l-3.875 8.1836-3.8789-7.3203c-20.676 3.4453-34.746 5.7422-42.215 6.8906l-3.0156 9.9102-6.0312-7.7539c-10.336 2.0078-24.121 5.4531-41.352 10.336l-1.293 8.6172-7.3242-6.0312c-13.211 4.3086-26.418 9.332-39.629 15.078v9.4766l-2.5859 2.582 3.0156 32.738c-12.637 5.7461-22.113 10.34-28.43 13.785l-4.3086-7.7539c-1.7227-2.2969-3.5898-2.7266-5.6016-1.293l-3.875 1.7266 6.4609 11.199c-9.1875 4.8828-19.527 10.77-31.016 17.66l-6.4609-10.77-3.4453 2.1562c-2.2969 1.1484-2.8711 3.0117-1.7227 5.5977l4.3047 7.7539c-4.3047 2.5859-14.215 9.332-29.723 20.246l-25.414-17.66-3.875 0.85938-8.1875-4.7383c-10.625 7.7539-21.395 16.656-32.305 26.707l1.2891 9.4805-8.1836-3.0156c-10.34 9.7617-20.102 19.957-29.293 30.582l3.4453 9.0469-9.9062-1.7227c-6.3164 7.1797-15.219 18.234-26.707 33.168l4.3086 6.4609-9.0469-0.42969c-7.7539 10.914-15.078 21.684-21.969 32.309l6.4609 7.7539-2.1523 3.875 17.66 17.664-4.7383 7.3242-6.8945-3.8789-2.582 4.3086 6.8906 3.875-6.8906 11.633-6.8945-3.4453-2.582 4.3047 7.3203 3.4492-2.582 3.875-25.848-4.3086-2.5859 2.5859-9.9062-0.86328c-4.8828 9.1914-10.77 21.969-17.66 38.34l6.4609 8.6172-9.4766-0.43359c-5.7461 12.926-10.484 26.277-14.215 40.062l5.5977 6.8906-8.6133 1.7266c-2.875 10.336-6.1758 23.977-9.9102 40.922l8.1875 6.4609-9.9102 3.4453c-2.582 13.211-4.7383 27.141-6.4609 41.785l7.3242 3.8789-8.1875 3.875c-0.85938 8.3281-1.8633 21.25-3.0117 38.77l9.9062 3.4453v4.7383l24.121 6.4609v6.8945h-7.7539l-0.42969 5.168h8.1836v12.922l-8.1836 0.86328 0.42969 4.7383 7.7539-0.42969v4.3086l-24.984 9.043-0.85938 3.8789-9.0469 3.875c0.28906 14.359 1.5781 28.289 3.875 41.785l9.9102 3.8789-8.1836 4.7383c1.7227 16.082 4.1641 30.008 7.3203 41.785l8.6172 3.4453-6.4609 5.5977c3.4453 14.934 7.4648 28.434 12.059 40.492l9.9102 1.7266-6.8945 7.3203c4.8828 14.359 10.055 27.57 15.508 39.633l7.7539-0.43359-4.3047 7.7539c5.168 12.062 10.766 23.695 16.797 34.895l9.9102-1.7227 2.1523 3.875 24.555-6.4609 0.85937 1.7227-6.8906 3.8789 2.1523 4.3086 7.3242-3.8789 6.8945 11.629-6.8945 3.8789 2.5859 4.3086 6.4609-3.8789 4.3086 6.8945-17.664 18.09 2.1562 3.8789-6.4609 7.7539c5.168 8.3281 12.492 18.953 21.969 31.875l9.0469-0.42969-3.8789 6.4609c8.6172 12.062 17.52 23.117 26.707 33.168l9.9102-1.7227-3.4492 9.0469c10.34 11.773 20.105 21.828 29.293 30.156l8.6172-2.5859-1.7227 9.0469c9.7617 9.1875 20.676 18.09 32.738 26.707l8.1836-4.7383 3.875 0.85938 26.277-18.52c11.488 8.0391 20.246 13.926 26.277 17.66l-4.3086 7.3242c-1.7227 2.582-1.1484 4.5938 1.7266 6.0273l3.4453 1.7266 6.0312-10.77c10.336 6.6055 20.676 12.633 31.016 18.09l-6.0312 10.77 3.875 2.1562c2.0117 1.7227 3.8789 1.1484 5.6016-1.7266l4.3086-7.3203c6.8906 3.7305 17.805 9.0469 32.738 15.938l-3.0156 30.586 3.0156 2.582-0.43359 9.4766c11.488 5.1719 24.844 10.055 40.062 14.648l6.8945-6.0312 2.1523 8.6133c12.922 4.3086 26.562 7.7539 40.922 10.34l6.0312-7.7539 3.0156 9.9102c14.645 2.8711 28.719 5.0234 42.215 6.4609l3.8789-6.8945 4.3047 7.7539c11.203 1.7227 23.98 2.7305 38.34 3.0156l3.4453-9.4766h4.7383l6.4609-24.121 8.6172 0.42969v7.7539h4.7383l0.42969-7.7539h13.355l0.42969 8.1836 4.7383-0.42969-0.42969-7.7539h4.7383l9.0469 24.555 3.875 1.2891 3.8789 8.6172c13.496-0.28906 27.426-1.5781 41.785-3.875l4.3047-9.9102 4.7383 8.6172c12.637-1.4375 26.422-3.8789 41.355-7.3242l3.4453-9.0469 5.6016 6.8945c15.508-4.3086 29.148-8.3281 40.922-12.062l1.293-9.9102 7.7539 6.8945c13.496-4.5938 26.707-9.9062 39.629-15.938l-0.42969-7.7539 7.7539 4.7383c11.488-5.1719 23.117-10.77 34.895-16.801l-1.7227-9.9062 3.875-2.1562-6.8906-24.555 6.4609-3.0156 3.4453 6.4648 4.7383-2.5859-3.875-6.4609 11.199-6.8945 4.7383 6.8945 3.875-3.0156-4.3086-6.0312 3.8789-2.1523 20.246 16.797 3.875-0.85938 7.7539 5.5977c12.062-7.4648 23.551-15.648 34.465-24.551l-1.293-10.77 8.1836 5.168c7.1797-5.457 17.949-14.504 32.309-27.137l-1.7227-9.0469 8.6133 2.582c6.6055-6.6016 16.227-16.797 28.863-30.582l-3.4453-9.4766 9.9062 2.1523c10.34-12.348 19.098-23.406 26.277-33.168l-4.3086-6.8945 9.0469 0.43359c7.7539-10.629 15.078-21.398 21.969-32.309l-6.4609-7.7539 2.1523-3.8789-17.66-17.66 0.85938-2.1523 6.4648 4.7383 3.0156-4.3086-6.8945-4.3086 6.4609-11.629 6.8945 3.875 2.582-4.7383-6.8906-3.4453z" fill-rule="evenodd"/> </svg>
  </g>
</svg>`;
</script>
  <meta charset="utf-8" />
  <title>Wfo Writer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23000'/><circle cx='50' cy='50' r='25' fill='%23fff'/></svg>">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    /* CSS Variables for dark mode support */
    :root { 
      --canvas-bg: #fff;
      --grid-color: #ddd;
      --border-color: #ccc;
      --button-bg: #f8f8f8;
      --button-border: #ddd;
    }
    
    /* Override Pico CSS for dropdown display */
    #bgColorSelect {
      color: inherit !important;
    }
    
    #bgColorSelect option {
      color: inherit !important;
    }
    
    /* 3D flip animation for presentation card */
    .canvas-only {
      perspective: 1000px;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .canvas-only .grid {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    
    .canvas-only .grid > div:first-child {
      transform-style: preserve-3d;
      animation: cardFlipIn 1.5s ease-out forwards;
      position: relative;
    }
    
    /* Glow effect emanating from behind the card */
    .canvas-only .grid > div:first-child::before {
      content: '';
      position: absolute;
      top: -80px;
      left: -30px;
      right: -30px;
      bottom: -80px;
      background: radial-gradient(ellipse, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.4) 20%, rgba(255, 255, 255, 0.2) 40%, transparent 70%);
      border-radius: 30px;
      z-index: -1;
      opacity: 0;
      animation: glowAppear 1.5s ease-out forwards;
      filter: blur(10px);
    }
    
    @keyframes cardFlipIn {
      0% {
        transform: rotateX(90deg) rotateY(90deg);
        opacity: 0;
      }
      50% {
        transform: rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
      100% {
        transform: rotateX(0deg) rotateY(0deg);
        opacity: 1;
      }
    }
    
    @keyframes glowAppear {
      0% {
        opacity: 0;
        transform: scale(0.3);
      }
      20% {
        opacity: 1;
        transform: scale(1.5);
      }
      100% {
        opacity: 0.6;
        transform: scale(1);
      }
    }
    
    :root.dark {
      --canvas-bg: #2a2a2a;
      --grid-color: #555;
      --border-color: #666;
      --button-bg: #333;
      --button-border: #666;
    }
    
    /* Canvas-specific styles only */
    canvas { 
      width: 400px; 
      height: 1000px; 
      display: block;
      position: relative;
      z-index: 1;
    }
    
    /* Specific class for custom backgrounds */
    canvas.has-custom-background {
      background: var(--custom-bg) !important;
    }
    
    .mono-grid{ 
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; 
      white-space: pre; 
    }

    .ce-editor {
      font: 13px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      white-space: pre-wrap; 
      word-break: break-word; 
      tab-size: 2;
      min-height: 20em;
      padding: 6px 8px;
      border: 1px solid var(--border-color); 
      border-radius: 6px;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: auto;
    }
    
    .hex-hit {
      background: rgba(255, 230, 0, .6);
      border-radius: 3px;
    }
    
    .current-letter {
      /* Bold text is handled by <strong> tag, no additional styling needed */
    }
    
    .byte { font-weight: 600; }
    
    /* Size subscript alignment */
    sub { vertical-align: sub; font-size: 0.8em; }
    
    /* Responsive layout fixes */
    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
    }
    
    /* Prevent overlap in edit mode at medium widths */
    @media (max-width: 1000px) and (min-width: 769px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 1rem;
      }
      
      aside {
        min-width: 300px;
      }
    }
    
    /* Ensure canvas doesn't shrink below its natural width */
    canvas {
      min-width: 400px;
    }
    
    /* Better grid behavior for wider screens */
    @media (min-width: 1001px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 2rem;
      }
    }
    
    /* Canvas centering when sidebar is hidden */
    .canvas-only .grid {
      display: flex;
      justify-content: center;
    }
    
    .canvas-only aside {
      display: none !important;
    }
    
    /* Monitor/glossy effect for presentation mode */
    .canvas-only canvas {
      background: linear-gradient(135deg, 
        rgba(109,191,232,0.8) 0%, 
        rgba(40,161,222,0.6) 25%, 
        rgba(31,140,194,0.4) 50%, 
        rgba(51,160,214,0.2) 75%, 
        rgba(20,120,180,0.1) 100%);
      box-shadow: 
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.1),
        0 8px 32px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255,255,255,0.1);
      filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
      border-radius: 16px;
      padding: 1.5rem;
      position: relative;
    }
    
    /* Add a subtle screen reflection effect */
    .canvas-only canvas::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, 
        rgba(255,255,255,0.1) 0%, 
        rgba(255,255,255,0.05) 50%, 
        transparent 100%);
      border-radius: 16px 16px 0 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <main class="container-fluid">
    <div class="grid">
      <div>
        <div id="canvasWrapper" style="position: relative; overflow: hidden; padding-bottom: 1.5rem; border-radius: 16px;">
          <canvas id="board" width="400" height="1000" aria-label="drawing canvas"></canvas>
        </div>
</div>
      <aside>
        <details>
          <summary>Instruction</summary>
      <small>
        <strong>Encoding:</strong> Each byte is <code>axxxbyyy</code> (MSB→LSB), where <code>xxx</code> and <code>yyy</code> are 3-bit values mapped via <code>(v<=4?v:4-v)</code>.
        <br>
        <div class="mono-grid">bit7 bit6..4 bit3 bit2..0
a     xxx    b    yyy</div>
        <br>
        <strong>Line type (<code>ab</code>):</strong>
        <br>
        <div class="mono-grid">00 line
01 elliptical arc type 1
10 elliptical arc type 2
11 invisible (move only)</div>
        <br>
        <strong>Zero move:</strong> If <code>xxx=000</code> and <code>yyy=000</code>, behavior depends on ab:
        <div class="mono-grid">00 point
01 circle radius 1
10 circle radius 1/2
11 snap to top of textline (move only)</div>
        <br>
            <strong>Pipes:</strong>
            <br>
            <code>|</code> cycles color
            <br>
            <code>||</code> moves to next text line
            <br>
            <br>
            <strong>Shortcuts:</strong>
            <br>
            <code>Ctrl+E / Cmd+E</code> toggles editor
      </small>
        </details>
        
        <details>
          <summary>Option</summary>
          <div class="grid">
            <div>
              <input id="italicsCheckbox" type="checkbox" checked/>
              <label for="italicsCheckbox">Italics</label>
            </div>
            <div>
              <label for="sInput"><sub>Size </sub><sub id="sValue">5</sub></label>
              <input id="sInput" type="range" min="2" max="20" value="5"/>
            </div>
            <div>
              <label for="bgColorSelect"><sub>Background <span id="bgColorIndicator" style="display: inline-block; width: 12px; height: 12px; background-color: #000000; border: 1px solid #ccc; margin-left: 4px; vertical-align: middle;"></span></sub></label>
              <select id="bgColorSelect">
                <option value="transparent">Transparent</option>
              </select>
            </div>
          </div>
        </details>
        
        <details>
          <summary>Svg</summary>
          <div>
            <label for="svgInput"><sub>Background Svg</sub></label>
            <textarea id="svgInput" rows="8" placeholder="Enter SVG code here...">
              ${defaultSvgBackground}
            </textarea>
            <div id="svgPreview" style="margin-top: 1rem; padding: 1rem; border: 1px solid #ccc; border-radius: 4px; background: white; min-height: 100px; display: none;">
              <div id="svgPreviewContent"></div>
            </div>
          </div>
        </details>
        
        <details>
          <summary>Rule</summary>
          <div id="strRule" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details>
          <summary>Input</summary>
          <div id="strInput" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details>
          <summary>Output</summary>
          <div id="strOutput" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
    </aside>
  </div>
  </main>
  <script>
    let italicsMode = true; // toggled by italics checkbox
    let editorVisible = false; // toggled by E key
    let maxDrawnY = 0; // track the lowest point of drawn content
    let s=5;let thickness=s/10;const pad={left:1,top:1,right:1};const start={xi:pad.left,yi:pad.top};
    const canvas=document.getElementById('board');const ctx=canvas.getContext('2d', { alpha: true });
    const cssW=400,cssH=1000;
    let currentCanvasHeight = 200; // start small for smooth expansion
    let targetCanvasHeight = cssH; // target height for smooth animation
    let animationStartTime = 0; // when height animation started
    const dpr=window.devicePixelRatio||1;
    if(dpr!==1){canvas.width=cssW*dpr;canvas.height=cssH*dpr;canvas.style.width=cssW+'px';canvas.style.height=cssH+'px';ctx.scale(dpr,dpr);}    
    const width=cssW,height=cssH;let gridX=Math.floor(width/s);
    
    // Configure canvas for round line caps
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Color palette (cycles each time a SINGLE '|' is encountered)
    const COLORS = ['#000000','#8c0004','#f34001','#f8af00','#0ccc0e','#3441fc','#4000c0','#350063','#808080'];
    
    function getColors() {
      return COLORS;
    }
    
    // Drawing constants
    const OUTLINE_THICKNESS_MULTIPLIER = 6;
    const MAIN_THICKNESS_MULTIPLIER = 4;
    const POINT_OUTLINE_THICKNESS_MULTIPLIER = 2;
    const POINT_RADIUS_MULTIPLIER = 4;
    const END_MARKER_RADIUS_MULTIPLIER = 3;
    
    // UI constants
    const DEFAULT_PANEL_COLOR_INDEX = 3;
    
    // Helper function to draw outline with consistent styling
    function drawOutline(isPoint = false) {
      // Skip outlines in editor mode
      if (editorVisible) return;
      
      const bgColorSelectEl = document.getElementById('bgColorSelect');
      const backgroundColor = bgColorSelectEl.value;
      
      // Blend background color with #404040 (50% interpolation)
      const blendedColor = blendColors(backgroundColor, '#404040', 0.5);
      
      ctx.strokeStyle = blendedColor;
      ctx.lineWidth = thickness * (isPoint ? POINT_OUTLINE_THICKNESS_MULTIPLIER : OUTLINE_THICKNESS_MULTIPLIER);
      ctx.stroke();
    }
    
    // Helper function to draw point outline with stroke
    function drawPointOutline() {
      // Skip outlines in editor mode
      if (editorVisible) return;
      
      const bgColorSelectEl = document.getElementById('bgColorSelect');
      const backgroundColor = bgColorSelectEl.value;
      
      // Blend background color with #404040 (50% interpolation)
      const blendedColor = blendColors(backgroundColor, '#404040', 0.5);
      
      ctx.strokeStyle = blendedColor;
      ctx.lineWidth = thickness * POINT_OUTLINE_THICKNESS_MULTIPLIER;
      ctx.stroke();
    }
    
    // Helper function to blend two colors
    function blendColors(color1, color2, ratio) {
      // Convert hex to RGB
      const hex1 = color1.replace('#', '');
      const hex2 = color2.replace('#', '');
      
      const r1 = parseInt(hex1.substr(0, 2), 16);
      const g1 = parseInt(hex1.substr(2, 2), 16);
      const b1 = parseInt(hex1.substr(4, 2), 16);
      
      const r2 = parseInt(hex2.substr(0, 2), 16);
      const g2 = parseInt(hex2.substr(2, 2), 16);
      const b2 = parseInt(hex2.substr(4, 2), 16);
      
      // Interpolate
      const r = Math.round(r1 + (r2 - r1) * ratio);
      const g = Math.round(g1 + (g2 - g1) * ratio);
      const b = Math.round(b1 + (b2 - b1) * ratio);
      
      return `rgb(${r}, ${g}, ${b})`;
    }

    const toCanvas=(p)=>({x:p.xi*s,y:p.yi*s});
    
    // Apply italics skew transformation to a point
    function applyItalicsTransform(point) {
      if (!italicsMode) return point;
      
      // Calculate which text line this point belongs to (each text line is 8 grid units tall)
      const textLineHeight = 8 * s;
      const textLineIndex = Math.floor(point.y / textLineHeight);
      
      // Calculate the skew offset for this text line
      // Each text line gets skewed by its own height within that line
      const skewFactor = -0.15;
      const yWithinTextLine = point.y - (textLineIndex * textLineHeight);
      const skewOffset = s + yWithinTextLine * skewFactor;
      
      return {
        x: point.x + skewOffset,
        y: point.y
      };
    }
    
    function preCalculateHeight() {
      // Count the number of "||" to determine how many text lines we have
      const text = getEditorValue();
      const lineCount = (text.match(/\|\|/g) || []).length;
      
      // Calculate target height: (number of "||" + 1) * 8 * s
      targetCanvasHeight = (lineCount + 1) * 8 * s + 24; // +24px for padding-bottom
      currentCanvasHeight = 200; // Start small for smooth expansion
      animationStartTime = performance.now();
      
      // Set initial wrapper height
      const wrapper = document.getElementById('canvasWrapper');
      wrapper.style.height = currentCanvasHeight + 'px';
    }
    
    function updateCanvasHeight() {
      if (!editorVisible && targetCanvasHeight > 0) {
        // Smooth S-curve animation from current to target height
        const now = performance.now();
        const elapsed = now - animationStartTime;
        const duration = 4000;
        
        if (elapsed < duration) {
          // S-curve easing function (smooth acceleration and deceleration)
          const t = elapsed / duration;
          const sCurve = t * t * (3 - 2 * t); // smoothstep function
          
          const newHeight = currentCanvasHeight + (targetCanvasHeight - currentCanvasHeight) * sCurve;
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.style.height = newHeight + 'px';
          // Canvas stays at full height - wrapper clips it
          
          // Reposition SVG background
        } else {
          // Animation complete
          currentCanvasHeight = targetCanvasHeight;
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.style.height = targetCanvasHeight + 'px';
        }
      }
    }
    
    
    function drawSvgBackground() {
      const svgValue = svgInputEl.value.trim();
      if (!svgValue) return;
      
      // Process SVG content
      let processedSvg = svgValue;
      
      // Remove SVG animations when in edit mode
      if (editorVisible) {
        // Remove all animation elements (both self-closing and with content)
        processedSvg = processedSvg.replace(/<animate[^>]*(?:\/>|>.*?<\/animate>)/g, '');
        processedSvg = processedSvg.replace(/<animateTransform[^>]*(?:\/>|>.*?<\/animateTransform>)/g, '');
        processedSvg = processedSvg.replace(/<animateMotion[^>]*(?:\/>|>.*?<\/animateMotion>)/g, '');
      }
      
      // Remove explicit width and height attributes to allow proper container sizing
      processedSvg = processedSvg.replace(/width="[^"]*"/g, '');
      processedSvg = processedSvg.replace(/height="[^"]*"/g, '');
      
      // Keep original viewBox - CSS object-fit will handle the scaling
      //processedSvg = processedSvg.replace(/viewBox="[^"]*"/g, `viewBox="0 0 1200 1200"`);
      
      if (editorVisible) {
        // Show SVG in preview box when in editor mode
        const svgPreview = document.getElementById('svgPreview');
        const svgPreviewContent = document.getElementById('svgPreviewContent');
        
        if (svgPreview && svgPreviewContent) {
          svgPreview.style.display = 'block';
          svgPreviewContent.innerHTML = `
            <style>
              #svgPreviewContent svg {
                width: 100%;
                max-width: 200px;
                height: auto;
                display: block;
                margin: 0 auto;
              }
            </style>
            ${processedSvg}
          `;
        }
        
        // Hide background SVG when in editor mode
        const svgBackground = document.getElementById('svgBackground');
        if (svgBackground) {
          svgBackground.style.display = 'none';
        }
      } else {
        // Show SVG as background when not in editor mode
        const svgPreview = document.getElementById('svgPreview');
        if (svgPreview) {
          svgPreview.style.display = 'none';
        }
      
      // Create or update background SVG element
      let svgBackground = document.getElementById('svgBackground');
      const canvas = document.getElementById('board');
      
      if (!svgBackground) {
        svgBackground = document.createElement('div');
        svgBackground.id = 'svgBackground';
          svgBackground.style.position = 'absolute';
          svgBackground.style.top = '0';
          svgBackground.style.left = '0';
          svgBackground.style.width = '100%';
          svgBackground.style.height = '100%';
        svgBackground.style.zIndex = '-1';
          svgBackground.style.pointerEvents = 'none';

          // Add it as a child of the wrapper
          const wrapper = document.getElementById('canvasWrapper');
          wrapper.appendChild(svgBackground);
      }
        
        svgBackground.style.display = 'block';
      
      // Position and size exactly like the canvas
      
        // Get current background color for glow
        const bgColorSelectEl = document.getElementById('bgColorSelect');
        const selectedColor = bgColorSelectEl.value;
        
        // Convert hex to RGB for glow
        const hex = selectedColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);
      
      svgBackground.innerHTML = `
        <style>
          #svgBackground svg {
              width: 100%;
              height: 100%;
              display: block;
              object-fit: contain;
              object-position: center;
              transform: scale(0.707);
              filter: drop-shadow(0 0 10px rgba(${r}, ${g}, ${b}, 0.4)) drop-shadow(0 0 20px rgba(${r}, ${g}, ${b}, 0.3)) drop-shadow(0 0 30px rgba(${r}, ${g}, ${b}, 0.2));
          }
        </style>
        ${processedSvg}
      `;
      }
    }
    
    function drawSvgElement(element, scaleX, scaleY, offsetX, offsetY) {
      const tagName = element.tagName.toLowerCase();
      
      if (tagName === 'rect') {
        const x = parseFloat(element.getAttribute('x') || 0) * scaleX + offsetX;
        const y = parseFloat(element.getAttribute('y') || 0) * scaleY + offsetY;
        const w = parseFloat(element.getAttribute('width')) * scaleX;
        const h = parseFloat(element.getAttribute('height')) * scaleY;
        const fill = element.getAttribute('fill') || '#000';
        
        ctx.fillStyle = fill;
        ctx.fillRect(x, y, w, h);
      }
      else if (tagName === 'circle') {
        const cx = parseFloat(element.getAttribute('cx')) * scaleX + offsetX;
        const cy = parseFloat(element.getAttribute('cy')) * scaleY + offsetY;
        const r = parseFloat(element.getAttribute('r')) * Math.min(scaleX, scaleY);
        const fill = element.getAttribute('fill') || '#000';
        const stroke = element.getAttribute('stroke');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        }
      }
      else if (tagName === 'path') {
        const d = element.getAttribute('d');
        const stroke = element.getAttribute('stroke') || '#000';
        const fill = element.getAttribute('fill');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        if (d) {
          // Use proper SVG path parser with offsets
          drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY);
        }
      }
    }
    
    function drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY) {
      // Parse SVG path data
      const commands = parseSvgPath(d);
      
      ctx.beginPath();
      
      let currentX = 0, currentY = 0;
      let startX = 0, startY = 0;
      
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        
        switch (cmd.type) {
          case 'M': // Move to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'm': // Move to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'L': // Line to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'l': // Line to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'C': // Cubic curve (absolute)
            ctx.bezierCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x2 * scaleX + offsetX, cmd.y2 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'c': // Cubic curve (relative)
            ctx.bezierCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x2 * scaleX, currentY + cmd.y2 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Q': // Quadratic curve (absolute)
            ctx.quadraticCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'q': // Quadratic curve (relative)
            ctx.quadraticCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Z': // Close path
          case 'z':
            ctx.closePath();
            currentX = startX;
            currentY = startY;
            break;
        }
      }
      
      // Fill and stroke
      if (fill && fill !== 'none') {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      
      if (stroke && stroke !== 'none') {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
      }
    }
    
    function parseSvgPath(d) {
      // Simple SVG path parser
      const commands = [];
      const tokens = d.match(/[MmLlHhVvCcSsQqTtAaZz]|[+-]?[0-9]*\.?[0-9]+/g) || [];
      
      let i = 0;
      while (i < tokens.length) {
        const token = tokens[i];
        
        if (/[MmLlHhVvCcSsQqTtAaZz]/.test(token)) {
          const command = token;
          i++;
          
          switch (command) {
            case 'M':
            case 'm':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'L':
            case 'l':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'C':
            case 'c':
              if (i + 5 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x2: parseFloat(tokens[i + 2]),
                  y2: parseFloat(tokens[i + 3]),
                  x: parseFloat(tokens[i + 4]),
                  y: parseFloat(tokens[i + 5])
                });
                i += 6;
              }
              break;
              
            case 'Q':
            case 'q':
              if (i + 3 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x: parseFloat(tokens[i + 2]),
                  y: parseFloat(tokens[i + 3])
                });
                i += 4;
              }
              break;
              
            case 'Z':
            case 'z':
              commands.push({ type: command });
              i++;
              break;
              
            default:
              i++; // Skip unknown commands
              break;
          }
        } else {
          i++;
        }
      }
      
      return commands;
    }
    
    function drawGridPoints(spacing=s){
      // Only clear the canvas content if we're drawing grid points (edit mode)
      if (editorVisible) {
        ctx.clearRect(0,0,width,height);
        ctx.save();
        const baseColor = getComputedStyle(document.documentElement).getPropertyValue('--grid-color').trim();
        const r=thickness*3;
        
        for(let y=0;y<=height;y+=spacing){
          // Determine if this row is in an even or odd text row space
          const textRowIndex = Math.floor(y / (8 * s));
          const isEvenTextRow = textRowIndex % 2 === 0;
          
          // Slightly adjust brightness for alternating text rows
          const brightness = isEvenTextRow ? 0.15 : 0.1;
          
          ctx.fillStyle = baseColor;
          ctx.globalAlpha = brightness;
          
          ctx.beginPath();
          for(let x=0;x<=width;x+=spacing){
            const point = applyItalicsTransform({x,y});
            ctx.moveTo(point.x+r,point.y);
            ctx.arc(point.x,point.y,r,0,Math.PI*2);
          }
          ctx.fill();
        }
        ctx.restore();
      }
    }
    function preMoveWrap(xi,yi,dx){const maxX=gridX-pad.right;if(dx>0&&(xi+dx)>maxX){xi=pad.left;yi+=8;}return{xi,yi};}
    function snapToLineTop(yi){return pad.top+8*Math.floor((yi-pad.top)/8);}    
    function normAngle(a){const twoPI=Math.PI*2;while(a<=-Math.PI)a+=twoPI;while(a>Math.PI)a-=twoPI;return a;}
    function anticlockwiseForShortest(a0,a1){const twoPI=Math.PI*2;let cw=(a1-a0)%twoPI;if(cw<0)cw+=twoPI;let ccw=(a0-a1)%twoPI;if(ccw<0)ccw+=twoPI;return ccw<=cw;}
    function angleOnEllipse(cx,cy,rx,ry,x,y){return Math.atan2((y-cy)/ry,(x-cx)/rx);}    

    // Parse while preserving newline at '||'
    function parseBytesWithColors(str){
      const out=[]; let buf='';
      const isHex = c => /[0-9a-fA-F]/.test(c);

      for(let i=0;i<(str?str.length:0);i++){
        const ch = str[i];
        
        // Handle comments: skip everything after "//" until end of line
        if(ch === '/' && str[i + 1] === '/'){
          // Skip to end of line (newline or end of string)
          while(i < str.length && str[i] !== '\n'){
            i++;
          }
          // Don't skip the newline character itself, let it be processed normally
          if(i < str.length && str[i] === '\n'){
            i--; // Back up one so the newline gets processed in the next iteration
          }
          continue;
        }
        
        if(ch==='|'){
          const next = str[i+1];
          if(next==='|'){
            out.push({newline:true});
            i++;
          }else{
            // emit the literal pipe as a non-byte token so caret offsets match textContent
            out.push({pipe:true});
          }
          continue;
        }
        if(isHex(ch)){
          buf += ch;
          if(buf.length===2){
            out.push({byte:parseInt(buf,16), text:buf});
            buf='';
          }
          continue;
        } else {
          // reset partial hex if we hit a non-hex separator mid-token
          if (buf) out.push({text:buf});
          out.push({text:ch});
          buf = '';
        }
      }
      if (buf) out.push({text:buf});
      return out;
    }

    function triBitsToSigned(v3){return(v3<=4)?v3:(4-v3);}    

    // --- Animation state ---
    let currentAnim = null; // { timer, ops, idx, visited }
    const STEP_DELAY_MS = 20; // delay between each drawing command
    const DRAW_MS = STEP_DELAY_MS;       // how long each piece takes to draw
    
    function stopAnim(){
      if (currentAnim && currentAnim.rafId) cancelAnimationFrame(currentAnim.rafId);
      currentAnim = null;
    }
    
    function startAnim(ops, visited){
      stopAnim();
      const animStart = performance.now();

      // When each op *starts* becoming visible
      const theFirstVisibleAt = ops.map((_, i) => animStart + i * STEP_DELAY_MS);

      currentAnim = {
        ops, visited,
        animStart, firstVisibleAt: theFirstVisibleAt,
        rafId: null
      };

      const tick = (now) => {
        if (!currentAnim) return;

        // How many ops have "started" by now?
        let started = 0;
        while (started < ops.length && now >= currentAnim.firstVisibleAt[started]) started++;

        // Draw frame with progressive drawing
        drawFrameProgressive(now, started, ops, currentAnim.firstVisibleAt, visited);

        // Done when the last op has fully drawn
        const allDone = ops.length === 0 || (now >= currentAnim.firstVisibleAt[ops.length - 1] + DRAW_MS);
        if (!allDone) {
          currentAnim.rafId = requestAnimationFrame(tick);
        } else {
          // Save firstVisibleAt before stopping animation
          const firstVisibleAt = currentAnim.firstVisibleAt;
          stopAnim();
          drawFrameProgressive(now, ops.length, ops, firstVisibleAt, visited, /*isAnimating=*/false);
        }
      };

      currentAnim.rafId = requestAnimationFrame(tick);
    }

    function drawFrameProgressive(now, startedCount, ops, firstVisibleAt, visited, isAnimating = true){
      // Reset max Y tracking
      maxDrawnY = 0;
      
      // Only draw grid points in edit mode
      if (editorVisible) {
      drawGridPoints(s);
      }
      // Don't set lineWidth here - let each drawOp set its own thickness

      // First pass: draw all outlines
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0→1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpOutline(op, progress);
      }
      
      // Second pass: draw all main strokes on top
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0→1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpMain(op, progress);
      }

      // Show ONLY the red end marker when NOT animating AND in edit mode
      if (!isAnimating && editorVisible && visited && visited.length) {
        const endPix = applyItalicsTransform(toCanvas(visited[visited.length - 1]));
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(endPix.x, endPix.y, thickness * END_MARKER_RADIUS_MULTIPLIER, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Update canvas height progressively during animation (only in presentation mode)
      if (!editorVisible) {
        updateCanvasHeight();
      }
    }

    function drawOpOutline(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        // Track maximum Y coordinate
        maxDrawnY = Math.max(maxDrawnY, p1.y, p2.y);
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          maxDrawnY = Math.max(maxDrawnY, intermediate.y);
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw outline only - always black outline
        drawOutline();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Track maximum Y coordinate for arc
        maxDrawnY = Math.max(maxDrawnY, transformedCenter.y + op.ry);
        
        // Check if this is a complete circle (start=0, end=2π)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw outline only - always black outline
        drawOutline();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Track maximum Y coordinate
          maxDrawnY = Math.max(maxDrawnY, transformedStart.y, transformedEnd.y);
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw outline only
          drawOutline();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        // Track maximum Y coordinate for point
        maxDrawnY = Math.max(maxDrawnY, c.y + thickness * POINT_RADIUS_MULTIPLIER);
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw outline only - always black outline (thinner for points)
        drawPointOutline();
      }
    }

    function drawOpMain(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Check if this is a complete circle (start=0, end=2π)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw main stroke
          ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
          ctx.stroke();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw main fill
        ctx.fillStyle = op.color;
        ctx.fill();
      }
    }

    function drawOp(op, progress = 1){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        // Track maximum Y coordinate
        maxDrawnY = Math.max(maxDrawnY, p1.y, p2.y);
        
        if (progress >= 1) {
          // Draw complete line
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          // Draw partial line
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          maxDrawnY = Math.max(maxDrawnY, intermediate.y);
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        // Draw outline for better visibility
        drawOutline();
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        // Track maximum Y coordinate for arc
        maxDrawnY = Math.max(maxDrawnY, transformedCenter.y + op.ry);
        
        // Check if this is a complete circle (start=0, end=2π)
        if(op.start === 0 && op.end === Math.PI * 2){
          if (progress >= 1) {
            // For complete circles, just transform the center and draw
        ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,Math.PI*2,false);
          } else {
            // Draw partial circle
            const endAngle = Math.PI * 2 * progress;
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
          }
        
        // Draw outline for better visibility
        drawOutline();
        
        // Draw main stroke
        ctx.strokeStyle = op.color;
        ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        } else {
          // For partial arcs, calculate transformed angles
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          // Transform the start and end points
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          // Track maximum Y coordinate
          maxDrawnY = Math.max(maxDrawnY, transformedStart.y, transformedEnd.y);
          
          // Calculate new angles based on transformed points
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            // Draw complete arc
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            // Draw partial arc - handle angle wrapping correctly
            let angleDiff;
            if (op.acw) {
              // Anticlockwise: go from start to end in negative direction
              angleDiff = newStartAngle - newEndAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            } else {
              // Clockwise: go from start to end in positive direction  
              angleDiff = newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            }
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? 
              newStartAngle - progressAngle : 
              newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
          
          // Draw outline for better visibility
          drawOutline();
        
          // Draw main stroke
        ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * MAIN_THICKNESS_MULTIPLIER;
        ctx.stroke();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        // Track maximum Y coordinate for point
        maxDrawnY = Math.max(maxDrawnY, c.y + thickness * POINT_RADIUS_MULTIPLIER);
        
        if (progress >= 1) {
          // Draw complete point
        ctx.beginPath();ctx.arc(c.x,c.y,thickness*POINT_RADIUS_MULTIPLIER,0,Math.PI*2);
        } else {
          // Draw growing point
          const radius = thickness * POINT_RADIUS_MULTIPLIER * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        }
        
        // Draw outline for better visibility
        ctx.fillStyle = '#000000';
        ctx.fill();
        
        // Draw main fill
        ctx.fillStyle = op.color;
        ctx.fill();
      }
    }

    // Build ops (line/arc/point) in encounter order
    function buildOps(coloredItems){
      let xi=start.xi,yi=start.yi;
      const ops=[]; const visited=[{xi,yi}];
      let currentLetterIndex = getCurrentLetterIndex();
      let letterIndex = 0;

      for(const item of coloredItems){
        if(item.newline){
          // Move to the next text row boundary, regardless of current position
          yi = pad.top + 8 * (Math.floor((yi - pad.top) / 8) + 1);
          xi = pad.left; 
          visited.push({xi,yi});
          // Newline counts as a new letter
          letterIndex++;
          continue;
        }
        if (item.pipe) {
          // literal single '|', increment letter index
          letterIndex++;
          continue;
        }
        if (item.text && item.byte === undefined) {
          // free text / separators — ignore for drawing
          continue;
        }

        const b = item.byte;
        const bgColorSelectEl = document.getElementById('bgColorSelect');
        const backgroundColor = bgColorSelectEl.value;
        // Highlight current letter with red color, others with white
        const isCurrentLetter = letterIndex === currentLetterIndex;
        const stroke = isCurrentLetter ? '#ff0000' : '#ffffff';

        const a=(b>>7)&1;
        const xxx=(b>>4)&0b111;
        const bitB=(b>>3)&1;
        const yyy=b&0b111;
        const isZero=(xxx===0&&yyy===0);
        const ab=(a<<1)|bitB;

        if(isZero){
          if(ab===0b00){ ops.push({type:'point', xi, yi, color:stroke}); }
          else if(ab===0b01){ ops.push({type:'arc', cx:toCanvas({xi,yi}).x, cy:toCanvas({xi,yi}).y, rx:s, ry:s, start:0, end:Math.PI*2, acw:false, color:stroke}); }
          else if(ab===0b10){ ops.push({type:'arc', cx:toCanvas({xi,yi}).x, cy:toCanvas({xi,yi}).y, rx:s*0.5, ry:s*0.5, start:0, end:Math.PI*2, acw:false, color:stroke}); }
          else { yi=snapToLineTop(yi); }
          visited.push({xi,yi});
          continue;
        }

        const dx=triBitsToSigned(xxx),dy=triBitsToSigned(yyy);
        ({xi,yi}=preMoveWrap(xi,yi,Math.max(0,dx)));
        const from={xi,yi};
        const to={xi:xi+dx,yi:yi+dy};

        if(ab===0b11){
          // Invisible move
          xi=to.xi; yi=to.yi; visited.push({xi,yi});
          continue;
        }

        if(ab===0b00){
          ops.push({type:'line', from, to, color:stroke});
        }else{
          const p0=toCanvas(from),p1=toCanvas(to);
          let cx,cy,rx,ry,a0,a1; let semi=false;
          if(dx!==0&&dy!==0){
            rx=Math.abs(dx)*s; ry=Math.abs(dy)*s;
            if(ab===0b01){ cx=p0.x; cy=p0.y+dy*s; }
            else{          cx=p0.x+dx*s; cy=p0.y; }
            a0=angleOnEllipse(cx,cy,rx,ry,p0.x,p0.y);
            a1=angleOnEllipse(cx,cy,rx,ry,p1.x,p1.y);
          }else if(dx!==0&&dy===0){
            const r=Math.abs(dx)*s/2; rx=r; ry=r;
            cx=(p0.x+p1.x)/2; cy=p0.y;
            const movingRight = dx>0;
            a0 = movingRight ? Math.PI : 0;
            a1 = movingRight ? 0 : Math.PI;
            semi = true;
          }else if(dx===0&&dy!==0){
            const r=Math.abs(dy)*s/2; rx=r; ry=r;
            cx=p0.x; cy=(p0.y+p1.y)/2;
            const movingDown = dy>0;
            a0 = movingDown ? -Math.PI/2 : Math.PI/2;
            a1 = movingDown ?  Math.PI/2 : -Math.PI/2;
            semi = true;
          }
          if(rx&&ry){
            a0=normAngle(a0); a1=normAngle(a1);
            const acw = semi ? ((ab===0b01)?false:true) : anticlockwiseForShortest(a0,a1);
            ops.push({type:'arc', cx,cy,rx,ry,start:a0,end:a1,acw,color:stroke});
          }
        }

        xi=to.xi; yi=to.yi; visited.push({xi,yi});
      }
      return { ops, visited };
    }

    function renderInstant(ops, visited, skipHeightUpdate = false){
      // Reset max Y tracking
      maxDrawnY = 0;
      
      // Only draw grid points in edit mode
      if (editorVisible) {
      drawGridPoints(s);
      }
      // Don't set lineWidth here - let each drawOp set its own thickness
      
      // First pass: draw all outlines
      for(const op of ops){ drawOpOutline(op); }
      
      // Second pass: draw all main strokes on top
      for(const op of ops){ drawOpMain(op); }
      if(visited && visited.length){
        // Show only the ending marker (red) when in edit mode
        if (editorVisible) {
          const endPix=applyItalicsTransform(toCanvas(visited[visited.length-1]));
          ctx.fillStyle='red';ctx.beginPath();ctx.arc(endPix.x,endPix.y,thickness*3,0,Math.PI*2);ctx.fill();
        }
      }
      
      // Update canvas height based on drawn content (only in presentation mode and when not skipping)
      if (!editorVisible && !skipHeightUpdate) {
        updateCanvasHeight();
      }
    }

    // --- Contenteditable highlighting helpers ---
    const inputEl=document.getElementById('strInput');
    const ruleEl=document.getElementById('strRule');
    const outputEl=document.getElementById('strOutput');
    const sInputEl = document.getElementById('sInput');
    const sValueEl = document.getElementById('sValue');

    const escapeHTML = s => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    function getPlainText(el){ return el.textContent.replace(/\r/g,''); }

    function getCaretOffset(root){
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return 0;
      const range = sel.getRangeAt(0);
      const pre = document.createRange();
      pre.selectNodeContents(root);
      pre.setEnd(range.endContainer, range.endOffset);
      return pre.toString().length;
    }

    function setCaretOffset(root, target){
      target = Math.max(0, target);
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (target <= next) {
          const sel = getSelection();
          const range = document.createRange();
          range.setStart(node, target - count);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      const sel = getSelection();
      const r = document.createRange();
      r.selectNodeContents(root);
      r.collapse(false);
      sel.removeAllRanges(); sel.addRange(r);
    }


    // Basic "hex-hit" highlighter with current letter highlighting
    const HEX_CHAR_RE = /[0-9A-Fa-f]/;
    function basicHighlightHTML(raw){
      const currentLetterIndex = getCurrentLetterIndex();
      const esc = escapeHTML(raw);
      
      let letterIndex = 0;
      let html = '';
      let i = 0;
      
      while(i < esc.length){
        const ch = esc[i];
        
        if(ch === '|'){
          const next = esc[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter
            letterIndex++;
            html += '||';
            i += 2;
          } else {
            // Letter separator
            letterIndex++;
            html += '|';
            i++;
          }
        } else if(HEX_CHAR_RE.test(ch) && HEX_CHAR_RE.test(esc[i+1])){
          // Found a hex pair
          const pair = esc.substr(i, 2);
          const isCurrentLetter = letterIndex === currentLetterIndex;
          
          // Check if this is an invisible move
          const byte = parseInt(pair, 16);
          const a = (byte >> 7) & 1;
          const xxx = (byte >> 4) & 0b111;
          const bitB = (byte >> 3) & 1;
          const yyy = byte & 0b111;
          const isZero = (xxx === 0 && yyy === 0);
          const ab = (a << 1) | bitB;
          
          // Invisible moves: ab===0b11 (both a and bitB are 1)
          const isInvisibleMove = ab === 0b11;
          
          if(isCurrentLetter){
            html += `<strong>${pair}</strong>`;
          } else if(isInvisibleMove){
            html += `<span class="hex-hit">${pair}</span>`;
          } else {
            html += pair;
          }
          i += 2;
        } else {
          html += ch;
          i++;
        }
      }
      
      return html;
    }

    // Use basic highlighting
    function highlightEditor(){
      const raw = getPlainText(inputEl);
      const caret = getCaretOffset(inputEl);
      const html = basicHighlightHTML(raw);
      inputEl.innerHTML = html;
      setCaretOffset(inputEl, caret);
    }

    // Plain-text value getter used by renderer
    function getEditorValue(){ return getPlainText(inputEl); }

    // Get the current letter index (which space between | characters the cursor is in)
    function getCurrentLetterIndex(){
      const raw = getPlainText(inputEl);
      const caret = getCaretOffset(inputEl);
      
      let letterIndex = 0;
      let currentPos = 0;
      
      for(let i = 0; i < raw.length && currentPos < caret; i++){
        const ch = raw[i];
        
        if(ch === '|'){
          const next = raw[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter
            letterIndex++;
            i++;
            currentPos += 2;
          } else {
            // This is a letter separator
            letterIndex++;
            currentPos++;
          }
        } else {
          currentPos++;
        }
      }
      
      return letterIndex;
    }

    // Insert plain text at the current caret (collapses selection)
    function insertTextAtCaret(root, text) {
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return;

      const range = sel.getRangeAt(0);
      range.deleteContents();

      const tn = document.createTextNode(text);
      range.insertNode(tn);

      // move caret after the inserted text node
      range.setStartAfter(tn);
      range.setEndAfter(tn);
      sel.removeAllRanges();
      sel.addRange(range);

      // trigger highlight & render
      highlightEditor();
      renderNow();
    }

    // --- Lightweight undo/redo history ---
    const HISTORY_LIMIT = 100;
    const history = [];
    const redo = [];
    let snapshotTimer = null;

    function getState() {
      return { text: getEditorValue(), caret: getCaretOffset(inputEl) };
    }

    function applyState(st) {
      inputEl.textContent = st.text;  // plain text
      highlightEditor();
      setCaretOffset(inputEl, st.caret);
      renderNow();
    }

    function pushHistory() {
      const st = getState();
      const prev = history[history.length - 1];
      if (!prev || prev.text !== st.text || prev.caret !== st.caret) {
        history.push(st);
        if (history.length > HISTORY_LIMIT) history.shift();
        redo.length = 0; // clear redo on new branch
      }
    }

    function scheduleSnapshot() {
      clearTimeout(snapshotTimer);
      snapshotTimer = setTimeout(pushHistory, 250); // coalesce rapid edits
    }

    function undo() {
      if (history.length <= 1) return;
      const cur = history.pop();
      redo.push(cur);
      applyState(history[history.length - 1]);
    }

    function redoAction() {
      if (!redo.length) return;
      const st = redo.pop();
      history.push(st);
      applyState(st);
    }

    // --- Enter & clipboard behaviors ---
    // Intercept default paragraph for plain newline
    inputEl.addEventListener('beforeinput', (e) => {
      if (e.inputType === 'insertParagraph') {
        e.preventDefault();
        insertTextAtCaret(inputEl, '\n');
        scheduleSnapshot();
      }
    });

    // Keydown fallback for Enter
    inputEl.addEventListener('keydown', (e) => {
      const mod = e.metaKey || e.ctrlKey;

      // Redo (Cmd+Shift+Z or Ctrl+Y)
      if (mod && ((e.key.toLowerCase() === 'z' && e.shiftKey) || e.key.toLowerCase() === 'y')) {
        e.preventDefault();
        redoAction();
        return;
      }

      // Undo (Cmd/Ctrl+Z without Shift)
      if (mod && e.key.toLowerCase() === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
        return;
      }

      // Plain Enter inserts '\n'
      if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
        e.preventDefault();
        insertTextAtCaret(inputEl, '\n');
        scheduleSnapshot();
      }
    });

    // Sanitize paste to plain text
    inputEl.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');
      document.execCommand('insertText', false, text);
      highlightEditor();
      renderNow();
      scheduleSnapshot();
    });

    // --- Wiring (render + highlight) ---
    function renderNow(){
      try{
        const coloredItems = parseBytesWithColors(getEditorValue());
        const { ops, visited } = buildOps(coloredItems);
        stopAnim();
        
        // Always use static rendering in renderNow (animation is handled elsewhere)
        renderInstant(ops, visited);
        
        // Delay canvas expansion for 3D flip animation (only on first load)
        if (!editorVisible && currentCanvasHeight === 200) {
          setTimeout(() => {
            animationStartTime = performance.now();
          }, 1500); // Wait for flip animation to complete
        }
      }catch(e){
        console.error('Render error:',e);
        stopAnim();
      }
    }

    // Live update on every edit (typing, delete, IME commits, etc.)
    inputEl.addEventListener('input', () => {
      highlightEditor();   // rebuild colored spans
      renderNow();         // rebuild ops + redraw canvas
      scheduleSnapshot();  // coalesce undo snapshots
    });

    // Update highlighting when cursor position changes (click, arrow keys, etc.)
    document.addEventListener('selectionchange', () => {
      if (document.activeElement === inputEl) {
        highlightEditor();
        renderNow();
      }
    });

    
    // Background color functionality
    const bgColorSelectEl = document.getElementById('bgColorSelect');
    
    // Populate color options dynamically
    function populateColorOptions() {
      const colors = getColors();
      const initialColor = colors[DEFAULT_PANEL_COLOR_INDEX]; // Default to yellowish color
      
      // Clear existing options
      bgColorSelectEl.innerHTML = '';
      
      // Add color options with hex values
      colors.forEach((color, index) => {
        const option = document.createElement('option');
        option.value = color;
        option.textContent = color; // Show the hex value
        if (color === initialColor) {
          option.selected = true;
        }
        bgColorSelectEl.appendChild(option);
      });
    }
    
    // Generate gradient from base color
    function generateGradientFromColor(baseColor) {
      // Convert hex to RGB
      const hex = baseColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // Create gradient with varying opacity
      return `linear-gradient(135deg, 
        rgba(${r},${g},${b},0.8) 0%, 
        rgba(${r},${g},${b},0.6) 25%, 
        rgba(${r},${g},${b},0.4) 50%, 
        rgba(${r},${g},${b},0.2) 75%, 
        rgba(${r},${g},${b},0.1) 100%)`;
    }
    
    // Update canvas background based on editor mode and selected color
    function updateCanvasBackground(selectedColor) {
      const canvasElement = document.getElementById('board');
      if (!editorVisible) {
        canvasElement.style.background = generateGradientFromColor(selectedColor);
      } else {
        canvasElement.style.background = '';
      }
    }
    
    // Initialize color options and set defaults
    populateColorOptions();
    
    const initialColor = getColors()[DEFAULT_PANEL_COLOR_INDEX];
    const colorIndicator = document.getElementById('bgColorIndicator');
    
    // Set initial values
    colorIndicator.style.backgroundColor = initialColor;
    updateCanvasBackground(initialColor);
    
    bgColorSelectEl.addEventListener('change', () => {
      const selectedColor = bgColorSelectEl.value;
      const colorIndicator = document.getElementById('bgColorIndicator');
      
      // Update canvas background
      updateCanvasBackground(selectedColor);
      
      // Update color indicator
      colorIndicator.style.backgroundColor = selectedColor;
      
      // Update SVG glow to match
      drawSvgBackground();
    });
    
    sInputEl.addEventListener('input', () => {
      s = parseInt(sInputEl.value, 10);
      thickness = s/10;
      sValueEl.textContent = s;
      renderNow();
    });

    // SVG input functionality
    const svgInputEl = document.getElementById('svgInput');
    svgInputEl.addEventListener('input', () => {
      // Always update SVG display (preview in editor mode, background in non-editor mode)
        drawSvgBackground();
    });
    

    // Hotkey listener for editor toggle (Ctrl+E or Cmd+E)
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'e' && (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey) {
        // Only toggle if not typing in the editor
        if (document.activeElement !== inputEl && document.activeElement !== ruleEl && document.activeElement !== outputEl) {
          e.preventDefault();
          editorVisible = !editorVisible;
          
          // Toggle canvas-only mode for proper centering
          document.body.classList.toggle('canvas-only', !editorVisible);
          
          // Update canvas background based on new mode
          const bgColorSelectEl = document.getElementById('bgColorSelect');
          const selectedColor = bgColorSelectEl.value;
          
          updateCanvasBackground(selectedColor);
            drawSvgBackground();
          
          // Clear canvas when switching modes to remove any lingering grid points
          ctx.clearRect(0, 0, width, height);
          
          // Reset wrapper height when switching modes  
          const wrapper = document.getElementById('canvasWrapper');
          if (editorVisible) {
            wrapper.style.height = cssH + 'px'; // Full height in edit mode
          }
          
          // Always animate in non-edit mode, static in edit mode
          if (!editorVisible) {
            preCalculateHeight(); // Pre-calculate height for smooth animation
            const coloredItems = parseBytesWithColors(getEditorValue());
            const { ops, visited } = buildOps(coloredItems);
            startAnim(ops, visited);
          } else {
            renderNow(); // redraw canvas (grid visibility will be handled in drawGridPoints)
          }
        }
      }
    });

    // Window resize listener to reposition SVG background
    window.addEventListener('resize', () => {
      if (!editorVisible) {
      }
    });

    // Initial
    window.addEventListener('load', () => {
      // Start in non-edit mode (canvas-only)
      document.body.classList.add('canvas-only');
      // Load default content
      inputEl.textContent = defaultContent;
      // Initialize SVG background
      svgInputEl.value = defaultSvgBackground;
      highlightEditor();
      // Update color options for background
      populateColorOptions();
      // Pre-calculate height for smooth animation
      preCalculateHeight();
      // Start with animated rendering instead of static
      const coloredItems = parseBytesWithColors(getEditorValue());
      const { ops, visited } = buildOps(coloredItems);
      startAnim(ops, visited);
      pushHistory(); // seed history
      
      // Initialize background for non-edit mode
      drawSvgBackground();
      
      // Add event listeners after DOM is ready
      const italicsCheckboxEl = document.getElementById('italicsCheckbox');
      
      if (italicsCheckboxEl) {
        italicsCheckboxEl.addEventListener('change', ()=>{
          italicsMode = italicsCheckboxEl.checked;
          renderNow();       // redraw canvas with new italics mode
        });
      }
    });
  </script>
</body>
</html>
