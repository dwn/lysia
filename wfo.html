<!doctype html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <title>Wfo Writer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%23000'/><circle cx='50' cy='50' r='25' fill='%23fff'/></svg>">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" id="pico-css">
  <style>
    /* ===== THEME & LAYOUT ===== */
    :root, :root:not([data-theme="light"]) {
      --border-color: #666;
      --pico-background-color: #1a1a1a;
      --pico-color: #ffffff;
      --pico-muted-border-color: #666666;
      --pico-muted-color: #aaaaaa;
      --pico-primary-background: #333333;
      --pico-primary-color: #ffffff;
      --pico-secondary-background: #2a2a2a;
      --pico-secondary-color: #ffffff;
      --pico-form-element-background-color: #333333;
      --pico-form-element-border-color: #666666;
      --pico-form-element-color: #ffffff;
      --pico-form-element-placeholder-color: #aaaaaa;
      --pico-form-element-selected-background-color: #444444;
      --pico-form-element-selected-border-color: #777777;
      --pico-form-element-selected-color: #ffffff;
    }
    
    body {
      opacity: 0;
      transition: opacity 0.15s ease-in;
      position: relative;
      overflow-x: hidden;
    }
    
    /* Page fade effect during mode transitions */
    body.page-transitioning {
      transition: opacity 0.4s ease-in-out;
    }
    
    body.page-ready {
      opacity: 1;
    }
    
    #bgColorSelect, #bgColorSelect option {
      color: inherit !important;
    }
    
    /* ===== EDITOR MODE ===== */
    body:not(.canvas-only) {
      zoom: 0.75;
      transform-origin: top left;
    }
    
    /* ===== ANIMATIONS ===== */
    /* Global glow for single-card mode only (not grid mode) */
    .canvas-only .grid > div:first-child:not(.grid-container)::before {
      content: '';
      position: absolute;
      top: -120px;
      left: -60px;
      right: -60px;
      bottom: -120px;
      background: radial-gradient(ellipse, var(--card-glow-1, rgba(255, 255, 255, 0.6)) 0%, var(--card-glow-2, rgba(255, 255, 255, 0.4)) 20%, var(--card-glow-3, rgba(255, 255, 255, 0.2)) 40%, transparent 70%);
      border-radius: 50px;
      z-index: -1;
      opacity: 0.7;
      animation: glowPulse 3s ease-in-out infinite;
      filter: blur(5px);
    }
    
    /* No large glow in zoomed-out grid mode - individual card glows only */
    .canvas-only .grid > div:first-child.grid-container::before,
    .canvas-only .grid > div:first-child:has(.grid-container)::before {
      display: none;
    }
    
    /* Selected card outline in zoomed-out mode */
    .canvas-only .grid-container .card-wrapper.selected {
      border: none !important;
      box-shadow: 0 0 0 12px #cccccc !important;
      border-radius: 20px !important;
    }
    
    /* Ensure consistent border styling for all cards in zoomed-out mode */
    .canvas-only .grid-container .card-wrapper,
    .canvas-only .grid-container .card-wrapper:hover {
      border: 2px solid #666 !important;
    }
    
    /* Drag and drop styling */
    .canvas-only .grid-container .card-wrapper[draggable="true"] {
      cursor: grab;
      user-select: none;
      transition: all 0.2s ease;
    }
    
    .canvas-only .grid-container .card-wrapper[draggable="true"]:active {
      cursor: grabbing;
    }
    
    .canvas-only .grid-container .card-wrapper.drag-over {
      border-color: #4CAF50 !important;
      transform: scale(1.05) !important;
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.3) !important;
    }
    
    .canvas-only .grid-container .card-wrapper.dragging {
      opacity: 0.5 !important;
      transform: rotate(5deg) scale(1.1) !important;
      z-index: 1000 !important;
    }
    
    @keyframes cardFlipIn {
      0% {
        transform: translateX(100vw) rotateY(90deg);
        opacity: 0;
      }
      25% {
        transform: translateX(75vw) rotateY(67.5deg);
        opacity: 0.25;
      }
      50% {
        transform: translateX(50vw) rotateY(45deg);
        opacity: 0.5;
      }
      75% {
        transform: translateX(25vw) rotateY(22.5deg);
        opacity: 0.75;
      }
      100% {
        transform: translateX(0) rotateY(0deg);
        opacity: 1;
      }
    }
    
    @keyframes cardFlipOut {
      0% {
        transform: translateX(0) rotateY(0deg);
        opacity: 1;
      }
      25% {
        transform: translateX(-25vw) rotateY(-22.5deg);
        opacity: 0.75;
      }
      50% {
        transform: translateX(-50vw) rotateY(-45deg);
        opacity: 0.5;
      }
      75% {
        transform: translateX(-75vw) rotateY(-67.5deg);
        opacity: 0.25;
      }
      100% {
        transform: translateX(-100vw) rotateY(-90deg);
        opacity: 0;
      }
    }
    
    @keyframes cardFlipOutRight {
      0% {
        transform: translateX(0) rotateY(0deg);
        opacity: 1;
      }
      25% {
        transform: translateX(25vw) rotateY(22.5deg);
        opacity: 0.75;
      }
      50% {
        transform: translateX(50vw) rotateY(45deg);
        opacity: 0.5;
      }
      75% {
        transform: translateX(75vw) rotateY(67.5deg);
        opacity: 0.25;
      }
      100% {
        transform: translateX(100vw) rotateY(90deg);
        opacity: 0;
      }
    }
    
    @keyframes cardFlipInRight {
      0% {
        transform: translateX(-100vw) rotateY(-90deg);
        opacity: 0;
      }
      25% {
        transform: translateX(-75vw) rotateY(-67.5deg);
        opacity: 0.25;
      }
      50% {
        transform: translateX(-50vw) rotateY(-45deg);
        opacity: 0.5;
      }
      75% {
        transform: translateX(-25vw) rotateY(-22.5deg);
        opacity: 0.75;
      }
      100% {
        transform: translateX(0) rotateY(0deg);
        opacity: 1;
      }
    }
    
    @keyframes cardFlipToEditor {
      0% {
        transform: rotateY(0deg);
        opacity: 1;
      }
      50% {
        transform: rotateY(-90deg);
        opacity: 0;
      }
      100% {
        transform: rotateY(-90deg);
        opacity: 0;
      }
    }
    
    
    @keyframes cardFadeIn {
      0% {
        opacity: 0;
        transform: scale(0.85);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    @keyframes cardFlipFromEditor {
      0% {
        transform: rotateY(-90deg);
        opacity: 0;
      }
      25% {
        transform: rotateY(-67.5deg);
        opacity: 0.25;
      }
      50% {
        transform: rotateY(-45deg);
        opacity: 0.5;
      }
      75% {
        transform: rotateY(-22.5deg);
        opacity: 0.75;
      }
      100% {
        transform: rotateY(0deg);
        opacity: 1;
      }
    }
    
    @keyframes cardFlipOutOnly {
      0% {
        transform: rotateY(0deg);
        opacity: 1;
      }
      25% {
        transform: rotateY(-22.5deg);
        opacity: 0.75;
      }
      50% {
        transform: rotateY(-45deg);
        opacity: 0.5;
      }
      75% {
        transform: rotateY(-67.5deg);
        opacity: 0.25;
      }
      100% {
        transform: rotateY(-90deg);
        opacity: 0;
      }
    }
    
    /* ===== CANVAS STYLES ===== */
    canvas { 
      width: 600px; 
      height: 971px; 
      min-width: 600px;
      display: block;
      position: relative;
      z-index: 1;
      transform: translateZ(0);
      will-change: transform;
    }
    
    /* ===== EDITOR STYLES ===== */
    .mono-grid, .ce-editor { 
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; 
    }
    
    .mono-grid { 
      white-space: pre; 
    }

    .ce-editor {
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap; 
      word-break: break-word; 
      tab-size: 2;
      min-height: 20em;
      padding: 6px 8px;
      border: 1px solid var(--border-color); 
      border-radius: 6px;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: auto;
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    #strOutput {
      background: #6c757d;
      border: 1px solid #495057;
      color: #ffffff;
      cursor: default;
    }
    
    #strOutput:hover {
      background: #5a6268;
    }
    
    .hex-hit {
      outline: 1px solid rgba(0, 230, 255, 0.6);
      border-radius: 3px;
    }
    
    /* ===== RESPONSIVE LAYOUT ===== */
    .grid {
      height: auto !important;
      min-height: auto !important;
    }
    
    @media (max-width: 768px) {
      .grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
    }
    
    @media (max-width: 1000px) and (min-width: 769px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 1rem;
      }
      aside {
        min-width: 300px;
      }
    }
    
    @media (min-width: 1001px) {
      .grid {
        grid-template-columns: auto 1fr;
        gap: 2rem;
      }
    }
    
    /* ===== PRESENTATION MODE ===== */
    .canvas-only {
      perspective: 1000px;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      padding-top: 60px; /* Move card down for balanced button spacing */
    }
    
    body.canvas-only {
      color: #ffffff;
      font-family: system-ui, -apple-system, sans-serif;
      zoom: 0.75;
      transform-origin: top left;
    }
    
    body.canvas-only main,
    body.canvas-only .grid {
      color: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    
    .canvas-only .grid > div:first-child {
      transform-style: preserve-3d;
      animation: none;
      position: relative;
      object-fit: contain;
      transform-origin: center center;
      perspective: 1500px;
    }
    
    .canvas-only aside {
      display: none !important;
    }
    
    /* Hide zoom button in editor mode */
    body:not(.canvas-only) #zoomOutButton {
      display: none !important;
    }
    
    /* Hide add card button in editor mode */
    body:not(.canvas-only) #addCardButton {
      display: none !important;
    }
    
    /* Monitor/glossy effect for presentation mode */
    .canvas-only canvas {
      background: transparent;
      box-shadow: 
        inset 0 2px 4px rgba(255,255,255,0.3),
        inset 0 -2px 4px rgba(0,0,0,0.1),
        0 8px 32px rgba(0,0,0,0.3),
        0 0 0 1px rgba(255,255,255,0.1);
      /* filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); */
      border-radius: 16px;
      padding: 1.5rem;
      position: relative;
    }
    
    /* Fixed 50/50 layout for editor mode only */
    body:not(.canvas-only) .container-fluid {
      max-width: none !important;
    }
    
    body:not(.canvas-only) .container-fluid .grid {
      display: grid !important;
      grid-template-columns: 1fr 1fr !important;
      gap: 2rem !important;
      min-height: 100vh;
      align-items: start;
    }
    
    body:not(.canvas-only) .container-fluid .grid > div:first-child,
    body:not(.canvas-only) .container-fluid .grid > aside {
      width: 100% !important;
      max-width: none !important;
      flex: none !important;
    }
    
    body:not(.canvas-only) .container-fluid .grid > aside {
      overflow-y: auto;
      height: 100%;
      position: relative;
      z-index: 1;
      background: var(--pico-background-color);
      margin-left: 15px;
    }
    
    /* Ensure textareas don't resize the layout in editor mode */
    body:not(.canvas-only) .container-fluid textarea {
      resize: vertical !important;
      min-height: 100px !important;
      max-height: 200px !important;
    }
    
    /* Canvas wrapper positioning in editor mode */
    body:not(.canvas-only) #canvasWrapper {
      width: 100% !important;
      max-width: 100% !important;
      display: flex;
      justify-content: flex-start;
      align-items: flex-start;
      overflow: visible !important;
      padding-bottom: 0 !important;
      margin-top: 65px;
      left: -15px;
      z-index: -1;
    }
    
    body:not(.canvas-only) #canvasWrapper canvas {
      width: 100% !important;
      max-width: 100% !important;
      height: auto !important;
      flex-shrink: 0;
    }
    
    /* Add a subtle screen reflection effect */
    .canvas-only canvas::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to bottom, 
        rgba(255,255,255,0.1) 0%, 
        rgba(255,255,255,0.05) 50%, 
        transparent 100%);
      border-radius: 16px 16px 0 0;
      pointer-events: none;
    }
    
    /* Soft roaming light effect on page background - only in presentation mode */
    body {
      position: relative;
      overflow-x: hidden;
    }
    
    body.canvas-only::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: -1;
    }
    
    /* ===== EDITOR TOGGLE BUTTON ===== */
    .editor-toggle {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10%;
      padding: 8px 12px;
      font-size: 16px;
      height: 38px;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(10px);
    }
    
    .editor-toggle:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
      transform: scale(1.05);
    }
    
    .editor-toggle:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
      pointer-events: auto; /* Still absorb clicks when disabled */
    }
    
    .editor-toggle:disabled:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.2);
      transform: none;
    }
    
  </style>
</head>
<body>
  <!-- Editor toggle button -->
  <button id="editorToggle" class="editor-toggle" title="Toggle Editor Mode (⌘E)" style="left: 120px; width: 80px;">
    ✏️
  </button>

  <!-- Upload button -->
  <button id="exportButton" class="editor-toggle" title="Upload Card to Storage (⌘S)" style="left: 220px; width: 80px;">
    💾
  </button>

  <!-- Add card button -->
  <button id="addCardButton" class="editor-toggle" title="Add New Card to Current Set" style="left: 20px; width: 80px;">
    ➕
  </button>

  <!-- Zoom out button -->
  <button id="zoomOutButton" class="editor-toggle" title="Toggle Zoom (Enter)" style="left: auto; right: 20px; width: 80px;">
    🔍
  </button>

  <!-- Card indicator -->
  <div id="cardIndicator" class="editor-toggle" style="left: auto; right: 120px; background: transparent; width: 80px; text-align: center;">
    0 / 0
  </div>

  <main class="container-fluid">
    <div class="grid">
      <div>
        <div id="canvasWrapper" style="position: relative; overflow: hidden; border-radius: 16px;">
          <canvas id="board" width="600" height="971" aria-label="drawing canvas" style="position: relative; z-index: 1;"></canvas>
        </div>
</div>
      <aside>
        <div id="cardFileName" style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 0.9em; color: var(--pico-muted-color); margin-bottom: 1rem; padding: 0.5rem; background: var(--pico-form-element-background-color); border: 1px solid var(--pico-form-element-border-color); border-radius: 4px; text-align: center;">
          1.json
        </div>
        <details>
          <summary>Instruction</summary>
      <small>
        <strong>Encoding:</strong> Each byte is <code>axxxbyyy</code> (MSB→LSB), where <code>xxx</code> and <code>yyy</code> are 3-bit values mapped via <code>(v<=4?v:4-v)</code>.
        <br>
        <div class="mono-grid">bit7 bit6..4 bit3 bit2..0
a     xxx    b    yyy</div>
        <br>
        <strong>Line type (<code>ab</code>):</strong>
        <br>
        <div class="mono-grid">00 line
01 elliptical arc type 1
10 elliptical arc type 2
11 invisible (move only)</div>
        <br>
        <strong>Zero move:</strong> If <code>xxx=000</code> and <code>yyy=000</code>, behavior depends on ab:
        <div class="mono-grid">00 snap to top of textline (move only)
01 point
10 circle radius 1/2
11 extension code</div>
        <br>
            <strong>Pipes:</strong>
            <br>
            <code>|</code> next glyph
            <br>
            <code>||</code> next text row
      </small>
        </details>
        
        <details>
          <summary>Option</summary>
          <div class="grid">
            <div>
              <label for="sInput">Size <span id="sValue">8</span></label>
              <input id="sInput" type="range" min="2" max="40" value="5"/>
            </div>
            <div>
              <label for="bgColorSelect">Background <span id="bgColorIndicator" style="display: inline-block; width: 12px; height: 12px; background-color: #000000; border: 1px solid #ccc; margin-left: 4px; vertical-align: middle;"></span></label>
              <select id="bgColorSelect">
                <option value="transparent">Transparent</option>
              </select>
            </div>
            <div>
              <input id="italicsCheckbox" type="checkbox" checked/>
              <label for="italicsCheckbox">Italics</label>
            </div>
            <div>
              <input id="animateCheckbox" type="checkbox"/>
              <label for="animateCheckbox">Animate</label>
            </div>
            <div>
              <label>Position</label>
              <div id="positionDisplay" style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; font-size: 0.9em; color: var(--pico-muted-color); margin-top: 0.25rem; padding: 0.25rem 0.5rem; background: var(--pico-form-element-background-color); border: 1px solid var(--pico-form-element-border-color); border-radius: 4px;">
                Not set
              </div>
            </div>
            <div>
              <label for="orderSelect">Order</label>
              <select id="orderSelect">
                <option value="">Undefined</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
                <option value="10">10</option>
                <option value="11">11</option>
                <option value="12">12</option>
                <option value="13">13</option>
                <option value="14">14</option>
                <option value="15">15</option>
              </select>
            </div>
          </div>
          <div style="margin-top: 1rem;">
            <div>
              <input id="svgColorCheckbox" type="checkbox"/>
              <label for="svgColorCheckbox">SVG Color</label>
            </div>
            <label for="svgInput">Background Svg</label>
            <input id="svgInput" type="url" placeholder="https://example.com/image.svg or paste SVG code directly">
            <div id="svgPreview" style="margin-top: 1rem; padding: 1rem; border: 1px solid #ccc; border-radius: 4px; background: white; min-height: 100px; display: none;">
              <div id="svgPreviewContent" style="background: linear-gradient(135deg, #f8f8f8 0%, #a0a0a0 100%); padding: 10px; border-radius: 4px;"></div>
            </div>
          </div>
        </details>
        
        
        <details open>
          <summary>Rule</summary>
          <div id="strRule" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details open>
          <summary>Input</summary>
          <div id="strInput" class="ce-editor" contenteditable="true" role="textbox" aria-multiline="true">
          </div>
        </details>
        
        <details open>
          <summary>Output</summary>
          <div id="strOutput" class="ce-editor">
          </div>
        </details>
    </aside>
  </div>
  </main>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    
    // Page fade effect functions
    function fadeOutPage() {
      document.body.classList.add('page-transitioning');
      document.body.style.opacity = '0';
    }
    
    function fadeInPage() {
      document.body.style.opacity = '1';
      setTimeout(() => {
        document.body.classList.remove('page-transitioning');
      }, 400); // Wait for transition to complete
    }
    
    // ===== INITIALIZATION =====
    let editorVisible = false;
    let isFlipping = false; // Flag to track if card is currently flipping
    let italicsMode = true;
    let s = 8;
    let thickness = s / 10;
    const pad = { left: 1, top: 1, right: 1 };
    const start = { xi: pad.left, yi: pad.top };
    
    // ===== CARD SYSTEM =====
    const CARD_BASE_URL = `{{SUPABASE_URL}}/storage/v1/object/public/card/`;
    
    // Check if SUPABASE_URL was properly replaced
    if (CARD_BASE_URL.includes('{{SUPABASE_URL}}')) {
      console.warn('SUPABASE_URL not replaced - make sure to access via FastAPI server with LOCAL_SUPABASE_URL set');
    }
    
    // ===== SUPABASE CLIENT =====
    const SUPABASE_URL = '{{SUPABASE_URL}}';
    const SUPABASE_SERVICE_ROLE_KEY = '{{SUPABASE_SERVICE_ROLE_KEY}}';
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
    let currentCardIndex = 1;
    let maxCardIndex = 0; // Will be determined by checking available cards
    
    // ===== CARD PRELOADING SYSTEM =====
    const MAX_CARDS_PER_SET = 15; // Maximum cards per set
    const cardCache = new Map(); // Cache for card JSON data
    const svgCache = new Map(); // Cache for SVG content
    let currentBlockStart = 1; // Starting index of current preloaded block
    let preloadingInProgress = false;
    let setBoundaries = new Map(); // Cache for set boundaries: cardIndex -> {start, end, size}
    
    
    // ===== DOM REFERENCES =====
    const canvas = document.getElementById('board');
    let ctx = canvas.getContext('2d', { alpha: true });
    const bgColorSelectEl = document.getElementById('bgColorSelect');
    const svgPreview = document.getElementById('svgPreview');
    const svgPreviewContent = document.getElementById('svgPreviewContent');
    let svgBackground = document.getElementById('svgBackground');
    let canvasWrapper = document.getElementById('canvasWrapper');
    const inputEl = document.getElementById('strInput');
    const ruleEl = document.getElementById('strRule');
    const outputEl = document.getElementById('strOutput');
    const sInputEl = document.getElementById('sInput');
    const sValueEl = document.getElementById('sValue');
    const animateCheckbox = document.getElementById('animateCheckbox');
    const orderSelectEl = document.getElementById('orderSelect');
    const italicsCheckbox = document.getElementById('italicsCheckbox');
    const svgColorCheckbox = document.getElementById('svgColorCheckbox');
    const cardFileNameEl = document.getElementById('cardFileName');
    const editorToggleBtn = document.getElementById('editorToggle');
    const exportButton = document.getElementById('exportButton');
    const addCardButton = document.getElementById('addCardButton');
    const zoomOutButton = document.getElementById('zoomOutButton');
    const cardIndicator = document.getElementById('cardIndicator');
    const svgInputEl = document.getElementById('svgInput');
    let cardElement = null;
    
    // Utility function to prevent card flip on button clicks
    function preventCardFlip(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Check if editor toggle is allowed
    function canToggleEditor() {
      const now = performance.now();
      const isInCooldown = now < animationCooldownEnd;
      return document.activeElement !== inputEl && 
             document.activeElement !== ruleEl && 
             document.activeElement !== outputEl && 
             !isFlipping && 
             !currentAnim && 
             !isInCooldown;
    }
    
    // ===== CANVAS SETUP =====
    const cssW = 600, cssH = 1000;
    const dpr = window.devicePixelRatio || 1;
    if (dpr !== 1) {
      canvas.width = cssW * dpr;
      canvas.height = cssH * dpr;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(dpr, dpr);
    }
    const width = cssW, height = cssH;
    let gridX = Math.floor(width / s);
    
    // ===== DRAWING CONSTANTS =====
    const COLORS = [
      { name: 'bla', hex: '#000000' },
      { name: 'car', hex: '#8c0004' },
      { name: 'red', hex: '#f80007' },
      { name: 'ora', hex: '#f34001' },
      { name: 'amb', hex: '#faaf00' },
      { name: 'yel', hex: '#d9ce00' },
      { name: 'grn', hex: '#0ccc0e' },
      { name: 'cya', hex: '#00dfd8' },
      { name: 'blu', hex: '#3441fc' },
      { name: 'ind', hex: '#5020e0' },
      { name: 'pur', hex: '#8000f0' },
      { name: 'vio', hex: '#350063' },
      { name: 'gry', hex: '#808080' },
      { name: 'wht', hex: '#ffffff' }
    ];
    const THICKNESS_MULTIPLIERS = {
      outline: 12,
      main: 4,
      pointOutline: 6,
      pointRadius: 4,
      endMarkerRadius: 3
    };
    const DEFAULT_PANEL_COLOR_INDEX = 1;
    
    let currentLetterHexPairIndex = 0;
    let highlightTimeout = null; // Timeout to prevent infinite highlighting loops
    
    // ===== CANVAS CONTEXT SETUP =====
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.textRenderingOptimization = 'optimizeQuality';
    
    // Calculate luminosity of a hex color (0-1, where 1 is brightest)
    function getLuminosity(hexColor) {
      const rgb = hexToRgb(hexColor);
      // Using relative luminance formula
      const r = rgb.r / 255;
      const g = rgb.g / 255;
      const b = rgb.b / 255;
      
      const rsRGB = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      const gsRGB = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
      const bsRGB = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
      
      return 0.2126 * rsRGB + 0.7152 * gsRGB + 0.0722 * bsRGB;
    }
    
    // ===== DRAWING FUNCTIONS =====
    function drawOutline(isPoint = false) {
      if (editorVisible) return;
      
      const backgroundColor = bgColorSelectEl.value;
      const blendedColor = blendColors(backgroundColor, '#606060', 0.2);
      
      ctx.strokeStyle = blendedColor;
      ctx.lineWidth = thickness * (isPoint ? THICKNESS_MULTIPLIERS.pointOutline : THICKNESS_MULTIPLIERS.outline);
      ctx.stroke();
    }
    
    function drawPointOutline() {
      drawOutline(true);
    }
    
    // Utility functions for color operations
    function hexToRgb(hex) {
      const h = hex.replace('#', '');
      return {
        r: parseInt(h.substr(0, 2), 16),
        g: parseInt(h.substr(2, 2), 16),
        b: parseInt(h.substr(4, 2), 16)
      };
    }
    
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    
    function blendColors(color1, color2, ratio) {
      const rgb1 = hexToRgb(color1);
      const rgb2 = hexToRgb(color2);
      return rgbToHex(
        Math.round(rgb1.r + (rgb2.r - rgb1.r) * ratio),
        Math.round(rgb1.g + (rgb2.g - rgb1.g) * ratio),
        Math.round(rgb1.b + (rgb2.b - rgb1.b) * ratio)
      );
    }

    const toCanvas=(p)=>({x:p.xi*s,y:p.yi*s});
    
    // Apply italics skew transformation to a point
    function applyItalicsTransform(point) {
      if (!italicsMode) return point;
      
      // Calculate which text line this point belongs to (each text line is 8 grid units tall)
      const textLineHeight = 8 * s;
      const textLineIndex = Math.floor(point.y / textLineHeight);
      
      // Calculate the skew offset for this text line
      // Each text line gets skewed by its own height within that line
      const skewFactor = -0.15;
      const yWithinTextLine = point.y - (textLineIndex * textLineHeight);
      const skewOffset = s + yWithinTextLine * skewFactor;
      
      return {
        x: point.x + skewOffset,
        y: point.y
      };
    }
    
    
    
    function checkForZAxisRotation(svgContent) {
      // Check for animated z-axis rotations (spinning) in SVG content
      const patterns = [
        // Animation transforms with rotate
        /animateTransform[^>]*type\s*=\s*["']rotate["'][^>]*>/gi,
        // CSS animations with rotate
        /@keyframes[^}]*{[^}]*rotate\s*\([^)]+\)/gi,
        // Animation properties with rotate
        /animation[^;]*rotate/gi,
        // Animate elements with rotate
        /<animate[^>]*rotate/gi
      ];
      
      return patterns.some(pattern => pattern.test(svgContent));
    }
    
    async function drawSvgBackground() {
      const svgValue = svgInputEl.value.trim();
      if (!svgValue) return;
      
      let svgContent;
      
      // Check if it's a URL (starts with http/https) or SVG code
      if (svgValue.startsWith('http://') || svgValue.startsWith('https://')) {
        // Check cache first
        svgContent = svgCache.get(svgValue);
        
        if (!svgContent) {
          try {
            const response = await fetch(svgValue);
            svgContent = await response.text();
            svgCache.set(svgValue, svgContent);
          } catch (error) {
            console.error('Failed to fetch SVG from URL:', error);
            return;
          }
        }
        } else {
        // It's SVG code directly
        svgContent = svgValue;
      }
      
      // Process SVG content
      let processedSvg = svgContent;
      
      // Remove SVG animations when in edit mode
      if (editorVisible) {
        // Remove all animation elements (both self-closing and with content)
        processedSvg = processedSvg.replace(/<animate[^>]*(?:\/>|>.*?<\/animate>)/g, '');
        processedSvg = processedSvg.replace(/<animateTransform[^>]*(?:\/>|>.*?<\/animateTransform>)/g, '');
        processedSvg = processedSvg.replace(/<animateMotion[^>]*(?:\/>|>.*?<\/animateMotion>)/g, '');
      }
      
      // Remove explicit width and height attributes to allow proper container sizing
      // But preserve dimensions for rect elements that define backgrounds
      processedSvg = processedSvg.replace(/width="[^"]*"/g, '');
      processedSvg = processedSvg.replace(/height="[^"]*"/g, '');
      
      // Restore width and height for rect elements that have fill colors (backgrounds)
      // More flexible approach: find any rect with fill and extract width/height separately
      const originalSvg = svgContent;
      const widthMatch = originalSvg.match(/<rect[^>]*?width="([^"]*)"[^>]*?>/);
      const heightMatch = originalSvg.match(/<rect[^>]*?height="([^"]*)"[^>]*?>/);
      const fillMatch = originalSvg.match(/<rect[^>]*?style="[^"]*fill:[^"]*"[^>]*?>/);
      
      if (widthMatch && heightMatch && fillMatch) {
        processedSvg = processedSvg.replace(/<rect([^>]*?)style="([^"]*fill:[^"]*)"([^>]*?)>/g, 
          `<rect$1width="${widthMatch[1]}" height="${heightMatch[1]}" style="$2"$3>`);
      }
      
      // Normalize viewBox attribute (fix lowercase viewbox to proper viewBox)
      processedSvg = processedSvg.replace(/viewbox="([^"]*)"/g, 'viewBox="$1"');
      
      // Strip SVG colors to allow CSS inheritance
      processedSvg = stripSvgColors(processedSvg);
      
      // Check if SVG contains z-axis rotations (spins)
      const hasZRotation = checkForZAxisRotation(svgContent);
      
      // Keep original viewBox - CSS object-fit will handle the scaling
      
      if (editorVisible) {
        // Show SVG in preview box when in editor mode
        if (svgPreview && svgPreviewContent) {
          svgPreview.style.display = 'block';
          svgPreviewContent.innerHTML = `
            <style>
              #svgPreviewContent svg {
                width: 100%;
                max-width: 200px;
                height: auto;
                display: block;
                margin: 0 auto;
              }
            </style>
            ${processedSvg}
          `;
        }
        
        // Hide background SVG when in editor mode
        if (svgBackground) {
          svgBackground.style.display = 'none';
        }
      } else {
        // Show SVG as background when not in editor mode
        if (svgPreview) {
          svgPreview.style.display = 'none';
        }
      
      // Create or update background SVG element
      const canvas = document.getElementById('board');
      
      // Check if SVG background element exists in DOM, if not create it
      if (!svgBackground || !document.getElementById('svgBackground')) {
        svgBackground = document.createElement('div');
        svgBackground.id = 'svgBackground';
          svgBackground.style.position = 'absolute';
          svgBackground.style.top = '0';
          svgBackground.style.left = '0';
          svgBackground.style.width = '100%';
          svgBackground.style.height = '100%';
        svgBackground.style.zIndex = '0';
          svgBackground.style.pointerEvents = 'none';

          // Add it as a child of the wrapper
          canvasWrapper.appendChild(svgBackground);
      }
        
        svgBackground.style.display = 'block';
      
      // Position and size exactly like the canvas
      
        // Get current background color for glow
        const selectedColor = bgColorSelectEl.value;
        
        // Convert hex to RGB for glow
        const rgb = hexToRgb(selectedColor);
        
        // Calculate text color for SVG
        const textColor = calculateSvgTextColor(selectedColor, editorVisible);
      
      svgBackground.innerHTML = `
        <style>
          #svgBackground ${createSvgStyle(true, hasZRotation ? '0.707' : '1', textColor)}
          /* filter: drop-shadow(0 0 10px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.4)) drop-shadow(0 0 20px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)) drop-shadow(0 0 30px rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.2)); */
        </style>
        ${processedSvg}
      `;
      
      // Force a reflow/repaint to ensure SVG is rendered
      svgBackground.offsetHeight; // Force reflow
      }
    }
    
    function drawSvgElement(element, scaleX, scaleY, offsetX, offsetY) {
      const tagName = element.tagName.toLowerCase();
      
      if (tagName === 'rect') {
        const x = parseFloat(element.getAttribute('x') || 0) * scaleX + offsetX;
        const y = parseFloat(element.getAttribute('y') || 0) * scaleY + offsetY;
        const w = parseFloat(element.getAttribute('width')) * scaleX;
        const h = parseFloat(element.getAttribute('height')) * scaleY;
        const fill = element.getAttribute('fill') || '#000';
        
        ctx.fillStyle = fill;
        ctx.fillRect(x, y, w, h);
      }
      else if (tagName === 'circle') {
        const cx = parseFloat(element.getAttribute('cx')) * scaleX + offsetX;
        const cy = parseFloat(element.getAttribute('cy')) * scaleY + offsetY;
        const r = parseFloat(element.getAttribute('r')) * Math.min(scaleX, scaleY);
        const fill = element.getAttribute('fill') || '#000';
        const stroke = element.getAttribute('stroke');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.lineWidth = strokeWidth;
          ctx.stroke();
        }
      }
      else if (tagName === 'path') {
        const d = element.getAttribute('d');
        const stroke = element.getAttribute('stroke') || '#000';
        const fill = element.getAttribute('fill');
        const strokeWidth = parseFloat(element.getAttribute('stroke-width') || 1) * Math.min(scaleX, scaleY);
        
        if (d) {
          // Use proper SVG path parser with offsets
          drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY);
        }
      }
    }
    
    function drawSvgPath(d, stroke, fill, strokeWidth, scaleX, scaleY, offsetX, offsetY) {
      // Parse SVG path data
      const commands = parseSvgPath(d);
      
      ctx.beginPath();
      
      let currentX = 0, currentY = 0;
      let startX = 0, startY = 0;
      
      for (let i = 0; i < commands.length; i++) {
        const cmd = commands[i];
        
        switch (cmd.type) {
          case 'M': // Move to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'm': // Move to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            startX = currentX;
            startY = currentY;
            ctx.moveTo(currentX, currentY);
            break;
            
          case 'L': // Line to (absolute)
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'l': // Line to (relative)
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            ctx.lineTo(currentX, currentY);
            break;
            
          case 'C': // Cubic curve (absolute)
            ctx.bezierCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x2 * scaleX + offsetX, cmd.y2 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'c': // Cubic curve (relative)
            ctx.bezierCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x2 * scaleX, currentY + cmd.y2 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Q': // Quadratic curve (absolute)
            ctx.quadraticCurveTo(
              cmd.x1 * scaleX + offsetX, cmd.y1 * scaleY + offsetY,
              cmd.x * scaleX + offsetX, cmd.y * scaleY + offsetY
            );
            currentX = cmd.x * scaleX + offsetX;
            currentY = cmd.y * scaleY + offsetY;
            break;
            
          case 'q': // Quadratic curve (relative)
            ctx.quadraticCurveTo(
              currentX + cmd.x1 * scaleX, currentY + cmd.y1 * scaleY,
              currentX + cmd.x * scaleX, currentY + cmd.y * scaleY
            );
            currentX += cmd.x * scaleX;
            currentY += cmd.y * scaleY;
            break;
            
          case 'Z': // Close path
          case 'z':
            ctx.closePath();
            currentX = startX;
            currentY = startY;
            break;
        }
      }
      
      // Fill and stroke
      if (fill && fill !== 'none') {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      
      if (stroke && stroke !== 'none') {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
      }
    }
    
    function parseSvgPath(d) {
      // Simple SVG path parser
      const commands = [];
      const tokens = d.match(/[MmLlHhVvCcSsQqTtAaZz]|[+-]?[0-9]*\.?[0-9]+/g) || [];
      
      let i = 0;
      while (i < tokens.length) {
        const token = tokens[i];
        
        if (/[MmLlHhVvCcSsQqTtAaZz]/.test(token)) {
          const command = token;
          i++;
          
          switch (command) {
            case 'M':
            case 'm':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'L':
            case 'l':
              if (i + 1 < tokens.length) {
                commands.push({
                  type: command,
                  x: parseFloat(tokens[i]),
                  y: parseFloat(tokens[i + 1])
                });
                i += 2;
              }
              break;
              
            case 'C':
            case 'c':
              if (i + 5 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x2: parseFloat(tokens[i + 2]),
                  y2: parseFloat(tokens[i + 3]),
                  x: parseFloat(tokens[i + 4]),
                  y: parseFloat(tokens[i + 5])
                });
                i += 6;
              }
              break;
              
            case 'Q':
            case 'q':
              if (i + 3 < tokens.length) {
                commands.push({
                  type: command,
                  x1: parseFloat(tokens[i]),
                  y1: parseFloat(tokens[i + 1]),
                  x: parseFloat(tokens[i + 2]),
                  y: parseFloat(tokens[i + 3])
                });
                i += 4;
              }
              break;
              
            case 'Z':
            case 'z':
              commands.push({ type: command });
              i++;
              break;
              
            default:
              i++; // Skip unknown commands
              break;
          }
        } else {
          i++;
        }
      }
      
      return commands;
    }
    
    let gridFadeStartTime = null;
    let gridFadeComplete = false;
    
    function drawGridPoints(spacing=s){
      // Only draw grid points in edit mode and not currently flipping
      if (editorVisible && !isFlipping) {
        ctx.save();
        const baseColor = '#666666';
        const r = thickness * 3;
        
        // Calculate fade-in opacity
        let fadeOpacity = 1;
        if (!gridFadeComplete) {
          if (gridFadeStartTime === null) {
            gridFadeStartTime = performance.now();
            fadeOpacity = 0; // Start invisible
          } else {
            const fadeDuration = 1200; // 1.2s fade-in
            const elapsed = performance.now() - gridFadeStartTime;
            fadeOpacity = Math.min(elapsed / fadeDuration, 1);
            
            // If fade is complete, mark it as done
            if (fadeOpacity >= 1) {
              gridFadeComplete = true;
            }
          }
        }
        
        for(let y = 0; y <= height; y += spacing){
          // Determine if this row is in an even or odd text row space
          const textRowIndex = Math.floor(y / (8 * s));
          const isEvenTextRow = textRowIndex % 2 === 0;
          
          // Use different colors for alternating text rows
          const rowColor = isEvenTextRow ? '#6e6e6e' : '#565656';
          
          ctx.fillStyle = rowColor;
          ctx.globalAlpha = fadeOpacity;
          
          for(let x = 0; x <= width; x += spacing){
            const point = applyItalicsTransform({x, y});
            ctx.beginPath();
            ctx.arc(point.x, point.y, r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.restore();
        
        // If fade is not complete, schedule another render
        if (!gridFadeComplete) {
          requestAnimationFrame(() => {
            renderNow();
          });
        }
      } else {
        // Reset fade state when not in editor mode or when flipping
        gridFadeStartTime = null;
        gridFadeComplete = false;
      }
    }
    
    // ===== UTILITY FUNCTIONS =====
    const preMoveWrap = (xi, yi, dx) => {
      const maxX = gridX - pad.right;
      if (dx > 0 && (xi + dx) > maxX) { xi = pad.left; yi += 8; }
      return { xi, yi };
    };
    
    const snapToLineTop = (yi) => pad.top + 8 * Math.floor((yi - pad.top) / 8);
    
    const normAngle = (a) => {
      const twoPI = Math.PI * 2;
      while (a <= -Math.PI) a += twoPI;
      while (a > Math.PI) a -= twoPI;
      return a;
    };
    
    const anticlockwiseForShortest = (a0, a1) => {
      const twoPI = Math.PI * 2;
      let cw = (a1 - a0) % twoPI;
      if (cw < 0) cw += twoPI;
      let ccw = (a0 - a1) % twoPI;
      if (ccw < 0) ccw += twoPI;
      return ccw <= cw;
    };
    
    const angleOnEllipse = (cx, cy, rx, ry, x, y) => Math.atan2((y - cy) / ry, (x - cx) / rx);    

    // ===== PARSING FUNCTIONS =====
    function parseBytesWithColors(str){
      const out=[]; let buf='';
      const isHex = c => /[0-9a-fA-F]/.test(c);

      for(let i=0;i<(str?str.length:0);i++){
        const ch = str[i];
        
        // Handle comments: skip everything after "//" until end of line
        if(ch === '/' && str[i + 1] === '/'){
          // Skip to end of line (newline or end of string)
          while(i < str.length && str[i] !== '\n'){
            i++;
          }
          // Don't skip the newline character itself, let it be processed normally
          if(i < str.length && str[i] === '\n'){
            i--; // Back up one so the newline gets processed in the next iteration
          }
          continue;
        }
        
        if(ch==='|'){
          const next = str[i+1];
          if(next==='|'){
            out.push({newline:true});
            i++;
          }else{
            // emit the literal pipe as a non-byte token so caret offsets match textContent
            out.push({pipe:true});
          }
          continue;
        }
        if(isHex(ch)){
          buf += ch;
          if(buf.length===2){
            out.push({byte:parseInt(buf,16), text:buf});
            buf='';
          }
          continue;
        } else {
          // reset partial hex if we hit a non-hex separator mid-token
          if (buf) out.push({text:buf});
          out.push({text:ch});
          buf = '';
        }
      }
      if (buf) out.push({text:buf});
      return out;
    }

    function triBitsToSigned(v3){return(v3<=4)?v3:(4-v3);}    

    // --- Animation state ---
    let currentAnim = null; // { timer, ops, idx, visited }
    let animationCooldownEnd = 0; // timestamp when animation cooldown ends
    const ANIMATION_COOLDOWN_MS = 1000; // 1 second cooldown after animation finishes
    const STEP_DELAY_MS = 20; // delay between each drawing command
    const DRAW_MS = STEP_DELAY_MS;       // how long each piece takes to draw
    
    // ===== ANIMATION FUNCTIONS =====
    function stopAnim(){
      if (currentAnim && currentAnim.rafId) cancelAnimationFrame(currentAnim.rafId);
      currentAnim = null;
      // Start cooldown period after animation finishes
      animationCooldownEnd = performance.now() + ANIMATION_COOLDOWN_MS;
    }
    
    function startAnim(ops, visited){
      stopAnim();
      
      // Clear canvas before starting animation
      ctx.clearRect(0, 0, width, height);
      
      const animStart = performance.now();

      // When each op *starts* becoming visible
      const theFirstVisibleAt = ops.map((_, i) => animStart + i * STEP_DELAY_MS);

      currentAnim = {
        ops, visited,
        animStart, firstVisibleAt: theFirstVisibleAt,
        rafId: null
      };

      const tick = (now) => {
        if (!currentAnim) return;

        // How many ops have "started" by now?
        let started = 0;
        while (started < ops.length && now >= currentAnim.firstVisibleAt[started]) started++;

        // Draw frame with progressive drawing
        drawFrameProgressive(now, started, ops, currentAnim.firstVisibleAt, visited);

        // Done when the last op has fully drawn
        const allDone = ops.length === 0 || (now >= currentAnim.firstVisibleAt[ops.length - 1] + DRAW_MS);
        if (!allDone) {
          currentAnim.rafId = requestAnimationFrame(tick);
        } else {
          // Save firstVisibleAt before stopping animation
          const firstVisibleAt = currentAnim.firstVisibleAt;
          stopAnim();
          drawFrameProgressive(now, ops.length, ops, firstVisibleAt, visited, /*isAnimating=*/false);
        }
      };

      currentAnim.rafId = requestAnimationFrame(tick);
    }

    function drawFrameProgressive(now, startedCount, ops, firstVisibleAt, visited, isAnimating = true){
      // Reset max Y tracking
      
      // Only draw grid points in edit mode and not flipping
      if (editorVisible && !isFlipping) {
        drawGridPoints(s);
      }
      
      // Don't set lineWidth here - let each drawOp set its own thickness

      // First pass: draw all outlines
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0→1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpOutline(op, progress);
      }
      
      // Second pass: draw all main strokes on top
      for (let i = 0; i < startedCount; i++) {
        const op = ops[i];
        const t0 = firstVisibleAt[i];
        const progress = Math.max(0, Math.min(1, (now - t0) / DRAW_MS)); // 0→1 over DRAW_MS

        if (progress <= 0) continue; // not visible yet

        drawOpMain(op, progress);
      }

      // Show ONLY the red end marker when NOT animating AND in edit mode
      if (!isAnimating && editorVisible && visited && visited.length) {
        const endPix = applyItalicsTransform(toCanvas(visited[visited.length - 1]));
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(endPix.x, endPix.y, thickness * THICKNESS_MULTIPLIERS.endMarkerRadius, 0, Math.PI * 2);
        ctx.fill();
      }
      
    }

    // ===== RENDERING FUNCTIONS =====
    function drawOpUnified(op, progress = 1, mode = 'outline'){
      if(op.type==='line'){
        const p1=applyItalicsTransform(toCanvas(op.from)),p2=applyItalicsTransform(toCanvas(op.to));
        
        // Track maximum Y coordinate
        
        if (progress >= 1) {
        ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(p2.x,p2.y);
        } else {
          const intermediate = {
            x: p1.x + (p2.x - p1.x) * progress,
            y: p1.y + (p2.y - p1.y) * progress
          };
          ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.lineTo(intermediate.x,intermediate.y);
        }
        
        if (mode === 'outline') {
          drawOutline();
        } else if (mode === 'main') {
        ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * THICKNESS_MULTIPLIERS.main;
        ctx.stroke();
        } else { // 'both'
          drawOutline();
          ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * THICKNESS_MULTIPLIERS.main;
          ctx.stroke();
        }
      }else if(op.type==='arc'){
        const transformedCenter = applyItalicsTransform({x: op.cx, y: op.cy});
        
        if(op.start === 0 && op.end === Math.PI * 2){
        ctx.beginPath();
          const endAngle = progress >= 1 ? Math.PI*2 : Math.PI * 2 * progress;
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,0,endAngle,false);
        } else {
          const startX = op.cx + op.rx * Math.cos(op.start);
          const startY = op.cy + op.ry * Math.sin(op.start);
          const endX = op.cx + op.rx * Math.cos(op.end);
          const endY = op.cy + op.ry * Math.sin(op.end);
          
          const transformedStart = applyItalicsTransform({x: startX, y: startY});
          const transformedEnd = applyItalicsTransform({x: endX, y: endY});
          
          const newStartAngle = Math.atan2(transformedStart.y - transformedCenter.y, transformedStart.x - transformedCenter.x);
          const newEndAngle = Math.atan2(transformedEnd.y - transformedCenter.y, transformedEnd.x - transformedCenter.x);
          
          if (progress >= 1) {
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,newEndAngle,op.acw);
          } else {
            let angleDiff = op.acw ? newStartAngle - newEndAngle : newEndAngle - newStartAngle;
              if (angleDiff <= 0) angleDiff += Math.PI * 2;
            
            const progressAngle = angleDiff * progress;
            const progressEndAngle = op.acw ? newStartAngle - progressAngle : newStartAngle + progressAngle;
              
            ctx.beginPath();
            ctx.ellipse(transformedCenter.x,transformedCenter.y,op.rx,op.ry,0,newStartAngle,progressEndAngle,op.acw);
          }
        }
        
        if (mode === 'outline') {
          drawOutline();
        } else if (mode === 'main') {
        ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * THICKNESS_MULTIPLIERS.main;
          ctx.stroke();
        } else { // 'both'
          drawOutline();
          ctx.strokeStyle = op.color;
          ctx.lineWidth = thickness * THICKNESS_MULTIPLIERS.main;
        ctx.stroke();
        }
      }else if(op.type==='point'){
        const c=applyItalicsTransform(toCanvas(op));
        
        const radius = progress >= 1 ? thickness*THICKNESS_MULTIPLIERS.pointRadius : thickness * THICKNESS_MULTIPLIERS.pointRadius * progress;
          ctx.beginPath();ctx.arc(c.x,c.y,radius,0,Math.PI*2);
        
        if (mode === 'outline') {
          drawPointOutline();
        } else if (mode === 'main') {
          ctx.fillStyle = op.color;
          ctx.fill();
        } else { // 'both'
          ctx.fillStyle = '#000000';
          ctx.fill();
        ctx.fillStyle = op.color;
        ctx.fill();
        }
      }
    }

    // ===== DRAWING FUNCTIONS =====
    const drawOpOutline = (op, progress = 1) => drawOpUnified(op, progress, 'outline');
    const drawOpMain = (op, progress = 1) => drawOpUnified(op, progress, 'main');
    const drawOp = (op, progress = 1) => drawOpUnified(op, progress, 'both');

    // ===== OPERATION BUILDING =====
    function buildOps(coloredItems){
      let xi=start.xi,yi=start.yi;
      const ops=[]; const visited=[{xi,yi}];
      let currentLetterIndex = getCurrentLetterIndex();
      let letterIndex = 0;
      
      // Check if input has pipes to determine letter counting strategy
      const inputRaw = getPlainText(inputEl);
      const hasPipes = inputRaw.includes('|');
      
      // Reset hex pair counter for consistent color cycling
      currentLetterHexPairIndex = 0;

      for(const item of coloredItems){
        if(item.newline){
          // Move to the next text row boundary, regardless of current position
          yi = pad.top + 8 * (Math.floor((yi - pad.top) / 8) + 1);
          xi = pad.left; 
          visited.push({xi,yi});
          // Newline counts as a new letter only if pipes are present
          if (hasPipes) {
            letterIndex++;
            currentLetterHexPairIndex = 0; // Reset hex pair counter
          }
          continue;
        }
        if (item.pipe) {
          // literal single '|', increment letter index only if pipes are present
          if (hasPipes) {
            letterIndex++;
            currentLetterHexPairIndex = 0; // Reset hex pair counter
          }
          continue;
        }
        if (item.text && item.byte === undefined) {
          // free text / separators — ignore for drawing
          continue;
        }

        const b = item.byte;
        const backgroundColor = bgColorSelectEl.value;
        // Highlight current letter with red color only when Input field is focused, others with white
        const isInputFocused = document.activeElement === inputEl;
        const isCurrentLetter = letterIndex === currentLetterIndex && isInputFocused;
        // Calculate background luminosity for adaptive text color
        const luminosity = getLuminosity(backgroundColor);
        
        // In editor mode, always use pure white. In presentation mode, use adaptive colors
        let textColor;
        if (editorVisible) {
          textColor = '#ffffff'; // Always white in editor mode
        } else {
          // For presentation mode, use dark text on bright backgrounds, light text on dark backgrounds
          if (luminosity > 0.5) {
            // Bright background - use dark text
            textColor = blendColors(backgroundColor, '#000000', 0.8);
          } else {
            // Dark background - use light text
            textColor = blendColors(backgroundColor, '#ffffff', 0.7);
          }
        }

        const a=(b>>7)&1;
        const xxx=(b>>4)&0b111;
        const bitB=(b>>3)&1;
        const yyy=b&0b111;
        const isZero=(xxx===0&&yyy===0);
        const ab=(a<<1)|bitB;
        const isInvisibleMove = ab === 0b11;

        // For current letter, use different colors for each hex pair (skip invisible moves)
        let stroke;
        if (isCurrentLetter && !isInvisibleMove) {
          // Use the tracked hex pair index within current letter (both editor and presentation modes)
          const colorIndex = currentLetterHexPairIndex % HEX_PAIR_COLORS.length;
          stroke = HEX_PAIR_COLORS[colorIndex];
          currentLetterHexPairIndex++; // Increment for next visible hex pair
        } else {
          stroke = textColor;
        }

        if(isZero){
          if(ab===0b00){ yi=snapToLineTop(yi); }
          else if(ab===0b01){ ops.push({type:'point', xi, yi, color:stroke}); }
          else if(ab===0b10){ ops.push({type:'arc', cx:toCanvas({xi,yi}).x, cy:toCanvas({xi,yi}).y, rx:s*0.5, ry:s*0.5, start:0, end:Math.PI*2, acw:false, color:stroke}); }
          else { /* ab===0b11: extension code - not implemented yet */ }
          visited.push({xi,yi});
          continue;
        }

        const dx=triBitsToSigned(xxx),dy=triBitsToSigned(yyy);
        ({xi,yi}=preMoveWrap(xi,yi,Math.max(0,dx)));
        const from={xi,yi};
        const to={xi:xi+dx,yi:yi+dy};

        if(ab===0b11){
          // Invisible move
          xi=to.xi; yi=to.yi; visited.push({xi,yi});
          continue;
        }

        if(ab===0b00){
          ops.push({type:'line', from, to, color:stroke});
        }else{
          const p0=toCanvas(from),p1=toCanvas(to);
          let cx,cy,rx,ry,a0,a1; let semi=false;
          if(dx!==0&&dy!==0){
            rx=Math.abs(dx)*s; ry=Math.abs(dy)*s;
            if(ab===0b01){ cx=p0.x; cy=p0.y+dy*s; }
            else{          cx=p0.x+dx*s; cy=p0.y; }
            a0=angleOnEllipse(cx,cy,rx,ry,p0.x,p0.y);
            a1=angleOnEllipse(cx,cy,rx,ry,p1.x,p1.y);
          }else if(dx!==0&&dy===0){
            const r=Math.abs(dx)*s/2; rx=r; ry=r;
            cx=(p0.x+p1.x)/2; cy=p0.y;
            const movingRight = dx>0;
            a0 = movingRight ? Math.PI : 0;
            a1 = movingRight ? 0 : Math.PI;
            semi = true;
          }else if(dx===0&&dy!==0){
            const r=Math.abs(dy)*s/2; rx=r; ry=r;
            cx=p0.x; cy=(p0.y+p1.y)/2;
            const movingDown = dy>0;
            a0 = movingDown ? -Math.PI/2 : Math.PI/2;
            a1 = movingDown ?  Math.PI/2 : -Math.PI/2;
            semi = true;
          }
          if(rx&&ry){
            a0=normAngle(a0); a1=normAngle(a1);
            const acw = semi ? ((ab===0b01)?false:true) : anticlockwiseForShortest(a0,a1);
            ops.push({type:'arc', cx,cy,rx,ry,start:a0,end:a1,acw,color:stroke});
          }
        }

        xi=to.xi; yi=to.yi; visited.push({xi,yi});
      }
      return { ops, visited };
    }

    function renderInstant(ops, visited, skipHeightUpdate = false){
      // Clear canvas before redrawing to avoid visual artifacts
      ctx.clearRect(0, 0, width, height);
      
      // Reset max Y tracking
      
      // Only draw grid points in edit mode and not flipping
      if (editorVisible && !isFlipping) {
        drawGridPoints(s);
      }
      
      // Don't set lineWidth here - let each drawOp set its own thickness
      
      // First pass: draw all outlines
      for(const op of ops){ drawOpOutline(op); }
      
      // Second pass: draw all main strokes on top
      for(const op of ops){ drawOpMain(op); }
      if(visited && visited.length){
        // Show only the ending marker (red) when in edit mode
        if (editorVisible) {
          const endPix=applyItalicsTransform(toCanvas(visited[visited.length-1]));
          ctx.fillStyle='red';ctx.beginPath();ctx.arc(endPix.x,endPix.y,thickness*3,0,Math.PI*2);ctx.fill();
        }
      }
      
    }

    // --- Contenteditable highlighting helpers ---

    const escapeHTML = s => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    function getPlainText(el){ return el.textContent.replace(/\r/g,''); }

    function getCaretOffset(root){
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return 0;
      const range = sel.getRangeAt(0);
      const pre = document.createRange();
      pre.selectNodeContents(root);
      pre.setEnd(range.endContainer, range.endOffset);
      return pre.toString().length;
    }

    function setCaretOffset(root, target){
      target = Math.max(0, target);
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      let node, count = 0;
      while ((node = walker.nextNode())) {
        const next = count + node.nodeValue.length;
        if (target <= next) {
          const sel = getSelection();
          const range = document.createRange();
          range.setStart(node, target - count);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          return;
        }
        count = next;
      }
      const sel = getSelection();
      const r = document.createRange();
      r.selectNodeContents(root);
      r.collapse(false);
      sel.removeAllRanges(); sel.addRange(r);
    }


    // Color palette for hex pairs in current letter
    const HEX_PAIR_COLORS = [
      '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', 
      '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
      '#10ac84', '#ee5a24', '#0984e3', '#6c5ce7', '#a29bfe'
    ];

    // Basic "hex-hit" highlighter with current letter highlighting
    const HEX_CHAR_RE = /[0-9A-Fa-f]/;
    function basicHighlightHTML(raw){
      const currentLetterIndex = getCurrentLetterIndex();
      const esc = escapeHTML(raw);
      
      // Check if input has pipes to determine letter counting strategy
      const hasPipes = raw.includes('|');
      
      
      let letterIndex = 0;
      let hexPairIndex = 0; // Track hex pairs within current letter
      let html = '';
      let i = 0;
      let inComment = false;
      
      while(i < esc.length){
        const ch = esc[i];
        
        // Handle comment detection
        if(ch === '/' && esc[i+1] === '/'){
inComment = true;
          html += '//';
          i += 2;
          continue;
        }
        if(inComment && (ch === '\n' || ch === '\r')){
          inComment = false;
          html += ch;
          i++;
          continue;
        }
        
        if(ch === '|'){
          const next = esc[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter only if pipes are present
            if (hasPipes) {
              letterIndex++;
              hexPairIndex = 0; // Reset hex pair counter for new letter
            }
            html += '||';
            i += 2;
          } else {
            // Letter separator - increment letter index after processing current letter
            html += '|';
            i++;
            if (hasPipes) {
              letterIndex++;
              hexPairIndex = 0; // Reset hex pair counter for new letter
            }
          }
        } else if(HEX_CHAR_RE.test(ch) && HEX_CHAR_RE.test(esc[i+1])){
          // Found a hex pair
          const pair = esc.substr(i, 2);
          const isInputFocused = document.activeElement === inputEl;
          const isCurrentLetter = letterIndex === currentLetterIndex && isInputFocused;
          
          
          // Check if this is an invisible move
          const byte = parseInt(pair, 16);
          const a = (byte >> 7) & 1;
          const xxx = (byte >> 4) & 0b111;
          const bitB = (byte >> 3) & 1;
          const yyy = byte & 0b111;
          const isZero = (xxx === 0 && yyy === 0);
          const ab = (a << 1) | bitB;
          
          // Invisible moves: ab===0b11 (both a and bitB are 1)
          const isInvisibleMove = ab === 0b11;
          
          if(isCurrentLetter && !isInvisibleMove){
            // Make current letter bold (skip invisible moves)
            html += `<strong>${pair}</strong>`;
            hexPairIndex++;
          } else if(isInvisibleMove && !inComment){
            html += `<span class="hex-hit">${pair}</span>`;
          } else {
            html += pair;
          }
          i += 2;
        } else {
          html += ch;
          i++;
        }
      }
      
      return html;
    }

    // ===== HIGHLIGHTING FUNCTIONS =====
    function highlightEditor(){
      // Clear any pending highlight timeout
      if (highlightTimeout) {
        clearTimeout(highlightTimeout);
      }
      
      // Debounce highlighting to prevent loops
      highlightTimeout = setTimeout(() => {
        const raw = getPlainText(inputEl);
        const html = basicHighlightHTML(raw);
        inputEl.innerHTML = html;
        highlightTimeout = null;
      }, 10); // Small delay to break the cycle
    }

    function highlightOutput(){
      const outputText = getPlainText(outputEl);
      if (!outputText.trim()) {
        // No output to highlight
        return;
      }
      
      // Get the current letter index from the input field
      const currentLetterIndex = getCurrentLetterIndex();
      
      // Create highlighting for output using the same letter index logic
      const esc = escapeHTML(outputText);
      
      // Check if output has pipes to determine letter counting strategy
      const hasPipes = outputText.includes('|');
      
      let letterIndex = 0;
      let hexPairIndex = 0; // Track hex pairs within current letter
      let html = '';
      let i = 0;
      let inComment = false;
      
      while(i < esc.length){
        const ch = esc[i];
        
        // Handle comment detection
        if(ch === '/' && esc[i+1] === '/'){
          inComment = true;
          html += '//';
          i += 2;
          continue;
        }
        if(inComment && (ch === '\n' || ch === '\r')){
          inComment = false;
          html += ch;
          i++;
          continue;
        }
        
        if(ch === '|'){
          const next = esc[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter only if pipes are present
            if (hasPipes) {
              letterIndex++;
              hexPairIndex = 0; // Reset hex pair counter for new letter
            }
            html += '||';
            i += 2;
          } else {
            // Letter separator - increment letter index after processing current letter
            html += '|';
            i++;
            if (hasPipes) {
              letterIndex++;
              hexPairIndex = 0; // Reset hex pair counter for new letter
            }
          }
        } else if(HEX_CHAR_RE.test(ch) && HEX_CHAR_RE.test(esc[i+1])){
          // Found a hex pair
          const pair = esc.substr(i, 2);
          const isCurrentLetter = letterIndex === currentLetterIndex;
          
          // Check if this is an invisible move
          const byte = parseInt(pair, 16);
          const a = (byte >> 7) & 1;
          const xxx = (byte >> 4) & 0b111;
          const bitB = (byte >> 3) & 1;
          const yyy = byte & 0b111;
          const isZero = (xxx === 0 && yyy === 0);
          const ab = (a << 1) | bitB;
          
          // Invisible moves: ab===0b11 (both a and bitB are 1)
          const isInvisibleMove = ab === 0b11;
          
          if(isCurrentLetter && !isInvisibleMove){
            // Color each hex pair in current letter differently (skip invisible moves)
            const colorIndex = hexPairIndex % HEX_PAIR_COLORS.length;
            const hexColor = HEX_PAIR_COLORS[colorIndex];
            html += `<strong style="color: ${hexColor};">${pair}</strong>`;
            hexPairIndex++;
          } else if(isInvisibleMove && !inComment){
            html += `<span class="hex-hit">${pair}</span>`;
          } else {
            html += pair;
          }
          i += 2;
        } else {
          html += ch;
          i++;
        }
      }
      
      outputEl.innerHTML = html;
    }

    // ===== EDITOR FUNCTIONS =====
    function getEditorValue(){ 
      // Use Output field for canvas rendering if it has content, otherwise fall back to Input
      const outputText = getPlainText(outputEl);
      if (outputText.trim()) {
        return outputText;
      }
      return getPlainText(inputEl); 
    }

    // Get the current letter index (which space between | characters the cursor is in)
    function getCurrentLetterIndex(){
      const raw = getPlainText(inputEl);
      const caret = getCaretOffset(inputEl);
      
      
      // Check if there are any pipes in the input
      const hasPipes = raw.includes('|');
      
      if (!hasPipes) {
        // If no pipes, treat the entire input as one letter (index 0)
        return 0;
      }
      
      let letterIndex = 0;
      let currentPos = 0;
      
      for(let i = 0; i < raw.length && currentPos < caret; i++){
        const ch = raw[i];
        
        if(ch === '|'){
          const next = raw[i+1];
          if(next === '|'){
            // Newline token - this counts as a new letter
            letterIndex++;
            i++;
            currentPos += 2;
          } else {
            // This is a letter separator
            letterIndex++;
            currentPos++;
          }
        } else {
          currentPos++;
        }
      }
      
      return letterIndex;
    }

    // Insert plain text at the current caret (collapses selection)
    function insertTextAtCaret(root, text) {
      const sel = getSelection();
      if (!sel || sel.rangeCount === 0) return;

      const range = sel.getRangeAt(0);
      range.deleteContents();

      const tn = document.createTextNode(text);
      range.insertNode(tn);

      // move caret after the inserted text node
      range.setStartAfter(tn);
      range.setEndAfter(tn);
      sel.removeAllRanges();
      sel.addRange(range);

      // No highlighting in Input field - just render canvas
      renderNow();
    }

    // --- Lightweight undo/redo history ---
    const HISTORY_LIMIT = 100;
    const history = [];
    const redo = [];
    let snapshotTimer = null;

    // ===== HISTORY FUNCTIONS =====
    function getState() {
      return { text: getEditorValue(), caret: getCaretOffset(inputEl) };
    }

    function applyState(st) {
      inputEl.textContent = st.text;  // plain text
      highlightEditor();
      setCaretOffset(inputEl, st.caret);
      renderNow();
    }

    function pushHistory() {
      const st = getState();
      const prev = history[history.length - 1];
      if (!prev || prev.text !== st.text || prev.caret !== st.caret) {
        history.push(st);
        if (history.length > HISTORY_LIMIT) history.shift();
        redo.length = 0; // clear redo on new branch
      }
    }

    function scheduleSnapshot() {
      clearTimeout(snapshotTimer);
      snapshotTimer = setTimeout(pushHistory, 250); // coalesce rapid edits
    }

    function undo() {
      if (history.length <= 1) return;
      const cur = history.pop();
      redo.push(cur);
      applyState(history[history.length - 1]);
    }

    function redoAction() {
      if (!redo.length) return;
      const st = redo.pop();
      history.push(st);
      applyState(st);
    }

    // ===== EVENT HANDLERS =====
    // Editor toggle button
    editorToggleBtn.addEventListener('click', (e) => {
      preventCardFlip(e);
      
      // Check if we can toggle (same conditions as CMD+E)
      const now = performance.now();
      const isInCooldown = now < animationCooldownEnd;
      const canToggle = document.activeElement !== inputEl && 
                       document.activeElement !== ruleEl && 
                       document.activeElement !== outputEl && 
                       !isFlipping && 
                       !currentAnim && 
                       !isInCooldown;
      
      if (!canToggle) return;
      
      // Trigger the same logic as CMD+E
      editorVisible = !editorVisible;
      
      // Update button icon to reflect new state
      updateEditorToggleIcon();
      
      // Show/hide card indicator based on editor mode
      if (cardIndicator) {
        if (editorVisible) {
          // Hide immediately when entering editor mode
          cardIndicator.style.display = 'none';
        } else {
          // Don't show yet - will be shown when presentation mode is fully loaded
          cardIndicator.style.display = 'none';
        }
      }
      
      // Toggle Pico CSS based on mode
      
      // Handle card flip animation based on mode
      if (!cardElement) {
        cardElement = document.querySelector('.grid > div:first-child');
      }
      
      if (!editorVisible) {
        // Switching to presentation mode
        
        // Start page fade out
        fadeOutPage();
        
        // Step 1: Start first 90° rotation with fade out
        isFlipping = true; // Disable key listeners during flip
        if (cardElement) {
          cardElement.style.animation = 'cardFlipOutOnly 0.4s linear forwards';
        }
        
        // Step 2: Wait for first half to complete, then switch to presentation mode
        setTimeout(async () => {
          
          // Switch to presentation mode
          document.body.classList.toggle('canvas-only', !editorVisible);
          
          // Update SVG first, then canvas background
          const selectedColor = bgColorSelectEl.value;
          await drawSvgBackground();
          updateCanvasBackground(selectedColor);
          updateCardGlow(selectedColor);
          
          // Clear canvas and render the content (ensure editorVisible is properly set)
          setTimeout(() => {
            ctx.clearRect(0, 0, width, height); // Clear any grid points from editor mode
            const coloredItems = parseBytesWithColors(getEditorValue());
            const { ops, visited } = buildOps(coloredItems);
            
            if (animateCheckbox.checked && !editorVisible) {
              startAnim(ops, visited);
            } else {
              renderInstant(ops, visited);
            }
          }, 10); // Small delay to ensure mode change is complete
          
          // Step 3: Wait for rendering to complete, then start second half flip
          setTimeout(() => {
            
            // Show card indicator now that presentation mode is loaded
            if (cardIndicator) {
              cardIndicator.style.display = 'block';
            }
            
            // Start second half: fade in while rotating final 90°
            if (cardElement) {
              cardElement.style.animation = 'cardFlipIn 0.75s linear forwards';
            }
            
            // Step 4: Wait for second half to complete, then finish setup
            setTimeout(() => {
              
              // Final setup
              if (cardElement) {
                cardElement.style.opacity = '1';
                cardElement.style.transform = 'rotateY(0deg)';
                cardElement.style.animation = 'none';
              }
              
              const canvasElement = document.getElementById('board');
              if (canvasElement) {
                canvasElement.style.opacity = '1';
                canvasElement.style.visibility = 'visible';
                canvasElement.style.display = 'block';
              }
              
              fadeInPage();
              
              isFlipping = false; // Re-enable key listeners
            }, 750); // Wait for second half animation
          }, 100); // Small delay to ensure rendering completes
        }, 400); // Wait for first half animation
      } else {
        // Switching to editor mode
        
        // Start page fade out
        fadeOutPage();
        
        // Start flip-out animation (0 to 90 degrees)
        isFlipping = true; // Disable key listeners during flip
        if (cardElement) {
          cardElement.style.animation = 'cardFlipToEditor 0.75s linear forwards';
          
          // Hide SVG background at the halfway point of the flip (when card is at 45 degrees)
          setTimeout(() => {
            if (svgBackground) {
              svgBackground.style.display = 'none';
            }
          }, 375); // Half of 750ms animation
        }
        
        // Wait for flip-out to complete, then switch content
        setTimeout(async () => {
          
          // Clear canvas and switch to editor mode
          ctx.clearRect(0, 0, width, height);
          document.body.classList.toggle('canvas-only', !editorVisible);
          
          // Update SVG first, then canvas background
          const selectedColor = bgColorSelectEl.value;
          await drawSvgBackground();
          updateCanvasBackground(selectedColor);
          updateCardGlow(selectedColor);
          gridFadeStartTime = null;
          gridFadeComplete = false;
          
          // Wait a moment for setup to complete, then fade in
          setTimeout(() => {
            
            // Reset card element to final position (no flip-in needed)
            if (cardElement) {
              cardElement.style.opacity = '1';
              cardElement.style.transform = 'rotateY(0deg)';
              cardElement.style.animation = 'none'; // No flip-in animation
            }
            
            const canvasElement = document.getElementById('board');
            if (canvasElement) {
              canvasElement.style.opacity = '1';
              canvasElement.style.visibility = 'visible';
              canvasElement.style.display = 'block';
            }
            
            fadeInPage();
            isFlipping = false;
            
            // Render grid immediately after flipping is complete
            renderNow();
          }, 100);
        }, 750);
      }
    });
    
    // Let browser handle Enter naturally - no interception needed

    // Keydown fallback for Enter
    inputEl.addEventListener('keydown', (e) => {
      const mod = e.metaKey || e.ctrlKey;

      // Redo (Cmd+Shift+Z or Ctrl+Y)
      if (mod && ((e.key.toLowerCase() === 'z' && e.shiftKey) || e.key.toLowerCase() === 'y')) {
        e.preventDefault();
        redoAction();
        return;
      }

      // Undo (Cmd/Ctrl+Z without Shift)
      if (mod && e.key.toLowerCase() === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
        return;
      }

      // Enter handling is done by beforeinput event handler
    });

    // Sanitize paste to plain text
    inputEl.addEventListener('paste', (e) => {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text');
      insertTextAtCaret(inputEl, text);
      // insertTextAtCaret already handles highlighting and cursor position
      // But we need to trigger text replacement processing for Output field
      debouncedProcessTextReplacement();
      scheduleSnapshot();
    });

    // ===== UI FUNCTIONS =====
    function updateEditorToggleIcon() {
      if (editorVisible) {
        editorToggleBtn.innerHTML = '✕';
        editorToggleBtn.style.color = 'red';
      } else {
        editorToggleBtn.innerHTML = '✏️';
        editorToggleBtn.style.color = '';
      }
    }

    // ===== CARD PRELOADING FUNCTIONS =====
    
    // Calculate which block a card index belongs to (backward compatibility)
    async function getBlockForCard(cardIndex) {
      const setInfo = await getSetForCard(cardIndex);
      return setInfo.start;
    }
    
    // Get the range of cards in a block (backward compatibility)
    async function getBlockRange(blockStart) {
      return await getSetForCard(blockStart);
    }
    
    // Detect set boundaries for a given card index
    async function getSetForCard(cardIndex) {
      // Check cache first
      if (setBoundaries.has(cardIndex)) {
        return setBoundaries.get(cardIndex);
      }
      
      let setStart = cardIndex;
      let setEnd = cardIndex;
      
      // Check if current card itself starts a new set
      const currentCardData = await getCardData(cardIndex);
      if (currentCardData && currentCardData.options && currentCardData.options.order === 1) {
        // Current card starts a new set
        setStart = cardIndex;
        // For a set starter, find the end by looking forward
        for (let i = cardIndex + 1; i <= maxCardIndex; i++) {
          const cardData = await getCardData(i);
          if (cardData && cardData.options && cardData.options.order === 1) {
            setEnd = i - 1; // Previous card is the end of this set
            break;
          }
          // If we've gone forward too far (more than MAX_CARDS_PER_SET), assume this is the end
          if (i - setStart >= MAX_CARDS_PER_SET) {
            setEnd = i - 1;
            break;
          }
        }
        // If no end found, use the last available card
        if (setEnd === cardIndex) {
          setEnd = Math.min(maxCardIndex, cardIndex + MAX_CARDS_PER_SET - 1);
        }
      } else {
        // Look backward to find set start (card with order: 1)
        for (let i = cardIndex - 1; i >= 1; i--) {
          const cardData = await getCardData(i);
          if (cardData && cardData.options && cardData.options.order === 1) {
            setStart = i;
            break;
          }
          // If we've gone back too far (more than MAX_CARDS_PER_SET), assume this is the start
          if (cardIndex - i >= MAX_CARDS_PER_SET) {
            setStart = i + 1;
            break;
          }
        }
      }
      
      // Look forward to find set end (next card with order: 1 or end of cards)
      for (let i = cardIndex + 1; i <= maxCardIndex; i++) {
        const cardData = await getCardData(i);
        if (cardData && cardData.options && cardData.options.order === 1) {
          setEnd = i - 1; // Previous card is the end of this set
          break;
        }
        // If we've gone forward too far (more than MAX_CARDS_PER_SET), assume this is the end
        if (i - setStart >= MAX_CARDS_PER_SET) {
          setEnd = i - 1;
          break;
        }
      }
      
      // If no explicit boundaries found, use intelligent grouping
      if (setStart === cardIndex && setEnd === cardIndex) {
        const result = await detectIntelligentSetBoundaries(cardIndex);
        setStart = result.start;
        setEnd = result.end;
      }
      
      const setInfo = {
        start: setStart,
        end: setEnd,
        size: setEnd - setStart + 1
      };
      
      // Cache the result for all cards in this set
      for (let i = setStart; i <= setEnd; i++) {
        setBoundaries.set(i, setInfo);
      }
      
      return setInfo;
    }
    
    // Helper function to get card data (from cache or fetch)
    async function getCardData(cardIndex) {
      if (cardIndex === undefined || cardIndex === null) {
        return null;
      }
      
      let cardData = cardCache.get(cardIndex);
      if (!cardData) {
        const cacheBuster = `?t=${Date.now()}`;
        const response = await fetch(`${CARD_BASE_URL}${cardIndex}.json${cacheBuster}`);
        if (response.ok) {
          cardData = await response.json();
          cardCache.set(cardIndex, cardData);
        }
      }
      return cardData;
    }
    
    // Detect set boundaries intelligently based on card positions and order numbers
    async function detectIntelligentSetBoundaries(cardIndex) {
      if (cardIndex === undefined || cardIndex === null) {
        return { start: 1, end: 1 };
      }
      
      let setStart = cardIndex;
      let setEnd = cardIndex;
      
      // Look for cards with similar position patterns or order numbers
      const currentCardData = await getCardData(cardIndex);
      const currentPosition = currentCardData?.options?.position;
      const currentOrder = currentCardData?.options?.order;
      
      // Look backward
      for (let i = cardIndex - 1; i >= 1; i--) {
        const cardData = await getCardData(i);
        if (!cardData) break;
        
        const cardPosition = cardData.options?.position;
        const cardOrder = cardData.options?.order;
        
        // If this card has a much higher order number, it might be from a different set
        if (currentOrder && cardOrder && cardOrder > currentOrder + 5) {
          setStart = i + 1;
          break;
        }
        
        // If we've gone back too far, stop
        if (cardIndex - i >= MAX_CARDS_PER_SET) {
          setStart = i + 1;
          break;
        }
      }
      
      // Look forward
      for (let i = cardIndex + 1; i <= maxCardIndex; i++) {
        const cardData = await getCardData(i);
        if (!cardData) break;
        
        const cardOrder = cardData.options?.order;
        
        // If this card has a much lower order number, it might be from a different set
        if (currentOrder && cardOrder && cardOrder < currentOrder - 5) {
          setEnd = i - 1;
          break;
        }
        
        // If we've gone forward too far, stop
        if (i - setStart >= MAX_CARDS_PER_SET) {
          setEnd = i - 1;
          break;
        }
      }
      
      return { start: setStart, end: setEnd };
    }
    
    // Preload a block of cards (JSONs and SVGs)
    async function preloadCardBlock(blockStart) {
      if (preloadingInProgress) return;
      preloadingInProgress = true;
      
      const range = await getBlockRange(blockStart);
      
      const promises = [];
      
      // Preload JSON data for all cards in the block
      for (let i = range.start; i <= range.end; i++) {
        if (!cardCache.has(i)) {
          const cacheBuster = `?t=${Date.now()}`;
          const promise = fetch(`${CARD_BASE_URL}${i}.json${cacheBuster}`)
            .then(response => {
              if (response.ok) {
                return response.json().then(data => {
                  cardCache.set(i, data);
                  return { index: i, success: true, data };
                });
              } else {
                return { index: i, success: false };
              }
            })
            .catch(() => ({ index: i, success: false }));
          promises.push(promise);
        }
      }
      
      // Wait for all JSON requests to complete
      const results = await Promise.all(promises);
      
      // Now preload SVGs for cards that have SVG backgrounds
      const svgPromises = [];
      for (const result of results) {
        if (result.success && result.data && result.data.options && result.data.options.svgBackground) {
          const svgUrl = result.data.options.svgBackground;
          if (svgUrl.startsWith('http://') || svgUrl.startsWith('https://')) {
            if (!svgCache.has(svgUrl)) {
              const svgPromise = fetch(svgUrl)
                .then(response => {
                  if (response.ok) {
                    return response.text().then(content => {
                      svgCache.set(svgUrl, content);
                      return { url: svgUrl, success: true };
                    });
                  } else {
                    return { url: svgUrl, success: false };
                  }
                })
                .catch(() => ({ url: svgUrl, success: false }));
              svgPromises.push(svgPromise);
            }
          }
        }
      }
      
      // Wait for all SVG requests to complete
      if (svgPromises.length > 0) {
        await Promise.all(svgPromises);
      }
      
      preloadingInProgress = false;
    }
    
    // Check if we need to preload a new block and do so
    async function ensureBlockPreloaded(cardIndex) {
      const requiredBlock = await getBlockForCard(cardIndex);
      
      if (requiredBlock !== currentBlockStart) {
        currentBlockStart = requiredBlock;
        
        // Preload the new block in the background
        preloadCardBlock(requiredBlock).catch(error => {
          console.error('Failed to preload card block:', error);
        });
      }
    }

    // ===== CARD BLOCK OVERVIEW FUNCTIONS =====
    
    // Show the current block of cards in zoomed out mode
    // Setup drag and drop functionality for the card grid
    function setupDragAndDrop(gridContainer, blockStart, range) {
      let draggedElement = null;
      let dragStarted = false;
      
      // Add drag start event to all cards
      gridContainer.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('card-wrapper')) {
          draggedElement = e.target;
          dragStarted = true;
          e.target.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/html', e.target.outerHTML);
        }
      });
      
      // Add drag end event
      gridContainer.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('card-wrapper')) {
          e.target.classList.remove('dragging');
          // Remove any drag-over classes from all cards
          const allCards = gridContainer.querySelectorAll('.card-wrapper');
          allCards.forEach(card => card.classList.remove('drag-over'));
          
          // Set global drag tracking variables
          window.lastDragEnd = Date.now();
          window.dragStarted = dragStarted;
          
          // Reset drag state after a short delay to allow drop event to complete
          setTimeout(() => {
            draggedElement = null;
            dragStarted = false;
            window.dragStarted = false;
          }, 100);
        }
      });
      
      // Add dragover event to allow dropping
      gridContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });
      
      // Add drop event to handle card swapping
      gridContainer.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggedElement) {
          return;
        }
        
        // Find the target element (either card wrapper or empty placeholder)
        let targetElement = e.target;
        while (targetElement && !targetElement.classList.contains('card-wrapper') && !targetElement.classList.contains('empty-placeholder')) {
          targetElement = targetElement.parentElement;
        }
        
        if (!targetElement || (!targetElement.classList.contains('card-wrapper') && !targetElement.classList.contains('empty-placeholder'))) {
          return;
        }
        
        // Don't allow dropping on the same element
        if (draggedElement === targetElement) {
          return;
        }
        
        // Get current positions
        const draggedCardIndex = parseInt(draggedElement.getAttribute('data-card-index'));
        
        // Get current grid positions
        const draggedRow = parseInt(draggedElement.style.gridRow);
        const draggedCol = parseInt(draggedElement.style.gridColumn);
        
        if (targetElement.classList.contains('card-wrapper')) {
          // Card-to-card swap
          const targetCardIndex = parseInt(targetElement.getAttribute('data-card-index'));
          const targetRow = parseInt(targetElement.style.gridRow);
          const targetCol = parseInt(targetElement.style.gridColumn);
          
          // Swap the grid positions
          draggedElement.style.gridRow = targetRow.toString();
          draggedElement.style.gridColumn = targetCol.toString();
          targetElement.style.gridRow = draggedRow.toString();
          targetElement.style.gridColumn = draggedCol.toString();
          
          // Update the data attributes
          draggedElement.setAttribute('data-original-position', `${targetRow}-${targetCol}`);
          targetElement.setAttribute('data-original-position', `${draggedRow}-${draggedCol}`);
          
          // Update the visual feedback
          draggedElement.classList.remove('selected');
          targetElement.classList.add('selected');
          
        } else if (targetElement.classList.contains('empty-placeholder')) {
          // Card-to-empty-placeholder drop
          const targetRow = parseInt(targetElement.getAttribute('data-row'));
          const targetCol = parseInt(targetElement.getAttribute('data-col'));
          
          // Move the card to the empty position
          draggedElement.style.gridRow = targetRow.toString();
          draggedElement.style.gridColumn = targetCol.toString();
          draggedElement.setAttribute('data-original-position', `${targetRow}-${targetCol}`);
          
          // Remove the empty placeholder
          targetElement.remove();
          
          // Create a new empty placeholder at the old position
          const newEmptyPlaceholder = document.createElement('div');
          newEmptyPlaceholder.className = 'empty-placeholder';
          newEmptyPlaceholder.style.cssText = `
            width: 600px;
            height: 971px;
            border: 2px dashed #999;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 24px;
            font-weight: bold;
          `;
          // No text content - just an empty placeholder
          newEmptyPlaceholder.setAttribute('data-row', draggedRow);
          newEmptyPlaceholder.setAttribute('data-col', draggedCol);
          newEmptyPlaceholder.setAttribute('data-empty', 'true');
          newEmptyPlaceholder.style.gridColumn = draggedCol.toString();
          newEmptyPlaceholder.style.gridRow = draggedRow.toString();
          
          // Add hover effect for the new empty placeholder
          newEmptyPlaceholder.addEventListener('mouseenter', () => {
            newEmptyPlaceholder.style.borderColor = '#4CAF50';
            newEmptyPlaceholder.style.background = 'rgba(76, 175, 80, 0.1)';
            newEmptyPlaceholder.style.color = '#4CAF50';
          });
          
          newEmptyPlaceholder.addEventListener('mouseleave', () => {
            newEmptyPlaceholder.style.borderColor = '#999';
            newEmptyPlaceholder.style.background = 'rgba(255, 255, 255, 0.1)';
            newEmptyPlaceholder.style.color = '#999';
          });
          
          gridContainer.appendChild(newEmptyPlaceholder);
          
        }
        
        // Save the new positions to card JSON files
        await saveCardPositions(gridContainer, blockStart);
      });
      
      // Add drag enter/leave events for visual feedback
      gridContainer.addEventListener('dragenter', (e) => {
        // Find the target element (card wrapper or empty placeholder)
        let targetElement = e.target;
        while (targetElement && !targetElement.classList.contains('card-wrapper') && !targetElement.classList.contains('empty-placeholder')) {
          targetElement = targetElement.parentElement;
        }
        
        if (targetElement && (targetElement.classList.contains('card-wrapper') || targetElement.classList.contains('empty-placeholder')) && targetElement !== draggedElement) {
          if (targetElement.classList.contains('empty-placeholder')) {
            // Special styling for empty placeholders
            targetElement.style.borderColor = '#4CAF50';
            targetElement.style.background = 'rgba(76, 175, 80, 0.2)';
            targetElement.style.color = '#4CAF50';
          } else {
            targetElement.classList.add('drag-over');
          }
        }
      });
      
      gridContainer.addEventListener('dragleave', (e) => {
        // Find the target element (card wrapper or empty placeholder)
        let targetElement = e.target;
        while (targetElement && !targetElement.classList.contains('card-wrapper') && !targetElement.classList.contains('empty-placeholder')) {
          targetElement = targetElement.parentElement;
        }
        
        if (targetElement) {
          if (targetElement.classList.contains('empty-placeholder')) {
            // Reset empty placeholder styling
            targetElement.style.borderColor = '#999';
            targetElement.style.background = 'rgba(255, 255, 255, 0.1)';
            targetElement.style.color = '#999';
          } else if (targetElement.classList.contains('card-wrapper')) {
            targetElement.classList.remove('drag-over');
          }
        }
      });
    }
    
    // Save card positions to card JSON files in Supabase storage
    async function saveCardPositions(gridContainer, blockStart) {
      try {
        const positions = [];
        const allElements = gridContainer.children;
        
        // Collect all card positions
        for (let i = 0; i < allElements.length; i++) {
          const element = allElements[i];
          
          if (element.classList.contains('card-wrapper')) {
            const cardIndex = parseInt(element.getAttribute('data-card-index'));
            const row = parseInt(element.style.gridRow);
            const col = parseInt(element.style.gridColumn);
            
            positions.push({ row, col, cardIndex });
          }
        }
        
        // Update each card's JSON file with its new position
        for (const position of positions) {
          await updateCardPosition(position.cardIndex, position.row, position.col);
        }
        
      } catch (error) {
        console.error('Error saving card positions:', error);
        alert(`Failed to save card positions: ${error.message}`);
      }
    }
    
    // Update a single card's position in its JSON file
    async function updateCardPosition(cardIndex, row, col) {
      try {
        // Get current card data
        const cacheBuster = `?t=${Date.now()}`;
        const response = await fetch(`${CARD_BASE_URL}${cardIndex}.json${cacheBuster}`);
        
        if (!response.ok) {
          console.warn(`Card ${cardIndex} not found, skipping position update`);
          return;
        }
        
        const cardData = await response.json();
        
        // Add or update position field
        if (!cardData.options) {
          cardData.options = {};
        }
        cardData.options.position = { row, col };
        
        // Create JSON string
        const jsonString = JSON.stringify(cardData, null, 2);
        
        // Create blob for upload
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // Upload to Supabase storage
        const fileName = `${cardIndex}.json`;
        
        const { data, error } = await supabaseClient.storage
          .from('card')
          .upload(fileName, blob, {
            contentType: 'application/json',
            upsert: true // Overwrite if file exists
          });

        if (error) {
          console.error(`Upload error for card ${cardIndex}:`, error);
          throw error;
        }
        
        // Update cache with new position data
        cardCache.set(cardIndex, cardData);
        
      } catch (error) {
        console.error(`Failed to update position for card ${cardIndex}:`, error);
        throw error;
      }
    }

    // Load card positions from card JSON files
    async function loadCardPositions(range) {
      const cardsWithPositions = [];
      const cardsWithoutPositions = [];
      
      for (let i = range.start; i <= range.end; i++) {
        try {
          // Get card data from cache or load it
          let cardData = cardCache.get(i);
          if (!cardData) {
            const cacheBuster = `?t=${Date.now()}`;
            const response = await fetch(`${CARD_BASE_URL}${i}.json${cacheBuster}`);
            if (response.ok) {
              cardData = await response.json();
              cardCache.set(i, cardData);
            }
          }
          
          // Check if card has a saved position
          if (cardData && cardData.options && cardData.options.position) {
            const position = cardData.options.position;
            cardsWithPositions.push({ 
              row: position.row, 
              col: position.col, 
              cardIndex: i 
            });
          } else {
            // Card doesn't have a saved position - will be placed in empty spaces
            cardsWithoutPositions.push({ cardIndex: i });
          }
        } catch (error) {
          console.warn(`Failed to load position for card ${i}, will place in empty space:`, error);
          // Card without position - will be placed in empty spaces
          cardsWithoutPositions.push({ cardIndex: i });
        }
      }
      
      return { cardsWithPositions, cardsWithoutPositions };
    }

    // Add empty placeholders for unused grid positions
    function addEmptyPlaceholders(gridContainer, cardsWithPositions) {
      // Create a set of occupied positions
      const occupiedPositions = new Set();
      cardsWithPositions.forEach(pos => {
        occupiedPositions.add(`${pos.row}-${pos.col}`);
      });
      
      // Add empty placeholders for all 15 positions (3x5 grid)
      for (let row = 1; row <= 5; row++) {
        for (let col = 1; col <= 3; col++) {
          const positionKey = `${row}-${col}`;
          
          if (!occupiedPositions.has(positionKey)) {
            // Create empty placeholder for this position
            const emptyPlaceholder = document.createElement('div');
            emptyPlaceholder.className = 'empty-placeholder';
            emptyPlaceholder.style.cssText = `
              width: 600px;
              height: 971px;
              border: 2px dashed #999;
              border-radius: 8px;
              background: rgba(255, 255, 255, 0.1);
              cursor: pointer;
              transition: all 0.2s ease;
              display: flex;
              align-items: center;
              justify-content: center;
              color: #999;
              font-size: 24px;
              font-weight: bold;
            `;
            // No text content - just an empty placeholder
            emptyPlaceholder.setAttribute('data-row', row);
            emptyPlaceholder.setAttribute('data-col', col);
            emptyPlaceholder.setAttribute('data-empty', 'true');
            emptyPlaceholder.style.gridColumn = col.toString();
            emptyPlaceholder.style.gridRow = row.toString();
            
            // Add hover effect for empty placeholders
            emptyPlaceholder.addEventListener('mouseenter', () => {
              emptyPlaceholder.style.borderColor = '#4CAF50';
              emptyPlaceholder.style.background = 'rgba(76, 175, 80, 0.1)';
              emptyPlaceholder.style.color = '#4CAF50';
            });
            
            emptyPlaceholder.addEventListener('mouseleave', () => {
              emptyPlaceholder.style.borderColor = '#999';
              emptyPlaceholder.style.background = 'rgba(255, 255, 255, 0.1)';
              emptyPlaceholder.style.color = '#999';
            });
            
            gridContainer.appendChild(emptyPlaceholder);
          }
        }
      }
    }

    async function showCardBlockOverview() {
      // Get the current block range
      const blockStart = await getBlockForCard(currentCardIndex);
      const range = await getBlockRange(blockStart);
      
      // Check if range is valid
      if (!range || range.start === undefined || range.end === undefined) {
        return;
      }
      
      // Find the main card container
      const mainCardContainer = document.querySelector('.canvas-only .grid > div:first-child');
      if (!mainCardContainer) {
        return;
      }
      
      // Create the grid container for all cards
      const gridContainer = document.createElement('div');
      gridContainer.className = 'grid-container';
      gridContainer.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: auto auto auto auto auto;
        gap: 40px;
        width: 100%;
        height: 100%;
        align-items: center;
        justify-items: center;
        overflow: auto;
        padding: 40px;
      `;
      
      // Create card elements for each card in the block
      for (let i = range.start; i <= range.end; i++) {
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'card-wrapper';
        cardWrapper.style.cssText = `
          width: 600px;
          height: 971px;
          border: 2px solid #666;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        `;
        
        // Highlight the current card (will be overridden by individual glow if card has background color)
        if (i === currentCardIndex) {
          // Don't set a bright border here - keep the normal gray border
          cardWrapper.classList.add('selected');
        }
        
        // Create canvas for the card
        const cardCanvas = document.createElement('canvas');
        cardCanvas.width = 600;
        cardCanvas.height = 971;
        cardCanvas.style.cssText = `
          width: 100%;
          height: 100%;
          display: block;
        `;
        
        
        // Create SVG background container
        const svgContainer = document.createElement('div');
        svgContainer.className = `svg-container svg-card-${i}`;
        svgContainer.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: 0;
          pointer-events: none;
        `;
        
        cardWrapper.appendChild(svgContainer);
        cardWrapper.appendChild(cardCanvas);
        
        // Load and render the card content
        try {
          // Get card data from cache or load it
          let cardData = cardCache.get(i);
          if (!cardData) {
            const cacheBuster = `?t=${Date.now()}`;
            const response = await fetch(`${CARD_BASE_URL}${i}.json${cacheBuster}`);
            if (response.ok) {
              cardData = await response.json();
              cardCache.set(i, cardData);
            }
          }
          
          // Set card background gradient (will be overridden if SVG is present)
          const cardColor = getCardColor(cardData);
          cardCanvas.style.background = generateGradientFromColor(cardColor);
          
          // Also set the wrapper background initially
          cardWrapper.style.background = generateGradientFromColor(cardColor);
          
          if (cardData) {
            // Set background color
            if (cardData.options && cardData.options.backgroundColor) {
              cardCanvas.style.background = generateLightGradientFromColor(cardData.options.backgroundColor);
              
              // Add individual glow to each card
              const rgb = hexToRgb(cardData.options.backgroundColor);
              const glow1 = `rgba(${Math.min(255, rgb.r + 100)}, ${Math.min(255, rgb.g + 100)}, ${Math.min(255, rgb.b + 100)}, 0.4)`;
              const glow2 = `rgba(${Math.min(255, rgb.r + 80)}, ${Math.min(255, rgb.g + 80)}, ${Math.min(255, rgb.b + 80)}, 0.3)`;
              const glow3 = `rgba(${Math.min(255, rgb.r + 60)}, ${Math.min(255, rgb.g + 60)}, ${Math.min(255, rgb.b + 60)}, 0.2)`;
              
              // Override current card highlight with individual glow
              if (i === currentCardIndex) {
                // Create bright version of card color for border
                const brightColor = `rgba(${Math.min(255, Math.round(rgb.r * 1.8))}, ${Math.min(255, Math.round(rgb.g * 1.8))}, ${Math.min(255, Math.round(rgb.b * 1.8))}, 1)`;
                cardWrapper.style.border = `3px solid ${brightColor}`;
                
                cardWrapper.style.boxShadow = `
                  0 0 20px ${glow1},
                  0 0 40px ${glow2},
                  0 0 60px ${glow3},
                  0 0 10px rgba(255, 255, 255, 0.8)
                `;
              } else {
                cardWrapper.style.boxShadow = `
                  0 0 20px ${glow1},
                  0 0 40px ${glow2},
                  0 0 60px ${glow3}
                `;
              }
            }
            
            // Load SVG background
            if (cardData.options && cardData.options.svgBackground) {
              const svgValue = cardData.options.svgBackground;
              let svgContent = null; // Initialize svgContent outside the if block
              
              if (svgValue.startsWith('http://') || svgValue.startsWith('https://')) {
                // Check cache first
                svgContent = svgCache.get(svgValue);
                if (!svgContent) {
                  try {
                    const response = await fetch(svgValue);
                    svgContent = await response.text();
                    svgCache.set(svgValue, svgContent);
                  } catch (error) {
                    console.error('Failed to fetch SVG:', error);
                  }
                }
              }
              
              // Process SVG content (either fetched or direct)
              try {
                const svgContentToUse = svgContent || svgValue;
                if (svgContentToUse) {
                  // Strip SVG colors and calculate text color
                  const cardColor = getCardColor(cardData);
                  const textColor = calculateSvgTextColor(cardColor, false); // Always presentation mode in zoomed-out
                  const useNaturalColors = cardData.options && cardData.options.svgColor === true;
                  const cleanedSvgContent = stripSvgColors(svgContentToUse, useNaturalColors);
                  
                  svgContainer.innerHTML = `
                    <style>
                      .svg-card-${i} svg {
                        width: 100%;
                        height: 100%;
                        display: block;
                        object-fit: contain;
                        object-position: center;
                        opacity: 0.5;
                        ${!useNaturalColors ? `color: ${textColor};` : ''}
                      }
                      ${!useNaturalColors ? `.svg-card-${i} svg * { fill: currentColor; stroke: currentColor; }` : ''}
                    </style>
                    ${cleanedSvgContent}
                  `;
                  
                  // Make canvas transparent and apply gradient to wrapper when SVG is present
                  cardCanvas.style.background = 'transparent';
                  cardWrapper.style.background = generateGradientFromColor(getCardColor(cardData));
                }
              } catch (svgError) {
                console.error(`Card ${i}: SVG processing error:`, svgError);
              }
            }
            
            // Render card content on canvas
            if (cardData.input) {
              const ctx = cardCanvas.getContext('2d');
              // No scaling needed - canvas is already 600x1000
              
              // Set up canvas context
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              
              // Parse and render the card content
              const coloredItems = parseBytesWithColors(cardData.input);
              const { ops, visited } = buildOps(coloredItems);
              
              // Clear canvas
              ctx.clearRect(0, 0, 600, 1000);
              
              // Render the operations
              for (const op of ops) {
                drawOpUnified(op, 1, 'both');
              }
            }
          }
        } catch (error) {
          console.error(`Failed to load card ${i}:`, error);
          // Show card number as fallback - keep the background that was already set
          const ctx = cardCanvas.getContext('2d');
          ctx.fillStyle = 'white';
          ctx.font = '120px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(i.toString(), 300, 500);
        }
        
        // Add click handler to jump to card
        cardWrapper.addEventListener('click', async (e) => {
          preventCardFlip(e);
          
          // Check if this click is from a drag operation
          if (cardWrapper.classList.contains('dragging') || 
              (window.dragStarted && Date.now() - window.lastDragEnd < 200)) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          
          // Zoom back in regardless of which card was clicked
            document.body.style.zoom = '0.75';
            setButtonState('normal');
          
          hideCardBlockOverview();
          
          // Wait for canvas to be ready and force a reflow
          await delay(100);
          
          // Force a reflow to ensure DOM is ready
          document.getElementById('board').offsetHeight;
          
          // Always load the card (whether it's different or the same)
          // This ensures card data is properly loaded when returning from zoomed-out view
          if (i !== currentCardIndex) {
            currentCardIndex = i;
            updateCardFileName();
          }
          
          // Load the card and ensure proper rendering
          await loadCard(currentCardIndex);
          
          // Add fade-in animation
          applyCardFadeIn();
        });
        
        // Add hover effect
        cardWrapper.addEventListener('mouseenter', () => {
          if (i !== currentCardIndex) {
            cardWrapper.style.transform = 'scale(1.05)';
            cardWrapper.style.borderColor = '#999';
          }
        });
        
        cardWrapper.addEventListener('mouseleave', () => {
          if (i !== currentCardIndex) {
            cardWrapper.style.transform = 'scale(1)';
            cardWrapper.style.borderColor = '#666';
          }
        });
        
        gridContainer.appendChild(cardWrapper);
      }
      
      // Apply the grid layout: 3x5 grid with saved positions
      const cards = gridContainer.children;
      
      // Load saved card positions from card JSON files
      const { cardsWithPositions, cardsWithoutPositions } = await loadCardPositions(range);
      
      // Phase 1: Place cards that have saved positions
      for (let i = 0; i < cards.length; i++) {
        const cardIndex = range.start + i;
        const savedPosition = cardsWithPositions.find(pos => pos.cardIndex === cardIndex);
        
        if (savedPosition) {
          cards[i].style.gridColumn = savedPosition.col.toString();
          cards[i].style.gridRow = savedPosition.row.toString();
          cards[i].setAttribute('data-original-position', `${savedPosition.row}-${savedPosition.col}`);
        }
        
        // Add drag and drop attributes
        cards[i].draggable = true;
        cards[i].setAttribute('data-card-index', cardIndex);
      }
      
      // Phase 2: Place cards without saved positions in empty spaces
      const occupiedPositions = new Set();
      cardsWithPositions.forEach(pos => {
        occupiedPositions.add(`${pos.row}-${pos.col}`);
      });
      
      const availablePositions = [];
      for (let row = 1; row <= 5; row++) {
        for (let col = 1; col <= 3; col++) {
          const positionKey = `${row}-${col}`;
          if (!occupiedPositions.has(positionKey)) {
            availablePositions.push({ row, col });
          }
        }
      }
      
      // Place cards without positions in available spaces
      for (let i = 0; i < cards.length; i++) {
        const cardIndex = range.start + i;
        const cardWithoutPosition = cardsWithoutPositions.find(card => card.cardIndex === cardIndex);
        
        if (cardWithoutPosition) {
          const availablePosition = availablePositions.shift();
          if (availablePosition) {
            cards[i].style.gridColumn = availablePosition.col.toString();
            cards[i].style.gridRow = availablePosition.row.toString();
            cards[i].setAttribute('data-original-position', `${availablePosition.row}-${availablePosition.col}`);
          }
        }
      }
      
      // Add empty placeholders for remaining positions
      addEmptyPlaceholders(gridContainer, cardsWithPositions);
      
      // Add drag and drop event handlers
      setupDragAndDrop(gridContainer, blockStart, range);
      
      // Replace the main card with the grid
      mainCardContainer.innerHTML = '';
      mainCardContainer.appendChild(gridContainer);
    }
    
    // Hide the card block overview
    function hideCardBlockOverview() {
      // Restore the main card
      const mainCardContainer = document.querySelector('.canvas-only .grid > div:first-child');
      if (mainCardContainer) {
        // Clear the grid and restore the original canvas
        mainCardContainer.innerHTML = `
          <div id="canvasWrapper" style="position: relative; overflow: hidden; border-radius: 16px;">
            <canvas id="board" width="600" height="971" aria-label="drawing canvas" style="position: relative; z-index: 1;"></canvas>
          </div>
        `;
        
        // Re-initialize the canvas
        const canvas = document.getElementById('board');
        // Update the global ctx variable
        ctx = canvas.getContext('2d', { alpha: true });
        const dpr = window.devicePixelRatio || 1;
        if (dpr !== 1) {
          canvas.width = 600 * dpr;
          canvas.height = 971 * dpr;
          canvas.style.width = '600px';
          canvas.style.height = '971px';
          ctx.scale(dpr, dpr);
        }
        
        // Set up canvas context
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.textRenderingOptimization = 'optimizeQuality';
        
        // Re-initialize SVG background reference
        svgBackground = document.getElementById('svgBackground');
        
        // Re-initialize canvasWrapper reference
        canvasWrapper = document.getElementById('canvasWrapper');
      }
    }

    // ===== TEXT REPLACEMENT SYSTEM =====
    
    class TextReplacer {
      static init(replacementRules) {
        if (!replacementRules || !replacementRules.trim()) {
          return { sections: { 'MAIN': { index: 0, firstLine: -1 } }, rules: [] };
        }
        
        const lines = replacementRules.split('\n').filter(line => line.trim());
        const sections = { 'MAIN': { index: 0, firstLine: -1 } };
        const rules = [];
        
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Check for section headers
          if (line.startsWith('====SECTION')) {
            const sectionName = line.split(' ')[1];
            sections[sectionName] = { index: Object.keys(sections).length, firstLine: i };
          } else {
            // Parse replacement pairs (format: "find,replace" or "find replace")
            const pairs = line.split(/\s+/).map(pair => {
              if (pair.includes(',')) {
                const [find, replace] = pair.split(',');
                return [find, replace];
              } else {
                // If no comma, treat as single word replacement (replace with empty)
                return [pair, ''];
              }
            });
            rules.push(pairs);
          }
        }
        
        return { sections, rules };
      }
      
      static run(text, replacementData) {
        if (!replacementData || !replacementData.rules) return text;
        
        let result = text;
        
        // Process rules from the MAIN section
        const mainSection = replacementData.sections['MAIN'];
        if (!mainSection) return text;
        
        // Start from the line after the section header
        const startLine = mainSection.firstLine + 1;
        
        for (let i = startLine; i < replacementData.rules.length; i++) {
          const ruleLine = replacementData.rules[i];
          
          // Check for special RUN commands
          if (ruleLine.length === 1 && ruleLine[0][0].includes('====RUN')) {
            const runParts = ruleLine[0][0].split('-');
            const repetitions = runParts.length > 1 ? parseInt(runParts[1]) || 1 : 1;
            const sectionName = ruleLine[0][1];
            
            // Find the next section
            const currentSection = replacementData.sections[sectionName];
            if (currentSection) {
              const nextSectionIndex = currentSection.index + 1;
              const nextSectionName = Object.keys(replacementData.sections)
                .find(name => replacementData.sections[name].index === nextSectionIndex);
              
              if (nextSectionName) {
                const nextSection = replacementData.sections[nextSectionName];
                const endLine = nextSection.firstLine;
                
                // Apply the section rules multiple times
                for (let rep = 0; rep < repetitions; rep++) {
                  for (let lineIdx = currentSection.firstLine + 1; lineIdx < endLine; lineIdx++) {
                    const pairs = replacementData.rules[lineIdx];
                    for (const [find, replace] of pairs) {
                      result = result.replace(new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replace);
                    }
                  }
                }
              }
            }
          } else {
            // Apply regular replacement rules
            for (const [find, replace] of ruleLine) {
              result = result.replace(new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), replace);
            }
          }
        }
        
        return result;
      }
    }
    
    // Process text replacement and update Output field
    function processTextReplacement() {
      const ruleText = getPlainText(ruleEl);
      const inputText = getPlainText(inputEl);
      
      if (!ruleText.trim()) {
        // No rules, just copy input to output
        outputEl.textContent = inputText;
        highlightOutput();
        return;
      }
      
      try {
        const replacementData = TextReplacer.init(ruleText);
        const processedText = TextReplacer.run(inputText, replacementData);
        outputEl.textContent = processedText;
      } catch (error) {
        console.error('Text replacement error:', error);
        outputEl.textContent = inputText; // Fallback to original input
      }
      
      // Highlight the output after text replacement
      highlightOutput();
    }
    
    // Debounced version of processTextReplacement
    let replacementTimer = null;
    function debouncedProcessTextReplacement() {
      if (replacementTimer) {
        clearTimeout(replacementTimer);
      }
      replacementTimer = setTimeout(() => {
        processTextReplacement();
        // Re-render canvas with updated output
        const coloredItems = parseBytesWithColors(getEditorValue());
        const { ops, visited } = buildOps(coloredItems);
        if (animateCheckbox.checked && !editorVisible) {
          startAnim(ops, visited);
        } else {
          renderInstant(ops, visited);
        }
      }, 250);
    }
    
    // ===== UI STATE MANAGEMENT =====
    
    // Utility function for delays
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function createSvgStyle(hasTransform = false, transformValue = '1', textColor = 'currentColor', useNaturalColors = null) {
      // Check if using natural SVG colors (checkbox checked = use natural colors, so no CSS override)
      if (useNaturalColors === null) {
        useNaturalColors = svgColorCheckbox && svgColorCheckbox.checked;
      }
      
      if (useNaturalColors) {
        // Keep original SVG colors - no CSS override
        return `svg {
          width: 100%;
          height: 100%;
          display: block;
          object-fit: contain;
          object-position: center;
          ${hasTransform ? `transform: scale(${transformValue});` : ''}
          opacity: 0.5;
        }`;
      } else {
        // Apply color inheritance
        return `svg {
          width: 100%;
          height: 100%;
          display: block;
          object-fit: contain;
          object-position: center;
          ${hasTransform ? `transform: scale(${transformValue});` : ''}
          opacity: 0.5;
          color: ${textColor};
        }
        svg * {
          fill: currentColor;
          stroke: currentColor;
        }`;
      }
    }
    
    function getCardColor(cardData, fallback = '#333333') {
      if (!cardData) return fallback;
      return cardData.options?.backgroundColor || cardData.color || fallback;
    }
    
    function stripSvgColors(svgContent, useNaturalColors = null) {
      if (!svgContent) return svgContent;
      
      // Check if SVG color override is enabled (checkbox checked = use natural colors, so don't override)
      if (useNaturalColors === null) {
        useNaturalColors = svgColorCheckbox && svgColorCheckbox.checked;
      }
      if (useNaturalColors) {
        return svgContent; // Keep original colors if using natural colors
      }
      
      // Remove fill and stroke attributes to allow CSS inheritance
      let cleanedSvg = svgContent
        .replace(/\s+fill="[^"]*"/g, '')  // Remove fill attributes
        .replace(/\s+stroke="[^"]*"/g, '') // Remove stroke attributes
        .replace(/style="([^"]*?)"/g, (match, styleContent) => {
          // Remove fill and stroke from CSS styles
          const cleanedStyle = styleContent
            .replace(/fill:\s*[^;]+;?/g, '')
            .replace(/stroke:\s*[^;]+;?/g, '')
            .replace(/;\s*;/g, ';') // Clean up double semicolons
            .replace(/^;|;$/g, ''); // Remove leading/trailing semicolons
          
          return cleanedStyle ? `style="${cleanedStyle}"` : '';
        });
      
      return cleanedSvg;
    }
    
    function calculateSvgTextColor(backgroundColor, editorVisible = false) {
      // In editor mode, always use pure white
      if (editorVisible) {
        return '#ffffff';
      }
      
      // For presentation mode, use pure black or white (no color blending to avoid tints)
      const luminosity = getLuminosity(backgroundColor);
      
      if (luminosity > 0.5) {
        // Bright background - use pure black
        return '#000000';
      } else {
        // Dark background - use pure white
        return '#ffffff';
      }
    }
    
    // Calculate optimal zoom level to fit content in viewport
    function calculateOptimalZoom() {
      const viewportHeight = window.innerHeight;
      const cardHeight = 971; // Each card is 971px tall (golden ratio)
      const gap = 40; // Gap between cards
      const padding = 40; // Grid padding
      
      // Calculate total content height for 3x5 grid layout
      // 5 rows of cards (971px each)
      // Plus gaps between rows (4 gaps × 40px = 160px)
      // Plus top and bottom padding (2 × 40px = 80px)
      const totalContentHeight = (5 * cardHeight) + (4 * gap) + (2 * padding);
      
      // Use more of the viewport height for better visual impact
      const margin = 40; // Reduced margin for closer to bottom
      const availableHeight = viewportHeight - margin;
      const optimalZoom = Math.min(0.75, availableHeight / totalContentHeight);
      
      return Math.max(0.1, optimalZoom); // Don't go below 0.1 zoom
    }
    
    // Unified zoom mode detection
    function isZoomedOut() {
      const currentZoom = parseFloat(document.body.style.zoom || '0.75');
      return currentZoom < 0.5; // Consider anything below 0.5 as "zoomed out"
    }
    
    // Button state configurations
    const BUTTON_STATES = {
      normal: {
        editorToggle: { display: 'block', left: '20px', top: '' },
        exportButton: { display: 'block', left: '120px', top: '' },
        addCardButton: { display: 'none' },
        zoomOutButton: { display: 'block', right: '20px', top: '', transform: '', border: '', boxShadow: '' },
        cardIndicator: { display: 'block', right: '120px', top: '', transform: '', border: '', boxShadow: '' }
      },
      zoomedOut: {
        editorToggle: { display: 'none' },
        exportButton: { display: 'none' },
        addCardButton: { display: 'block', left: '228px', top: '160px', transform: 'scale(4.2)', border: 'none', boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.2)' },
        zoomOutButton: { display: 'block', right: '228px', top: '160px', transform: 'scale(4.2)', border: 'none', boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.2)' },
        cardIndicator: { right: '648px', top: '160px', transform: 'scale(4.2)', border: 'none', boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.2)' }
      }
    };
    
    // Apply button states
    function setButtonState(state) {
      const config = BUTTON_STATES[state];
      Object.entries(config).forEach(([buttonId, styles]) => {
        const button = document.getElementById(buttonId);
        if (button) {
          Object.entries(styles).forEach(([property, value]) => {
            button.style[property] = value;
          });
        }
      });
      
      // Reset transform for all editor-toggle buttons
      if (state === 'normal') {
        document.querySelectorAll('.editor-toggle').forEach(button => {
          button.style.transform = '';
        });
      }
    }
    
    // ===== CARD SYSTEM FUNCTIONS =====
    
    // Apply fade-in animation to canvas and SVG background (no scaling)
    function applyCardFadeIn() {
      const canvasElement = document.getElementById('board');
      const svgBackgroundElement = document.getElementById('svgBackground');
      
      if (canvasElement) {
        // Set initial opacity and clear any existing animation
        canvasElement.style.opacity = '0';
        canvasElement.style.animation = '';
        canvasElement.offsetHeight; // Force reflow
        
        // Simple fade-in without scaling
        canvasElement.style.transition = 'opacity 1.2s ease-out';
        canvasElement.style.opacity = '1';
      }
      
      if (svgBackgroundElement) {
        // Set initial opacity and clear any existing animation
        svgBackgroundElement.style.opacity = '0';
        svgBackgroundElement.style.animation = '';
        svgBackgroundElement.offsetHeight; // Force reflow
        
        // Simple fade-in without scaling
        svgBackgroundElement.style.transition = 'opacity 1.2s ease-out';
        svgBackgroundElement.style.opacity = '1';
      }
    }
    async function loadCard(cardIndex) {
      try {
        // Check if URL is valid
        if (CARD_BASE_URL.includes('{{SUPABASE_URL}}')) {
          throw new Error('SUPABASE_URL not configured - access via FastAPI server with LOCAL_SUPABASE_URL set');
        }
        
        // Ensure the block containing this card is preloaded
        await ensureBlockPreloaded(cardIndex);
        
        // Check cache first
        let cardData = cardCache.get(cardIndex);
        
        if (!cardData) {
          // Fallback to direct fetch if not in cache
          const cacheBuster = `?t=${Date.now()}`;
          const response = await fetch(`${CARD_BASE_URL}${cardIndex}.json${cacheBuster}`);
          if (!response.ok) {
            throw new Error(`Card ${cardIndex} not found`);
          }
          cardData = await response.json();
          cardCache.set(cardIndex, cardData);
        }
        
        // Apply the loaded settings
        if (cardData.options) {
          sInputEl.value = cardData.options.size || 5;
          s = cardData.options.size || 5;
          thickness = s / 10;
          sValueEl.textContent = s;
          
          bgColorSelectEl.value = cardData.options.backgroundColor || COLORS[DEFAULT_PANEL_COLOR_INDEX].hex;
          const colorIndicator = document.getElementById('bgColorIndicator');
          colorIndicator.style.backgroundColor = cardData.options.backgroundColor || COLORS[DEFAULT_PANEL_COLOR_INDEX].hex;
          
          italicsCheckbox.checked = cardData.options.italics !== false;
          italicsMode = cardData.options.italics !== false;
          
          animateCheckbox.checked = cardData.options.animate === true;
          
          svgColorCheckbox.checked = cardData.options.svgColor === true;
          
          svgInputEl.value = cardData.options.svgBackground || '';
          
          // Set order select
          const orderValue = cardData.options.order;
          orderSelectEl.value = orderValue !== undefined ? orderValue.toString() : '';
          
          // Update position display
          const positionDisplay = document.getElementById('positionDisplay');
          if (positionDisplay) {
            let displayText = '';
            
            // Show position if available
            if (cardData.options.position) {
              displayText = `Row ${cardData.options.position.row}, Col ${cardData.options.position.col}`;
            } else {
              displayText = 'Not set';
            }
            
            positionDisplay.textContent = displayText;
          }
        } else {
          // Update position display even if no options
          const positionDisplay = document.getElementById('positionDisplay');
          if (positionDisplay) {
            positionDisplay.textContent = 'Not set';
          }
        }
        
        // Load content
        if (cardData.rule !== undefined) {
          ruleEl.textContent = cardData.rule;
        }
        if (cardData.input !== undefined) {
          inputEl.textContent = cardData.input;
        }
        
        // Load and display SVG background first
        await drawSvgBackground();
        
        // Update UI after SVG is loaded
        if (!isZoomedOut()) {
          updateCanvasBackground(bgColorSelectEl.value);
        }
        updateCardGlow(bgColorSelectEl.value);
        highlightEditor();
        
        // Process text replacement to update Output field
        processTextReplacement();
        
        // Render the new content (now using Output field)
        renderNow();
        
        // Update card indicator
        await updateCardIndicator();
        
        // Update card file name display
        updateCardFileName();
        
        return true;
      } catch (error) {
        console.error(`Failed to load card ${cardIndex}:`, error);
        return false;
      }
    }
    
    async function findMaxCardIndex() {
      // Try to find the highest available card index using parallel chunks of 15
      let maxIndex = 0;
      const chunkSize = 15;
      const maxCards = 100;
      
      for (let startIndex = 1; startIndex <= maxCards; startIndex += chunkSize) {
        const endIndex = Math.min(startIndex + chunkSize - 1, maxCards);
        
        // Create parallel requests for this chunk
        const promises = [];
        for (let i = startIndex; i <= endIndex; i++) {
          const cacheBuster = `?t=${Date.now()}`;
          const promise = fetch(`${CARD_BASE_URL}${i}.json${cacheBuster}`, { method: 'HEAD' })
            .then(response => ({ index: i, exists: response.ok }))
            .catch(() => ({ index: i, exists: false }));
          promises.push(promise);
        }
        
        // Wait for all requests in this chunk to complete
        const results = await Promise.all(promises);
        
        // Check results in order to find the highest existing card
        let foundExisting = false;
        for (const result of results) {
          if (result.exists) {
            maxIndex = result.index;
            foundExisting = true;
          } else if (foundExisting) {
            // If we found existing cards but now hit a missing one, we can stop
            break;
          }
        }
        
        // If no cards exist in this chunk, we've found the end
        if (!foundExisting) {
          break;
        }
      }
      
      return maxIndex;
    }
    
    function canFlipLeft() {
      return currentCardIndex < maxCardIndex;
    }
    
    function canFlipRight() {
      return currentCardIndex > 1;
    }
    
    async function updateCardIndicator() {
      if (cardIndicator) {
        if (isZoomedOut()) {
          // Show set number in zoomed-out mode
          const currentSetInfo = await getSetForCard(currentCardIndex);
          const currentSet = Math.ceil(currentCardIndex / MAX_CARDS_PER_SET); // Approximate for now
          const totalSets = Math.ceil(maxCardIndex / MAX_CARDS_PER_SET); // Approximate for now
          cardIndicator.textContent = `${currentSet} / ${totalSets}`;
        } else {
          // Show individual card number in normal mode
          cardIndicator.textContent = `${currentCardIndex} / ${maxCardIndex}`;
        }
      }
    }
    
    function updateCardFileName() {
      if (cardFileNameEl) {
        cardFileNameEl.textContent = `${currentCardIndex}.json`;
      }
    }
    
    async function addNewCard() {
      try {
        // Get current set information
        const currentSetInfo = await getSetForCard(currentCardIndex);
        const insertPosition = currentSetInfo.end + 1;
        
        // Shift all cards from insertPosition onwards up by one
        await shiftCardsUp(insertPosition);
        
        // Create a new card with default content
        const newCardData = {
          input: '',
          rule: '',
          options: {
            size: 10,
            background: '#808080',
            italics: false,
            animate: true,
            svgColor: false,
            svgBackground: '',
            position: null,
            order: null
          }
        };
        
        // Upload the new card at the insert position using Supabase storage
        const jsonString = JSON.stringify(newCardData, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const fileName = `${insertPosition}.json`;
        
        const { data, error } = await supabaseClient.storage
          .from('card')
          .upload(fileName, blob, {
            contentType: 'application/json',
            upsert: true // Overwrite if file exists
          });
        
        if (error) {
          throw new Error(`Failed to create card: ${error.message}`);
        }
        
        // Update max card index
        maxCardIndex = maxCardIndex + 1;
        
        // Navigate to the new card
        currentCardIndex = insertPosition;
        updateCardFileName();
        await loadCard(insertPosition);
        
        // Update card indicator
        await updateCardIndicator();
        
        // If in zoomed-out mode, refresh the view
        if (isZoomedOut()) {
          showCardBlockOverview();
        }
        
        // Clear set boundaries cache since we added a new card
        setBoundaries.clear();
        
      } catch (error) {
        console.error('Error adding new card:', error);
        alert(`Failed to add new card: ${error.message}`);
      }
    }
    
    async function shiftCardsUp(startIndex) {
      // Work backwards from the highest card to avoid overwriting
      for (let i = maxCardIndex; i >= startIndex; i--) {
        const currentCardData = await getCardData(i);
        if (currentCardData) {
          // Upload the card with the new index using Supabase storage
          const jsonString = JSON.stringify(currentCardData, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const newFileName = `${i + 1}.json`;
          
          const { data, error } = await supabaseClient.storage
            .from('card')
            .upload(newFileName, blob, {
              contentType: 'application/json',
              upsert: true // Overwrite if file exists
            });
          
          if (error) {
            throw new Error(`Failed to shift card ${i} to ${i + 1}: ${error.message}`);
          }
          
          // Delete the old card file
          const { error: deleteError } = await supabaseClient.storage
            .from('card')
            .remove([`${i}.json`]);
          
          if (deleteError) {
            console.warn(`Failed to delete old card ${i}.json:`, deleteError);
            // Don't throw here - the new file was created successfully
          }
          
          // Update cache
          cardCache.set(i + 1, currentCardData);
          cardCache.delete(i);
        }
      }
    }

    async function uploadCard() {
      try {
        // Get existing card data to preserve position and other settings
        let existingCardData = cardCache.get(currentCardIndex);
        if (!existingCardData) {
          // Fallback to direct fetch if not in cache
          const cacheBuster = `?t=${Date.now()}`;
          const response = await fetch(`${CARD_BASE_URL}${currentCardIndex}.json${cacheBuster}`);
          if (response.ok) {
            existingCardData = await response.json();
            cardCache.set(currentCardIndex, existingCardData);
          }
        }
        
        // Collect all settings, preserving existing position and other data
        const settings = {
          options: {
            size: parseInt(sInputEl.value, 10),
            backgroundColor: bgColorSelectEl.value,
            italics: italicsCheckbox.checked,
            animate: animateCheckbox.checked,
            svgColor: svgColorCheckbox.checked,
            svgBackground: svgInputEl.value.trim(),
            ...(orderSelectEl.value && { order: parseInt(orderSelectEl.value, 10) }),
            // Preserve existing position if it exists
            ...(existingCardData?.options?.position && { position: existingCardData.options.position })
          },
          rule: getPlainText(ruleEl),
          input: getPlainText(inputEl)
        };

        // Create JSON string
        const jsonString = JSON.stringify(settings, null, 2);
        
        // Create blob for upload
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // Upload to Supabase storage
        const fileName = `${currentCardIndex}.json`;
        
        const { data, error } = await supabaseClient.storage
          .from('card')
          .upload(fileName, blob, {
            contentType: 'application/json',
            upsert: true // Overwrite if file exists
          });

        if (error) {
          console.error('Upload error:', error);
          console.error('Error details:', JSON.stringify(error, null, 2));
          alert(`Upload failed: ${error.message}\n\nDetails: ${JSON.stringify(error, null, 2)}`);
          return;
        }

        // Upload successful
        alert(`Card ${currentCardIndex} uploaded successfully!`);
        
        // Update cache with new data
        cardCache.set(currentCardIndex, settings);
        
        // Update max card index if we uploaded a new card
        if (currentCardIndex > maxCardIndex) {
          maxCardIndex = currentCardIndex;
          await updateCardIndicator();
        }
        
      } catch (error) {
        console.error('Upload error:', error);
        alert(`Upload failed: ${error.message}`);
      }
    }

    function updateEditorToggleState() {
      const now = performance.now();
      const isInCooldown = now < animationCooldownEnd;
      const canToggle = document.activeElement !== inputEl && 
                       document.activeElement !== ruleEl && 
                       document.activeElement !== outputEl && 
                       !isFlipping && 
                       !currentAnim && 
                       !isInCooldown;
      
      editorToggleBtn.disabled = !canToggle;
      updateEditorToggleIcon();
    }

    function renderNow(){
      try{
        const coloredItems = parseBytesWithColors(getEditorValue());
        const { ops, visited } = buildOps(coloredItems);
        stopAnim();
        
        // Always use static rendering in renderNow (animation is handled elsewhere)
        renderInstant(ops, visited);
        
      }catch(e){
        console.error('Render error:',e);
        stopAnim();
      }
    }

    // Live update on every edit (typing, delete, IME commits, etc.)
    inputEl.addEventListener('input', () => {
      // No highlighting in Input field to avoid cursor position issues
      debouncedProcessTextReplacement(); // process text replacement and update canvas
      scheduleSnapshot();  // coalesce undo snapshots
    });

    // Handle highlighting when clicking in the input field
    inputEl.addEventListener('click', () => {
      setTimeout(() => {
        highlightOutput();
        renderNow();
      }, 0);
    });

    // Handle highlighting when using arrow keys to move cursor
    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        setTimeout(() => {
          highlightOutput();
          renderNow();
        }, 0);
      }
    });

    
    // Process text replacement when rule field changes
    ruleEl.addEventListener('input', () => {
      debouncedProcessTextReplacement();
    });

    // Update highlighting when cursor position changes (click, arrow keys, etc.)
    // DISABLED - causing infinite loops. Using input event only.
    /*
    document.addEventListener('selectionchange', () => {
      if (document.activeElement === inputEl) {
        // Only update if there's no active selection (just cursor movement)
        const sel = getSelection();
        if (!sel || sel.rangeCount === 0 || sel.isCollapsed) {
          // Small delay to ensure cursor position is fully established
          setTimeout(() => {
            const caret = getCaretOffset(inputEl);
            highlightEditor();
            highlightOutput();
            setCaretOffset(inputEl, caret);
            renderNow();
          }, 0);
        }
      }
    });
    */

    
    // ===== COLOR & BACKGROUND FUNCTIONS =====
    function populateColorOptions() {
      const colors = COLORS;
      const initialColor = colors[DEFAULT_PANEL_COLOR_INDEX].hex; // Default to car color
      
      // Clear existing options
      bgColorSelectEl.innerHTML = '';
      
      // Add transparent option first to prevent flash
      const transparentOption = document.createElement('option');
      transparentOption.value = 'transparent';
      transparentOption.textContent = 'transparent';
      transparentOption.selected = true;
      bgColorSelectEl.appendChild(transparentOption);
      
      // Add color options with names and hex values
      colors.forEach((colorObj, index) => {
        const option = document.createElement('option');
        option.value = colorObj.hex;
        option.textContent = `${colorObj.name} (${colorObj.hex})`;
        bgColorSelectEl.appendChild(option);
      });
    }
    
    // Generate gradient from base color (slightly lighter at bottom for zoomed-in mode)
    function generateGradientFromColor(baseColor) {
      const rgb = hexToRgb(baseColor);
      
      // Create gradient with varying opacity (brighter overall)
      return `linear-gradient(135deg, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.95) 0%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.85) 25%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.75) 50%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.65) 75%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.55) 100%)`;
    }
    
    // Generate lighter gradient for zoomed-out cards
    function generateLightGradientFromColor(baseColor) {
      const rgb = hexToRgb(baseColor);
      
      // Create gradient with varying opacity - brighter overall for zoomed-out mode
      return `linear-gradient(135deg, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.9) 0%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.8) 25%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.7) 50%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.6) 75%, 
        rgba(${rgb.r},${rgb.g},${rgb.b},0.5) 100%)`;
    }
    
    // Update canvas background based on editor mode and selected color
    function updateCanvasBackground(selectedColor) {
      const canvasElement = document.getElementById('board');
      const canvasWrapper = document.getElementById('canvasWrapper');
      
      if (!editorVisible) {
        // Check if there's an SVG background - if so, keep canvas transparent and apply gradient to canvas wrapper
        const svgBackgroundElement = document.getElementById('svgBackground');
        const hasSvgBackground = svgBackgroundElement && svgBackgroundElement.style.display !== 'none' && svgBackgroundElement.innerHTML.trim();
        
        if (hasSvgBackground) {
          canvasElement.style.background = 'transparent';
          if (canvasWrapper) {
            canvasWrapper.style.background = generateGradientFromColor(selectedColor);
          }
        } else {
          canvasElement.style.background = generateGradientFromColor(selectedColor);
          if (canvasWrapper) {
            canvasWrapper.style.background = '';
          }
        }
      } else {
        canvasElement.style.background = '';
        if (canvasWrapper) {
          canvasWrapper.style.background = '';
        }
      }
    }
    
    // Update card glow to match the selected color
    function updateCardGlow(selectedColor) {
      const rgb = hexToRgb(selectedColor);
      
      // Create lighter, more whitish glow variations (brighter)
      const glow1 = `rgba(${Math.min(255, rgb.r + 100)}, ${Math.min(255, rgb.g + 100)}, ${Math.min(255, rgb.b + 100)}, 0.8)`;
      const glow2 = `rgba(${Math.min(255, rgb.r + 80)}, ${Math.min(255, rgb.g + 80)}, ${Math.min(255, rgb.b + 80)}, 0.6)`;
      const glow3 = `rgba(${Math.min(255, rgb.r + 60)}, ${Math.min(255, rgb.g + 60)}, ${Math.min(255, rgb.b + 60)}, 0.4)`;
      
      // Update CSS custom properties for card glow
      document.documentElement.style.setProperty('--card-glow-1', glow1);
      document.documentElement.style.setProperty('--card-glow-2', glow2);
      document.documentElement.style.setProperty('--card-glow-3', glow3);
    }
    
    // Initialize color options and set defaults
    populateColorOptions();
    
    const initialColor = COLORS[DEFAULT_PANEL_COLOR_INDEX].hex;
    const colorIndicator = document.getElementById('bgColorIndicator');
    
    // Set initial values
    colorIndicator.style.backgroundColor = initialColor;
    // Start with transparent background to prevent flash
    const canvasElement = document.getElementById('board');
    canvasElement.style.background = 'transparent';
    updateCardGlow(initialColor);
    
    
    // Animate checkbox event listener
    animateCheckbox.addEventListener('change', () => {
      if (!editorVisible) {
        // Update the current presentation based on checkbox state
        const coloredItems = parseBytesWithColors(getEditorValue());
        const { ops, visited } = buildOps(coloredItems);
        
        // Stop any current animation
        stopAnim();
        
        // Render based on checkbox state
        if (animateCheckbox.checked && !editorVisible) {
          startAnim(ops, visited);
        } else {
          renderInstant(ops, visited);
        }
      }
    });
    
    // Background color select event listener
    bgColorSelectEl.addEventListener('change', () => {
      const selectedColor = bgColorSelectEl.value;
      
      // Update color indicator
      if (selectedColor === 'transparent') {
        colorIndicator.style.backgroundColor = '#000000'; // Default for transparent
      } else {
        colorIndicator.style.backgroundColor = selectedColor;
      }
      
      // Update canvas background and glow
      updateCanvasBackground(selectedColor);
      updateCardGlow(selectedColor);
    });
    
    // Export button event listener
    exportButton.addEventListener('click', (e) => {
      preventCardFlip(e);
      uploadCard();
    });
    
    // Add card button event listener
    addCardButton.addEventListener('click', (e) => {
      preventCardFlip(e);
      addNewCard();
    });
    
    // Zoom out button event listener
    zoomOutButton.addEventListener('click', async (e) => {
      preventCardFlip(e);
      
      // Toggle between zoom modes
      if (!isZoomedOut()) {
        const optimalZoom = calculateOptimalZoom();
        document.body.style.zoom = optimalZoom.toString();
        setButtonState('zoomedOut');
        await updateCardIndicator();
        showCardBlockOverview();
      } else {
        document.body.style.zoom = '0.75';
        setButtonState('normal');
        hideCardBlockOverview();
        
        // Ensure card data is properly loaded when returning from zoomed-out view
        setTimeout(async () => {
          // Wait for canvas to be ready and force a reflow
          await delay(100);
          
          // Force a reflow to ensure DOM is ready
          document.getElementById('board').offsetHeight;
          
          // Load the current card to ensure it's displayed
          await loadCard(currentCardIndex);
          
          // Add fade-in animation
          applyCardFadeIn();
        });
      }
    });
    
    // Card indicator event listener (prevents card flip when clicked)
    cardIndicator.addEventListener('click', (e) => {
      preventCardFlip(e);
      // No action needed - just prevent card flip
    });
    
    sInputEl.addEventListener('input', () => {
      s = parseInt(sInputEl.value, 10);
      thickness = s/10;
      sValueEl.textContent = s;
      
      // Clear canvas before redraw to avoid visual artifacts
      ctx.clearRect(0, 0, width, height);
      
      renderNow();
    });

    // SVG input functionality
    svgInputEl.addEventListener('input', async () => {
      // Always update SVG display (preview in editor mode, background in non-editor mode)
        await drawSvgBackground();
    });
    

    // Hotkey listener for editor toggle (Ctrl+E or Cmd+E)
    let isFlippingOut = false;
    
    // Consolidated card flip handler
    async function handleCardFlip(direction = 'left') {
      if (editorVisible || isFlippingOut) return;
      
      // Check if we're in zoomed-out mode
      if (isZoomedOut()) {
        await handleCardSetFade(direction);
        return;
      }
      
      // Check boundaries
      if ((direction === 'left' && !canFlipLeft()) || 
          (direction === 'right' && !canFlipRight())) {
        return;
      }
      
      isFlippingOut = true;
      const flipOutAnimation = direction === 'right' ? 'cardFlipOutRight' : 'cardFlipOut';
      const flipInAnimation = direction === 'right' ? 'cardFlipInRight' : 'cardFlipIn';
      
      // Cache card element if not already cached
      if (!cardElement) {
        cardElement = document.querySelector('.canvas-only .grid > div:first-child');
      }
      
      if (cardElement) {
        cardElement.style.animation = `${flipOutAnimation} 0.8s linear forwards`;
        
        setTimeout(async () => {
          // Update card index
          if (direction === 'left') {
            currentCardIndex++;
          } else {
            currentCardIndex--;
          }
          
          // Load the new card
          const loadSuccess = await loadCard(currentCardIndex);
          if (!loadSuccess) {
            // Revert index if load failed
            if (direction === 'left') {
              currentCardIndex--;
            } else {
              currentCardIndex++;
            }
            isFlippingOut = false;
            return;
          }
          
          
          // Trigger background preloading for adjacent blocks
          const currentSetInfo = await getSetForCard(currentCardIndex);
          const nextBlock = currentSetInfo.end + 1;
          const prevBlock = currentSetInfo.start - MAX_CARDS_PER_SET;
          
          // Preload next block if it exists
          if (nextBlock <= maxCardIndex) {
            preloadCardBlock(nextBlock).catch(error => {
              console.error('Failed to preload next block:', error);
            });
          }
          
          // Preload previous block if it exists
          if (prevBlock >= 1) {
            preloadCardBlock(prevBlock).catch(error => {
              console.error('Failed to preload previous block:', error);
            });
          }
          
          cardElement.style.animation = `${flipInAnimation} 0.8s linear forwards`;
          
          // Re-enable interactions after flip in completes
          setTimeout(() => {
            isFlippingOut = false;
          }, 800); // Wait for flip in animation to complete
        }, 800);
      }
    }
    
    async function handleCardSetFade(direction = 'left') {
      if (editorVisible || isFlippingOut) return;
      
      // Check if we can navigate to another set
      const currentSetInfo = await getSetForCard(currentCardIndex);
      let newBlockStart;
      
      if (direction === 'left') {
        // Go to next set - check if there's actually a next set
        const nextSetStart = currentSetInfo.end + 1;
        if (nextSetStart > maxCardIndex) {
          // Already at the last set, don't navigate
          return;
        }
        newBlockStart = nextSetStart;
      } else {
        // Go to previous set - find the actual start of the previous set
        if (currentSetInfo.start > 1) {
          // Look for the previous set start by checking cards before the current set
          for (let i = currentSetInfo.start - 1; i >= 1; i--) {
            const cardData = await getCardData(i);
            if (cardData && cardData.options && cardData.options.order === 1) {
              newBlockStart = i;
              break;
            }
          }
          // If no previous set start found, go to card 1
          if (!newBlockStart) {
            newBlockStart = 1;
          }
        } else {
          // Already at first set, don't navigate
          return;
        }
      }
      
      // If we're already at the boundary, don't navigate
      if (newBlockStart === currentSetInfo.start) {
        return;
      }
      
      isFlippingOut = true;
      
      // Fade out current set
      const gridContainer = document.querySelector('.grid-container');
      if (gridContainer) {
        gridContainer.style.transition = 'opacity 0.4s ease-out';
        gridContainer.style.opacity = '0';
      }
      
      // Wait for fade out
      await delay(400);
      
      // Update to new block
      const newCardIndex = newBlockStart;
      
      // Clear set boundaries cache to ensure fresh detection
      setBoundaries.clear();
      
      currentCardIndex = newCardIndex;
      updateCardFileName();
      
      // Show new set
      await showCardBlockOverview();
      
      // Fade in new set
      const newGridContainer = document.querySelector('.grid-container');
      if (newGridContainer) {
        newGridContainer.style.opacity = '0';
        newGridContainer.style.transition = 'opacity 0.4s ease-in';
        // Force reflow to ensure opacity is applied
        newGridContainer.offsetHeight;
        newGridContainer.style.opacity = '1';
      }
      
      // Wait for fade in
      await delay(400);
      
      // Reset transition
      if (newGridContainer) {
        newGridContainer.style.transition = '';
      }
      
      isFlippingOut = false;
      await updateCardIndicator();
    }
    
    // Consolidated input handlers
    document.addEventListener('click', (e) => {
      if (editorVisible || isFlippingOut) return;
      
      // Don't trigger card flip for programmatic clicks (like download links)
      if (e.target.getAttribute('data-programmatic') === 'true') return;
      
      // Find the card element to get its position
      if (!cardElement) {
        cardElement = document.querySelector('.canvas-only .grid > div:first-child');
      }
      if (!cardElement) return;
      
      // Get card's bounding rectangle
      const cardRect = cardElement.getBoundingClientRect();
      const cardCenterX = cardRect.left + cardRect.width / 2;
      
      // Determine click position relative to card center
      const clickX = e.clientX;
      const direction = clickX < cardCenterX ? 'right' : 'left';
      
      handleCardFlip(direction);
    });
    document.addEventListener('touchstart', (e) => {
      if (editorVisible || isFlippingOut) return;
      
      e.preventDefault();
      
      // Find the card element to get its position
      if (!cardElement) {
        cardElement = document.querySelector('.canvas-only .grid > div:first-child');
      }
      if (!cardElement) return;
      
      // Get card's bounding rectangle
      const cardRect = cardElement.getBoundingClientRect();
      const cardCenterX = cardRect.left + cardRect.width / 2;
      
      // Determine touch position relative to card center
      const touchX = e.touches[0].clientX;
      const direction = touchX < cardCenterX ? 'right' : 'left';
      
      handleCardFlip(direction);
    });

    document.addEventListener('keydown', async (e) => {
      // Handle flip animations (only when not in zoomed-out mode)
      if ((e.code === 'Space' || e.code === 'ArrowLeft' || e.code === 'ArrowRight') && !editorVisible && !isFlippingOut && !isZoomedOut()) {
        e.preventDefault();
        let direction;
        if (e.code === 'Space') {
          direction = 'left'; // Space moves to next card (right) but flips left
        } else {
          direction = e.code === 'ArrowRight' ? 'left' : 'right';
        }
        handleCardFlip(direction);
        return;
      }
      
      // Handle Ctrl+E or Cmd+E for editor toggle
      if (e.key.toLowerCase() === 'e' && (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey) {
        if (canToggleEditor()) {
          e.preventDefault();
          editorToggleBtn.click();
        }
        return;
      }
      
      // Handle Enter or Z for zoom toggle (only in presentation mode)
      if ((e.key === 'Enter' || e.key.toLowerCase() === 'z') && !editorVisible && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
        e.preventDefault();
        // Emulate a click on the zoom button
        zoomOutButton.click();
        return;
      }
      
      // Handle Ctrl+S or Cmd+S for save card
      if (e.key.toLowerCase() === 's' && (e.ctrlKey || e.metaKey) && !e.altKey && !e.shiftKey) {
        e.preventDefault();
        exportButton.click(); // Trigger the existing export functionality
        return;
      }
      
      
      // Handle number keys 1-9 to jump to specific card in current set (only in presentation mode)
      if (e.key >= '1' && e.key <= '9' && !editorVisible && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
        e.preventDefault();
        const targetCardNumber = parseInt(e.key, 10);
        const currentSetInfo = await getSetForCard(currentCardIndex);
        const currentSetStart = currentSetInfo.start;
        const targetCardIndex = currentSetStart + targetCardNumber - 1;
        
        // Only jump if the target card exists
        if (targetCardIndex <= maxCardIndex) {
          // Load the target card directly
          loadCard(targetCardIndex);
        }
        return;
      }
      
      // Handle up/down arrow keys in zoomed-out mode to change sets
      if ((e.code === 'ArrowUp' || e.code === 'ArrowDown') && !editorVisible && isZoomedOut() && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
        e.preventDefault();
        
        const currentSetInfo = await getSetForCard(currentCardIndex);
        let targetCardIndex;
        
        if (e.code === 'ArrowUp') {
          // Up arrow: go to previous set - find the actual start of the previous set
          if (currentSetInfo.start > 1) {
            // Look for the previous set start by checking cards before the current set
            for (let i = currentSetInfo.start - 1; i >= 1; i--) {
              const cardData = await getCardData(i);
              if (cardData && cardData.options && cardData.options.order === 1) {
                targetCardIndex = i;
                break;
              }
            }
            // If no previous set start found, go to card 1
            if (!targetCardIndex) {
              targetCardIndex = 1;
            }
          } else {
            // Already at first set, don't navigate
            return;
          }
        } else { // ArrowDown
          // Down arrow: go to next set - check if there's actually a next set
          const nextSetStart = currentSetInfo.end + 1;
          if (nextSetStart > maxCardIndex) {
            // Already at the last set, don't navigate
            return;
          }
          targetCardIndex = nextSetStart;
        }
        
        // Only navigate if the target set exists
        if (targetCardIndex <= maxCardIndex) {
          // Clear set boundaries cache to ensure fresh detection
          setBoundaries.clear();
          
          currentCardIndex = targetCardIndex;
          updateCardFileName();
          loadCard(targetCardIndex);
          
          // Update the zoomed-out view to show the new set
          showCardBlockOverview();
        }
        return;
      }
      
      // Handle left/right arrow keys in zoomed-out mode to navigate within current set
      if ((e.code === 'ArrowLeft' || e.code === 'ArrowRight') && !editorVisible && isZoomedOut() && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
        e.preventDefault();
        
        const currentSetInfo = await getSetForCard(currentCardIndex);
        const range = currentSetInfo;
        const { cardsWithPositions, cardsWithoutPositions } = await loadCardPositions(range);
        
        // Get current card's grid position
        const currentCardPosition = cardsWithPositions.find(pos => pos.cardIndex === currentCardIndex);
        if (!currentCardPosition) return; // Can't navigate if position not found
        
        let targetCardPosition = null;
        
        // Create a sorted list of all card positions for easier navigation
        const allPositions = [...cardsWithPositions];
        const sortedPositions = allPositions.sort((a, b) => {
          const aValue = (a.row - 1) * 3 + a.col;
          const bValue = (b.row - 1) * 3 + b.col;
          return aValue - bValue;
        });
        
        const currentIndex = sortedPositions.findIndex(pos => pos.cardIndex === currentCardIndex);
        
        if (e.code === 'ArrowRight') {
          // Right arrow: move to next card in sorted order
          if (currentIndex < sortedPositions.length - 1) {
            targetCardPosition = sortedPositions[currentIndex + 1];
          } else {
            // Wrap to first card
            targetCardPosition = sortedPositions[0];
          }
        } else { // ArrowLeft
          // Left arrow: move to previous card in sorted order
          if (currentIndex > 0) {
            targetCardPosition = sortedPositions[currentIndex - 1];
          } else {
            // Wrap to last card
            targetCardPosition = sortedPositions[sortedPositions.length - 1];
          }
        }
        
        if (targetCardPosition) {
          const targetCardIndex = targetCardPosition.cardIndex;
          
          // Only navigate if the target card exists
          if (targetCardIndex <= maxCardIndex) {
            currentCardIndex = targetCardIndex;
            updateCardFileName();
            loadCard(targetCardIndex);
            
            // Update visual selection in the grid
            const gridContainer = document.querySelector('.grid-container');
            if (gridContainer) {
              // Remove previous selection
              const previousSelected = gridContainer.querySelector('.card-wrapper.selected');
              if (previousSelected) {
                previousSelected.classList.remove('selected');
              }
              
              // Add selection to new card
              const cardWrappers = gridContainer.querySelectorAll('.card-wrapper');
              for (let i = 0; i < cardWrappers.length; i++) {
                const cardIndex = parseInt(cardWrappers[i].getAttribute('data-card-index'));
                if (cardIndex === targetCardIndex) {
                  cardWrappers[i].classList.add('selected');
                  break;
                }
              }
            }
          }
        }
        return;
      }
    });

    // ===== SWIPE GESTURE SUPPORT =====
    let touchStartY = 0;
    let touchStartX = 0;
    let touchStartTime = 0;
    const SWIPE_THRESHOLD = 50; // Minimum distance for a swipe
    const SWIPE_TIME_THRESHOLD = 300; // Maximum time for a swipe (ms)
    const VERTICAL_SWIPE_RATIO = 2; // Vertical swipe must be at least 2x longer than horizontal
    let lastNavigationTime = 0;
    const NAVIGATION_DEBOUNCE = 500; // Minimum time between navigations (ms)

    // Touch events for mobile devices
    document.addEventListener('touchstart', (e) => {
      if (editorVisible || !isZoomedOut()) return;
      
      const touch = e.touches[0];
      touchStartY = touch.clientY;
      touchStartX = touch.clientX;
      touchStartTime = Date.now();
    });

    document.addEventListener('touchend', async (e) => {
      if (editorVisible || !isZoomedOut()) return;
      
      const touch = e.changedTouches[0];
      const touchEndY = touch.clientY;
      const touchEndX = touch.clientX;
      const touchEndTime = Date.now();
      
      const deltaY = touchStartY - touchEndY;
      const deltaX = Math.abs(touchEndX - touchStartX);
      const deltaTime = touchEndTime - touchStartTime;
      
      // Check if this is a valid vertical swipe
      if (Math.abs(deltaY) > SWIPE_THRESHOLD && 
          Math.abs(deltaY) > deltaX * VERTICAL_SWIPE_RATIO && 
          deltaTime < SWIPE_TIME_THRESHOLD) {
        
        e.preventDefault();
        
        if (deltaY > 0) {
          // Swipe up - go to previous set
          await navigateToSet('up');
        } else {
          // Swipe down - go to next set
          await navigateToSet('down');
        }
      }
    });

    // Wheel events for touchpad two-finger scrolling
    document.addEventListener('wheel', async (e) => {
      if (editorVisible || !isZoomedOut()) return;
      
      // Only handle vertical scrolling
      if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
        e.preventDefault();
        
        if (e.deltaY > 0) {
          // Scroll down - go to next set
          await navigateToSet('down');
        } else {
          // Scroll up - go to previous set
          await navigateToSet('up');
        }
      }
    }, { passive: false });

    // Helper function to navigate between sets
    async function navigateToSet(direction) {
      // Debounce rapid navigation calls
      const now = Date.now();
      if (now - lastNavigationTime < NAVIGATION_DEBOUNCE) {
        return;
      }
      lastNavigationTime = now;
      
      const currentSetInfo = await getSetForCard(currentCardIndex);
      let targetCardIndex;
      
      if (direction === 'up') {
        // Go to previous set - find the actual start of the previous set
        if (currentSetInfo.start > 1) {
          // Look for the previous set start by checking cards before the current set
          for (let i = currentSetInfo.start - 1; i >= 1; i--) {
            const cardData = await getCardData(i);
            if (cardData && cardData.options && cardData.options.order === 1) {
              targetCardIndex = i;
              break;
            }
          }
          // If no previous set start found, go to card 1
          if (!targetCardIndex) {
            targetCardIndex = 1;
          }
        } else {
          // Already at first set, don't navigate
          return;
        }
      } else {
        // Go to next set - check if there's actually a next set
        const nextSetStart = currentSetInfo.end + 1;
        if (nextSetStart > maxCardIndex) {
          // Already at the last set, don't navigate
          return;
        }
        targetCardIndex = nextSetStart;
      }
      
      // Only navigate if the target set exists and is different from current
      if (targetCardIndex <= maxCardIndex && targetCardIndex !== currentCardIndex) {
        // Clear set boundaries cache to ensure fresh detection
        setBoundaries.clear();
        
        currentCardIndex = targetCardIndex;
        updateCardFileName();
        loadCard(targetCardIndex);
        
        // Update the zoomed-out view to show the new set
        showCardBlockOverview();
      }
    }

    // Initial
    window.addEventListener('load', async () => {
      // Start in non-edit mode (canvas-only)
      document.body.classList.add('canvas-only');
      
      // Initialize card indicator visibility (visible in presentation mode)
      if (cardIndicator) {
        cardIndicator.style.display = 'block';
      }
      
      // Initialize card system
      maxCardIndex = await findMaxCardIndex();
      
      // Update card indicator with max count
      await updateCardIndicator();
      
      // Set current card to 1 (first card of first set)
      currentCardIndex = 1;
      
      // Start directly in zoomed-out mode showing set 1
      const optimalZoom = calculateOptimalZoom();
      document.body.style.zoom = optimalZoom.toString();
      setButtonState('zoomedOut');
      await updateCardIndicator();
      await showCardBlockOverview();
      
      // Preload the first block in the background
      if (maxCardIndex > 0) {
        preloadCardBlock(1).catch(error => {
          console.error('Failed to preload initial block:', error);
        });
      }
      
      // Now show the page with fade-in
      document.body.classList.add('page-ready');
      
      // Apply fade-in animation after everything is loaded
      applyCardFadeIn();
      
      // Skip initial canvas rendering since we're starting in zoomed-out mode
      // The canvas will be replaced by the grid, and rendering will happen
      // when user zooms back in to single card view
      
      // Start rendering based on checkbox state
      // const coloredItems = parseBytesWithColors(getEditorValue());
      // const { ops, visited } = buildOps(coloredItems);
      // 
      // if (animateCheckbox.checked) {
      //   startAnim(ops, visited);
      // } else {
      //   renderInstant(ops, visited);
      // }
      pushHistory(); // seed history
      
      // Add event listeners after DOM is ready
      const italicsCheckboxEl = document.getElementById('italicsCheckbox');
      
      if (italicsCheckboxEl) {
        italicsCheckboxEl.addEventListener('change', ()=>{
          italicsMode = italicsCheckboxEl.checked;
          renderNow();       // redraw canvas with new italics mode
        });
      }
      
      const svgColorCheckboxEl = document.getElementById('svgColorCheckbox');
      if (svgColorCheckboxEl) {
        svgColorCheckboxEl.addEventListener('change', async ()=>{
          // Redraw SVG background with new color setting
          await drawSvgBackground();
          
          // If in zoomed-out mode, also redraw the overview
          if (isZoomedOut()) {
            showCardBlockOverview();
          }
        });
      }
      
      // Order select event listener
      if (orderSelectEl) {
        orderSelectEl.addEventListener('change', () => {
          // Clear set boundaries cache so new order takes effect
          setBoundaries.clear();
          
          // If in zoomed-out mode, redraw the overview to reflect new boundaries
          if (isZoomedOut()) {
            showCardBlockOverview();
          }
        });
      }
      
    });

    // Update editor toggle button state periodically
    setInterval(updateEditorToggleState, 100);
    
    // Update button state on focus changes
    document.addEventListener('focusin', updateEditorToggleState);
    document.addEventListener('focusout', updateEditorToggleState);
    
    // Recalculate zoom on window resize if zoomed out
    window.addEventListener('resize', () => {
      if (isZoomedOut()) {
        const optimalZoom = calculateOptimalZoom();
        document.body.style.zoom = optimalZoom.toString();
      }
    });
  </script>
</body>
</html>
