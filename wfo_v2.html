<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wfo Writer v2</title>
  <style>
    /* ===== BASE STYLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #1a1a1a;
      color: #ffffff;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* ===== LAYOUT COMPONENTS ===== */
    /* ===== NAVIGATION AREAS ===== */
    .nav-area {
      position: fixed;
      top: 0;
      bottom: 0;
      cursor: pointer;
      z-index: 100;
      transition: background 0.2s ease;
    }
    
    .nav-left {
      left: 0;
      right: calc(50% + (100vh * 3 / 7.07) / 2);
    }
    
    .nav-right {
      left: calc(50% + (100vh * 3 / 7.07) / 2);
      right: 0;
    }
    
    .nav-area:hover {
      background: rgba(255, 255, 255, 0.05);
    }
    
    /* ===== GRID SYSTEM ===== */
    .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 10px;
      width: 100%;
      height: 100%;
      /* Grid is 3 cards wide, 5 cards tall, each card is 1:√2 aspect */
      /* Grid aspect = 3 / (5 * √2) = 3 / (5 * 1.414) = 3 / 7.07 = 0.424 */
      max-width: calc(100vh * 3 / 7.07);
      max-height: 100%;
      padding: 10px;
      box-sizing: border-box;
      margin: 0 auto; /* Center the grid */
    }
    
    /* ===== CARD COMPONENTS ===== */
    .card-wrapper {
      width: 100%;
      height: 100%;
      border: none;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      background: #333;
      cursor: grab;
      user-select: none;
      transition: all 0.2s ease;
      z-index: 1;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
    }
    
    .card-wrapper::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 8px;
      box-shadow: 
        inset 0 1px 2.5px rgba(0, 0, 0, 0.6),
        inset 0 -1px 2.5px rgba(255, 255, 255, 0.2);
      pointer-events: none;
      z-index: 5;
    }
    
    .card-wrapper:active {
      cursor: grabbing;
    }
    
    .card-wrapper.dragging {
      opacity: 0.4;
    }
    
    .card-wrapper.drag-source {
      background: #2a2a2a;
      border-style: dashed;
      border-color: #888;
    }
    
    .card-wrapper.drag-source canvas,
    .card-wrapper.drag-source .svg-container,
    .card-wrapper.drag-source .card-order {
      visibility: hidden;
    }
    
    .card-wrapper.drag-over {
      border-color: #4CAF50;
      transform: scale(1.05);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
    }
    
    .card-wrapper.empty-slot {
      cursor: default;
      background: #2a2a2a;
      border: 1px dashed #666;
      z-index: 0;
    }
    
    .card-wrapper.empty-slot.drag-over {
      background: #3a3a3a;
      border-color: #4CAF50;
      cursor: grab;
    }
    
    /* ===== INDIVIDUAL CARD VIEW ===== */
    .individual-card-view {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    .individual-card {
      width: 75vw;
      max-width: 500px;
      height: auto;
      aspect-ratio: 1 / 1.41421356;
      background: #333;
      border: none;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      box-shadow: 
        0 8px 30px rgba(0, 0, 0, 0.5),
        0 0 60px rgba(255, 255, 255, 0.15);
      margin: 20px;
      display: block;
    }
    
    .individual-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 12px;
      box-shadow: 
        inset 0 1px 4px rgba(0, 0, 0, 0.6),
        inset 0 -1px 4px rgba(255, 255, 255, 0.2);
      pointer-events: none;
      z-index: 10;
    }
    
    .individual-card canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .individual-card .svg-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    
    .individual-card .svg-container svg {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
      opacity: 0.5;
    }
    
    
    .card-wrapper canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .card-order {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .card-wrapper:hover .card-order {
      opacity: 1;
    }
    
    .svg-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    
    #status {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .error {
      color: #ff6b6b;
      text-align: center;
      padding: 1rem;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #gridContainer {
      flex: 1;
      overflow: auto;
    }
    
    /* ===== TRASH CAN ===== */
    .trash-can {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 48px;
      height: 48px;
      background: #333;
      border: 2px solid #666;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #888;
      cursor: pointer;
      z-index: 200;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .trash-can:hover {
      background: #444;
      border-color: #888;
      color: #aaa;
    }
    
    .trash-can.drag-over {
      background: #ff4444;
      border-color: #ff6666;
      color: white;
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
    }
    
    /* ===== DELETE MODAL ===== */
    .delete-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    
    .delete-modal-content {
      background: #333;
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      width: 90%;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .delete-modal-content h3 {
      color: #ff6b6b;
      margin-bottom: 16px;
      font-size: 20px;
    }
    
    .delete-modal-content p {
      color: #ccc;
      margin-bottom: 24px;
      line-height: 1.5;
    }
    
    .delete-modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn-danger {
      background: #ff4444;
      color: white;
    }
    
    .btn-danger:hover {
      background: #ff3333;
      transform: translateY(-1px);
    }
    
    .btn-secondary {
      background: #666;
      color: white;
    }
    
    .btn-secondary:hover {
      background: #777;
      transform: translateY(-1px);
    }
  </style>
</head>
<body>
  <!-- Navigation areas for previous/next set -->
  <div id="prevSetArea" class="nav-area nav-left" title="Previous Set"></div>
  <div id="nextSetArea" class="nav-area nav-right" title="Next Set"></div>
  
  <!-- Trash can for deleting cards -->
  <div id="trashCan" class="trash-can" title="Drag cards here to delete">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M10 11V17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M14 11V17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </div>
  
  <!-- Delete Confirmation Modal -->
  <div id="deleteModal" class="delete-modal" style="display: none;">
    <div class="delete-modal-content">
      <h3>Confirm Delete</h3>
      <p>Are you sure you want to delete this card? This action cannot be undone.</p>
      <div class="delete-modal-buttons">
        <button id="confirmDelete" class="btn btn-danger">Yes, Delete</button>
        <button id="cancelDelete" class="btn btn-secondary">Cancel</button>
      </div>
    </div>
  </div>
  
  <div id="status" style="display: none;">
    <div class="spinner"></div>
  </div>
  
  <!-- Individual Card View -->
  <div id="individualCardView" class="individual-card-view">
    <div class="individual-card" id="individualCard">
      <!-- Individual card content will be inserted here -->
    </div>
  </div>
  
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    // ===== CONFIGURATION =====
    const SUPABASE_URL = '{{SUPABASE_URL}}';
    const SUPABASE_SERVICE_ROLE_KEY = '{{SUPABASE_SERVICE_ROLE_KEY}}';
    const CARD_BASE_URL = `${SUPABASE_URL}/storage/v1/object/public/card/`;
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);
    
    // ===== GLOBAL VARIABLES =====
    let cardData = new Map(); // Cache for card data: "set.order" -> cardData
    let setInfo = new Map(); // Cache for set information: setNumber -> {cardCount, cards: [{order, position, filename}]}
    let currentSetNumber = 1; // Track the current set being displayed
    let availableSets = []; // Array of available set numbers
    
    // ===== UTILITY FUNCTIONS =====
    /**
     * Format card filename in the new naming convention
     * @param {number} set - Set number
     * @param {number} order - Card order within the set
     * @returns {string} Formatted filename (e.g., "1.2.json")
     */
    function formatCardFilename(set, order) {
      return `${set}.${order}.json`;
    }
    
    /**
     * Parse card filename to extract set and order numbers
     * @param {string} filename - Card filename (e.g., "1.2.json")
     * @returns {Object|null} Object with set and order properties, or null if invalid
     */
    function parseCardFilename(filename) {
      const match = filename.match(/^(\d+)\.(\d+)\.json$/);
      if (match) {
        return {
          set: parseInt(match[1], 10),
          order: parseInt(match[2], 10)
        };
      }
      return null;
    }
    
    /**
     * Generate CSS gradient from hex color
     * @param {string} hexColor - Hex color code or 'transparent'
     * @returns {string} CSS gradient string
     */
    function generateGradientFromColor(hexColor) {
      if (hexColor === 'transparent') {
        return 'linear-gradient(135deg, #f8f8f8 0%, #a0a0a0 100%)';
      }
      
      const rgb = hexToRgb(hexColor);
      const lighter = `rgb(${Math.min(255, rgb.r + 40)}, ${Math.min(255, rgb.g + 40)}, ${Math.min(255, rgb.b + 40)})`;
      const darker = `rgb(${Math.max(0, rgb.r - 40)}, ${Math.max(0, rgb.g - 40)}, ${Math.max(0, rgb.b - 40)})`;
      
      return `linear-gradient(135deg, ${lighter} 0%, ${hexColor} 50%, ${darker} 100%)`;
    }
    
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 128, g: 128, b: 128 };
    }
    
    // Get color for a card (from options or default)
    function getCardColor(cardData) {
      if (cardData && cardData.options && cardData.options.backgroundColor) {
        return cardData.options.backgroundColor;
      }
      return '#808080'; // Default gray
    }
    
    // Strip SVG colors to allow CSS inheritance
    function stripSvgColors(svgContent, keepNaturalColors = false) {
      if (keepNaturalColors) {
        return svgContent;
      }
      
      let processed = svgContent;
      
      // Remove fill attributes and replace with currentColor
      processed = processed.replace(/fill="[^"]*"/g, 'fill="currentColor"');
      processed = processed.replace(/fill='[^']*'/g, "fill='currentColor'");
      
      // Remove stroke attributes and replace with currentColor, or set to none for thin strokes
      processed = processed.replace(/stroke="[^"]*"/g, 'stroke="currentColor"');
      processed = processed.replace(/stroke='[^']*'/g, "stroke='currentColor'");
      
      // Remove stroke-width attributes to eliminate thick strokes
      processed = processed.replace(/\s*stroke-width="[^"]*"/g, '');
      processed = processed.replace(/\s*stroke-width='[^']*'/g, '');
      
      // Remove style attributes that contain fill or stroke
      processed = processed.replace(/\s*style="[^"]*fill:[^;"]*[^"]*"/g, '');
      processed = processed.replace(/\s*style='[^']*fill:[^;']*[^']*'/g, '');
      processed = processed.replace(/\s*style="[^"]*stroke:[^;"]*[^"]*"/g, '');
      processed = processed.replace(/\s*style='[^']*stroke:[^;']*[^']*'/g, '');
      
      return processed;
    }
    
    // Create SVG styling (from wfo.html)
    function createSvgStyle(hasTransform = false, transformValue = '1', textColor = 'currentColor', useNaturalColors = false) {
      if (useNaturalColors) {
        // Keep original SVG colors - no CSS override
        return `svg {
          width: 100%;
          height: 100%;
          display: block;
          object-fit: contain;
          object-position: center;
          ${hasTransform ? `transform: scale(${transformValue});` : ''}
          opacity: 0.5;
        }`;
      } else {
        // Apply color inheritance
        return `svg {
          width: 100%;
          height: 100%;
          display: block;
          object-fit: contain;
          object-position: center;
          ${hasTransform ? `transform: scale(${transformValue});` : ''}
          opacity: 0.5;
          color: ${textColor};
        }
        .svg-container svg * {
          fill: currentColor;
          stroke: currentColor;
          stroke-width: 0;
        }`;
      }
    }
    
    // Calculate text color for SVG
    function calculateSvgTextColor(backgroundColor, editorVisible) {
      if (backgroundColor === 'transparent') {
        return editorVisible ? '#000000' : '#ffffff';
      }
      
      const rgb = hexToRgb(backgroundColor);
      const luminosity = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
      
      return luminosity > 0.5 ? '#000000' : '#ffffff';
    }
    
    // ===== CARD DATA FUNCTIONS =====
    /**
     * Load card data from Supabase storage
     * @param {number} set - Set number
     * @param {number} order - Card order within the set
     * @returns {Promise<Object|null>} Card data object or null if not found
     */
    async function loadCardData(set, order) {
      try {
        const filename = formatCardFilename(set, order);
        const cacheBuster = `?t=${Date.now()}`;
        const response = await fetch(`${CARD_BASE_URL}${filename}${cacheBuster}`);
        
        if (!response.ok) {
          return null;
        }
        
        const cardData = await response.json();
        return cardData;
      } catch (error) {
        console.error(`Failed to load card ${set}.${order}:`, error);
        return null;
      }
    }
    
    // ===== DRAWING FUNCTIONS =====
    const COLORS = [
      { name: 'bla', hex: '#000000' },
      { name: 'car', hex: '#8c0004' },
      { name: 'red', hex: '#e00000' },
      { name: 'ora', hex: '#f34001' },
      { name: 'amb', hex: '#faaf00' },
      { name: 'yel', hex: '#dbd200' },
      { name: 'grn', hex: '#00cb00' },
      { name: 'cya', hex: '#00dfd8' },
      { name: 'blu', hex: '#3441fc' },
      { name: 'ind', hex: '#4020f0' },
      { name: 'pur', hex: '#8000f0' },
      { name: 'vio', hex: '#350063' },
      { name: 'gry', hex: '#808080' },
      { name: 'wht', hex: '#ffffff' }
    ];
    
    // Simple drawing function (placeholder - we'll render cards as images or simple representations)
    function drawCardPreview(canvas, cardData) {
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Don't draw background - let CSS gradient show through
      // Background is now handled by CSS gradient on canvas.style.background
      
      // Draw simple text if there's input
      if (cardData && cardData.input) {
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`Card ${cardData.input.substring(0, 10)}...`, canvas.width / 2, canvas.height / 2);
      }
    }
    
    // ===== DRAG AND DROP SYSTEM =====
    let draggedCard = null;
    let dragOffGridTimer = null;
    let isDraggingOffGrid = false;
    let lastDragX = 0;
    let cardToDelete = null; // Store card info for deletion
    
    /**
     * Set up drag and drop functionality for the grid
     * @param {number} setNumber - Set number for position updates
     */
    function setupDragAndDrop(setNumber) {
      const gridEl = document.getElementById('gridContainer');
      
      // Remove any existing drag event listeners to prevent duplicates
      gridEl.removeEventListener('dragstart', handleDragStart);
      gridEl.removeEventListener('dragend', handleDragEnd);
      gridEl.removeEventListener('dragover', handleDragOver);
      gridEl.removeEventListener('drop', handleDrop);
      
      function handleDragStart(e) {
        if (e.target.classList.contains('card-wrapper') && e.target.hasAttribute('data-order')) {
          draggedCard = e.target;
          e.target.classList.add('dragging');
          e.target.classList.add('drag-source');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', ''); // Required for some browsers
          
          // Add document-level listener to track drag position
          document.addEventListener('dragover', checkDragOffGrid);
        }
      }
      
      function checkDragOffGrid(e) {
        if (!draggedCard) return;
        
        lastDragX = e.clientX;
        const gridEl = document.getElementById('gridContainer');
        const trashCan = document.getElementById('trashCan');
        if (!gridEl || !trashCan) return;
        
        const gridRect = gridEl.getBoundingClientRect();
        const trashRect = trashCan.getBoundingClientRect();
        
        // Check if over trash can
        const isOverTrash = (
          e.clientX >= trashRect.left &&
          e.clientX <= trashRect.right &&
          e.clientY >= trashRect.top &&
          e.clientY <= trashRect.bottom
        );
        
        // Check if outside grid
        const isOutsideGrid = (
          e.clientX < gridRect.left ||
          e.clientX > gridRect.right ||
          e.clientY < gridRect.top ||
          e.clientY > gridRect.bottom
        );
        
        const prevArea = document.getElementById('prevSetArea');
        const nextArea = document.getElementById('nextSetArea');
        
        // Handle trash can highlighting
        if (isOverTrash) {
          trashCan.classList.add('drag-over');
          // Clear any existing timers
          if (dragOffGridTimer) {
            clearTimeout(dragOffGridTimer);
            dragOffGridTimer = null;
          }
          // Remove nav area highlights
          prevArea.style.background = '';
          nextArea.style.background = '';
          isDraggingOffGrid = false;
        } else {
          trashCan.classList.remove('drag-over');
          
          // Handle navigation areas
          if (isOutsideGrid && !isDraggingOffGrid) {
            isDraggingOffGrid = true;
            const direction = e.clientX < gridRect.left ? 'prev' : 'next';
            console.log('Started dragging off grid, direction:', direction);
            
            // Highlight the appropriate nav area
            if (direction === 'prev') {
              prevArea.style.background = 'rgba(255, 255, 255, 0.05)';
            } else {
              nextArea.style.background = 'rgba(255, 255, 255, 0.05)';
            }
            
            dragOffGridTimer = setTimeout(() => {
              console.log('1 second elapsed, finding target set...');
              const targetSet = findNonFullSet(direction);
              console.log('Target set:', targetSet);
              if (targetSet !== null) {
                const draggedOrder = parseInt(draggedCard.getAttribute('data-order'));
                console.log(`Moving card ${currentSetNumber}.${draggedOrder} to set ${targetSet}`);
                moveCardToSet(currentSetNumber, draggedOrder, targetSet);
              } else {
                console.log('No non-full sets available');
              }
              // Remove highlight
              prevArea.style.background = '';
              nextArea.style.background = '';
            }, 1000);
          } else if (!isOutsideGrid && isDraggingOffGrid) {
            console.log('Moved back onto grid, canceling timer');
            clearTimeout(dragOffGridTimer);
            isDraggingOffGrid = false;
            // Remove highlights
            prevArea.style.background = '';
            nextArea.style.background = '';
          }
        }
      }
      
      function handleDragEnd(e) {
        // Remove document listener
        document.removeEventListener('dragover', checkDragOffGrid);
        
        // Clear timer if still running
        if (dragOffGridTimer) {
          clearTimeout(dragOffGridTimer);
          dragOffGridTimer = null;
        }
        isDraggingOffGrid = false;
        
        // Clear nav area highlights
        const prevArea = document.getElementById('prevSetArea');
        const nextArea = document.getElementById('nextSetArea');
        const trashCan = document.getElementById('trashCan');
        if (prevArea) prevArea.style.background = '';
        if (nextArea) nextArea.style.background = '';
        if (trashCan) trashCan.classList.remove('drag-over');
        
        if (e.target.classList.contains('card-wrapper')) {
          e.target.classList.remove('dragging');
          e.target.classList.remove('drag-source');
          const allCards = gridEl.querySelectorAll('.card-wrapper');
          allCards.forEach(card => card.classList.remove('drag-over'));
          
          // Check if dropped on trash can
          const trashRect = trashCan.getBoundingClientRect();
          const isOverTrash = (
            e.clientX >= trashRect.left &&
            e.clientX <= trashRect.right &&
            e.clientY >= trashRect.top &&
            e.clientY <= trashRect.bottom
          );
          
          if (isOverTrash && draggedCard) {
            // Store card info for deletion
            const draggedOrder = parseInt(draggedCard.getAttribute('data-order'));
            cardToDelete = {
              set: currentSetNumber,
              order: draggedOrder,
              element: draggedCard
            };
            showDeleteModal();
          }
          
          setTimeout(() => {
            draggedCard = null;
          }, 100);
        }
      }
      
      function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        
        // Clear all existing drag-over highlights
        const allCards = gridEl.querySelectorAll('.card-wrapper');
        allCards.forEach(card => card.classList.remove('drag-over'));
        
        // Calculate distances to all card centers and find the closest one
        let closestCard = null;
        let closestDistance = Infinity;
        
        for (const card of allCards) {
          // Skip the dragged card itself and empty slots
          if (card === draggedCard || card.classList.contains('empty-slot')) continue;
          
          const cardRect = card.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;
          
          // Calculate distance from mouse to card center
          const distance = Math.sqrt(
            Math.pow(e.clientX - cardCenterX, 2) + 
            Math.pow(e.clientY - cardCenterY, 2)
          );
          
          if (distance < closestDistance) {
            closestDistance = distance;
            closestCard = card;
          }
        }
        
        // Highlight the closest card
        if (closestCard) {
          closestCard.classList.add('drag-over');
        }
      }
      
      function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggedCard) return;
        
        // Find the closest card to the drop point
        let targetCard = null;
        let closestDistance = Infinity;
        const allCards = gridEl.querySelectorAll('.card-wrapper');
        
        for (const card of allCards) {
          // Skip only the dragged card itself (allow empty slots as targets)
          if (card === draggedCard) continue;
          
          const cardRect = card.getBoundingClientRect();
          const cardCenterX = cardRect.left + cardRect.width / 2;
          const cardCenterY = cardRect.top + cardRect.height / 2;
          
          // Calculate distance from drop point to card center
          const distance = Math.sqrt(
            Math.pow(e.clientX - cardCenterX, 2) + 
            Math.pow(e.clientY - cardCenterY, 2)
          );
          
          if (distance < closestDistance) {
            closestDistance = distance;
            targetCard = card;
          }
        }
        
        // Get the target position from the closest card
        const targetRow = parseInt(targetCard?.style.gridRow) || 1;
        const targetCol = parseInt(targetCard?.style.gridColumn) || 1;
        
        // Get the dragged card's ORIGINAL positions (before any visual updates)
        const originalDraggedRow = parseInt(draggedCard.style.gridRow) || 1;
        const originalDraggedCol = parseInt(draggedCard.style.gridColumn) || 1;
        
        // Check if dropping on the same position
        if (targetRow === originalDraggedRow && targetCol === originalDraggedCol) {
          // No change needed
          targetCard?.classList.remove('drag-over');
          return;
        }
        
        // Use the global current set number
        const currentSet = currentSetNumber;
        
        const draggedOrder = parseInt(draggedCard.getAttribute('data-order'));
        const isTargetEmpty = !targetCard || targetCard.classList.contains('empty-slot');
        const targetOrder = targetCard ? parseInt(targetCard.getAttribute('data-order')) : null;
        
        // If target is an empty slot, we need to find if there's a real card at that position
        if (targetCard && targetCard.classList.contains('empty-slot')) {
          // Look for a real card at the same grid position
          const allRealCards = gridEl.querySelectorAll('.card-wrapper:not(.empty-slot)');
          for (const realCard of allRealCards) {
            const realCardRow = parseInt(realCard.style.gridRow) || 1;
            const realCardCol = parseInt(realCard.style.gridColumn) || 1;
            if (realCardRow === targetRow && realCardCol === targetCol) {
              // Found the real card at this position
              targetCard = realCard;
              break;
            }
          }
        }
        
        // Update isTargetEmpty after potentially finding the real card
        const finalIsTargetEmpty = !targetCard || targetCard.classList.contains('empty-slot');
        
        if (finalIsTargetEmpty) {
          // Move to empty slot - update visual position
          draggedCard.style.gridRow = targetRow;
          draggedCard.style.gridColumn = targetCol;
          
          // Create placeholder at original position
          const originalEmptySlot = document.createElement('div');
          originalEmptySlot.className = 'card-wrapper empty-slot';
          originalEmptySlot.style.gridRow = originalDraggedRow;
          originalEmptySlot.style.gridColumn = originalDraggedCol;
          gridEl.appendChild(originalEmptySlot);
          
          // Save position in background
          updateCardPosition(currentSet, draggedOrder, targetRow, targetCol);
        } else {
          // Swap with another card - update visual positions
          const targetOrder = parseInt(targetCard.getAttribute('data-order'));
          
          draggedCard.style.gridRow = targetRow;
          draggedCard.style.gridColumn = targetCol;
          targetCard.style.gridRow = originalDraggedRow;
          targetCard.style.gridColumn = originalDraggedCol;
          
          // Save both positions in background
          updateCardPosition(currentSet, draggedOrder, targetRow, targetCol);
          updateCardPosition(currentSet, targetOrder, originalDraggedRow, originalDraggedCol);
        }
        
        targetCard.classList.remove('drag-over');
      }
      
      // Add the event listeners
      gridEl.addEventListener('dragstart', handleDragStart);
      gridEl.addEventListener('dragend', handleDragEnd);
      gridEl.addEventListener('dragover', handleDragOver);
      gridEl.addEventListener('drop', handleDrop);
    }
    
    async function updateCardPosition(set, order, row, col) {
      try {
        const key = `${set}.${order}`;
        let cardDataObj = cardData.get(key);
        
        // If not in cache, load it
        if (!cardDataObj) {
          cardDataObj = await loadCardData(set, order);
          if (!cardDataObj) {
            return;
          }
          cardData.set(key, cardDataObj);
        }
        
        if (!cardDataObj.options) {
          cardDataObj.options = {};
        }
        cardDataObj.options.position = { row, col };
        
        // Update cache
        cardData.set(key, cardDataObj);
        
        const jsonString = JSON.stringify(cardDataObj, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const fileName = formatCardFilename(set, order);
        
        const { error } = await supabaseClient.storage
          .from('card')
          .upload(fileName, blob, {
            contentType: 'application/json',
            upsert: true
          });
        
        if (error) {
          console.error(`Failed to save position for ${set}.${order}:`, error);
        }
      } catch (error) {
        console.error(`Error updating position for ${set}.${order}:`, error);
      }
    }
    
    // ===== INDIVIDUAL CARD VIEW =====
    /**
     * Show individual card in full-screen view
     * @param {number} setNumber - Set number of the card
     * @param {number} order - Order number of the card
     * @param {Object} cardData - Card data object
     */
    async function showIndividualCard(setNumber, order, cardData) {
      const individualView = document.getElementById('individualCardView');
      const individualCard = document.getElementById('individualCard');
      const gridContainer = document.getElementById('gridContainer');
      
      // Remove grid from DOM to prevent CSS interference with SVG rendering
      if (gridContainer) {
        gridContainer.remove();
      }
      
      // Clear previous content
      individualCard.innerHTML = '';
      
      // Create canvas for the individual card
      const canvas = document.createElement('canvas');
      canvas.width = 600;
      canvas.height = 848; // 600 * √2 = 600 * 1.41421356 = 848.528
      individualCard.appendChild(canvas);
      
      // Set background
      const bgColor = getCardColor(cardData);
      canvas.style.background = generateGradientFromColor(bgColor);
      
      // Draw card preview
      drawCardPreview(canvas, cardData);
      
      // Load SVG if present
      if (cardData.options && cardData.options.svgBackground) {
        const svgValue = cardData.options.svgBackground;
        let svgContent = null;
        
        if (svgValue.startsWith('http://') || svgValue.startsWith('https://')) {
          try {
            const response = await fetch(svgValue);
            svgContent = await response.text();
          } catch (error) {
            console.error('Failed to load SVG:', error);
          }
        } else {
          svgContent = svgValue;
        }
        
        if (svgContent) {
          const cardColor = getCardColor(cardData);
          const textColor = calculateSvgTextColor(cardColor, false);
          const useNaturalColors = cardData.options && cardData.options.svgColor === true;
          const cleanedSvg = stripSvgColors(svgContent, useNaturalColors);
          
          const svgContainer = document.createElement('div');
          svgContainer.className = 'svg-container';
          svgContainer.innerHTML = `
            <style>
              .svg-container ${createSvgStyle(false, '1', textColor, useNaturalColors)}
            </style>
            ${cleanedSvg}
          `;
          individualCard.appendChild(svgContainer);
          
          // Force a reflow/repaint to ensure SVG is rendered (from wfo.html)
          svgContainer.offsetHeight;
        }
      }
      
      // Show individual card view
      individualView.style.display = 'flex';
    }
    
    /**
     * Hide individual card view and return to grid view
     */
    function hideIndividualCard() {
      const individualView = document.getElementById('individualCardView');
      const gridContainer = document.getElementById('gridContainer');
      
      // Hide individual view
      individualView.style.display = 'none';
      
      // Show the grid if it exists, otherwise rebuild it
      if (gridContainer) {
        gridContainer.style.display = 'grid';
      } else {
        // Grid was removed, rebuild it
        displaySet(currentSetNumber);
      }
    }
    
    // ===== CACHING SYSTEM =====
    async function scanAllSets() {
      try {
        console.log('Scanning all sets...');
        const { data: files, error } = await supabaseClient.storage
          .from('card')
          .list('', { limit: 1000 });
        
        if (error) throw error;
        
        // Group files by set
        const sets = new Map();
        let maxSetFound = 0;
        
        for (const file of files) {
          const parsed = parseCardFilename(file.name);
          if (parsed) {
            if (!sets.has(parsed.set)) {
              sets.set(parsed.set, []);
            }
            sets.get(parsed.set).push(parsed);
            maxSetFound = Math.max(maxSetFound, parsed.set);
          }
        }
        
        // Cache set info and build available sets array
        // Include all sets from 1 to maxSetFound, even if empty
        availableSets = [];
        
        for (let setNum = 1; setNum <= maxSetFound; setNum++) {
          const cards = sets.get(setNum) || [];
          setInfo.set(setNum, {
            cardCount: cards.length,
            cards: cards.sort((a, b) => a.order - b.order)
          });
          availableSets.push(setNum);
        }
        
        console.log('Cached set info:', setInfo);
        
      } catch (error) {
        console.error('Error scanning sets:', error);
      }
    }
    
    async function loadCardDataCached(set, order) {
      const key = `${set}.${order}`;
      
      // Return cached data if available
      if (cardData.has(key)) {
        return cardData.get(key);
      }
      
      // Load and cache
      const data = await loadCardData(set, order);
      cardData.set(key, data);
      return data;
    }
    
    
    // ===== GRID DISPLAY SYSTEM =====
    /**
     * Display a set of cards in the grid layout
     * @param {number} setNumber - Set number to display
     */
    async function displaySet(setNumber) {
      const statusEl = document.getElementById('status');
      
      // Create grid container dynamically if it doesn't exist
      let gridEl = document.getElementById('gridContainer');
      if (!gridEl) {
        gridEl = document.createElement('div');
        gridEl.id = 'gridContainer';
        gridEl.className = 'grid-container';
        gridEl.style.display = 'none';
        document.body.insertBefore(gridEl, document.getElementById('individualCardView'));
      }
      
      statusEl.style.display = 'block';
      gridEl.style.display = 'none';
      gridEl.innerHTML = '';
      
      try {
        // Use cached set info if available, otherwise load all cards
        let loadedCards;
        if (setInfo.has(setNumber)) {
          const setCards = setInfo.get(setNumber).cards;
          const cardPromises = setCards.map(card => 
            loadCardDataCached(setNumber, card.order).then(data => ({ order: card.order, data }))
          );
          loadedCards = await Promise.all(cardPromises);
        } else {
          // Fallback: load all cards for this set
          const cardPromises = [];
          for (let order = 1; order <= 15; order++) {
            cardPromises.push(loadCardDataCached(setNumber, order).then(data => ({ order, data })));
          }
          loadedCards = await Promise.all(cardPromises);
        }
        
        // Create a map of grid positions (row-col) to card data
        const gridPositions = new Map();
        const cardsWithoutPosition = [];
        
        // First pass: place cards that have explicit positions
        loadedCards.forEach(({ order, data }) => {
          if (data && data.options && data.options.position) {
            const { row, col } = data.options.position;
            // Only use position if both row and col are valid numbers
            if (row !== null && col !== null && typeof row === 'number' && typeof col === 'number') {
              const key = `${row}-${col}`;
              gridPositions.set(key, { order, data });
            } else {
              // Position exists but has null values, treat as no position
              cardsWithoutPosition.push({ order, data });
            }
          } else if (data) {
            cardsWithoutPosition.push({ order, data });
          }
        });
        
        // Second pass: fill empty positions with cards that don't have positions
        let cardWithoutPosIndex = 0;
        for (let row = 1; row <= 5; row++) {
          for (let col = 1; col <= 3; col++) {
            const key = `${row}-${col}`;
            if (!gridPositions.has(key) && cardWithoutPosIndex < cardsWithoutPosition.length) {
              gridPositions.set(key, cardsWithoutPosition[cardWithoutPosIndex]);
              cardWithoutPosIndex++;
            }
          }
        }
        
        // Create grid in order (row by row, col by col)
        for (let row = 1; row <= 5; row++) {
          for (let col = 1; col <= 3; col++) {
            const key = `${row}-${col}`;
            const cardInfo = gridPositions.get(key);
            
            const cardWrapper = document.createElement('div');
            cardWrapper.className = 'card-wrapper';
            cardWrapper.style.gridRow = row;
            cardWrapper.style.gridColumn = col;
          
          if (cardInfo) {
            const { order, data: cardData } = cardInfo;
            cardWrapper.setAttribute('draggable', 'true');
            cardWrapper.setAttribute('data-order', order);
          
          if (cardData) {
            // Order number label
            const orderLabel = document.createElement('div');
            orderLabel.className = 'card-order';
            orderLabel.textContent = order;
            cardWrapper.appendChild(orderLabel);
            
            // Add click event to show individual card
            cardWrapper.addEventListener('click', () => {
              showIndividualCard(setNumber, order, cardData);
            });
            
            // SVG container
            const svgContainer = document.createElement('div');
            svgContainer.className = 'svg-container';
            cardWrapper.appendChild(svgContainer);
            
            // Load SVG if present
            if (cardData.options && cardData.options.svgBackground) {
              const svgValue = cardData.options.svgBackground;
              let svgContent = null;
              
              if (svgValue.startsWith('http://') || svgValue.startsWith('https://')) {
                try {
                  const response = await fetch(svgValue);
                  svgContent = await response.text();
                } catch (error) {
                  console.error('Failed to load SVG:', error);
                }
              } else {
                svgContent = svgValue;
              }
              
              if (svgContent) {
                const cardColor = getCardColor(cardData);
                const textColor = calculateSvgTextColor(cardColor, false);
                const useNaturalColors = cardData.options && cardData.options.svgColor === true;
                const cleanedSvg = stripSvgColors(svgContent, useNaturalColors);
                
                svgContainer.innerHTML = `
                  <style>
                    .svg-container ${createSvgStyle(false, '1', textColor, useNaturalColors)}
                  </style>
                  ${cleanedSvg}
                `;
                
                // Force a reflow/repaint to ensure SVG is rendered (from wfo.html)
                svgContainer.offsetHeight;
              }
            }
            
            // Canvas
            const canvas = document.createElement('canvas');
            canvas.width = 600;
            canvas.height = 848; // 600 * √2 = 600 * 1.41421356 = 848.528
            cardWrapper.appendChild(canvas);
            
            // Set background
            const bgColor = getCardColor(cardData);
            canvas.style.background = generateGradientFromColor(bgColor);
            
            // Draw simple preview
            drawCardPreview(canvas, cardData);
          }
          } else {
            // Empty slot - make it a valid drop target
            cardWrapper.classList.add('empty-slot');
            
            // Add a placeholder div to ensure events are captured
            const placeholder = document.createElement('div');
            placeholder.style.width = '100%';
            placeholder.style.height = '100%';
            placeholder.style.pointerEvents = 'none'; // Don't interfere with drag events
            cardWrapper.appendChild(placeholder);
          }
          
          gridEl.appendChild(cardWrapper);
          }
        }
        
        statusEl.style.display = 'none';
        gridEl.style.display = 'grid';
        
        // Setup drag and drop
        setupDragAndDrop(setNumber);
        
      } catch (error) {
        statusEl.style.display = 'none';
        console.error('Error displaying set:', error);
      }
    }
    
    // ===== DELETE MODAL FUNCTIONS =====
    function showDeleteModal() {
      const modal = document.getElementById('deleteModal');
      modal.style.display = 'flex';
    }
    
    function hideDeleteModal() {
      const modal = document.getElementById('deleteModal');
      modal.style.display = 'none';
      cardToDelete = null;
    }
    
    async function deleteCard() {
      if (!cardToDelete) return;
      
      try {
        const { set, order } = cardToDelete;
        
        // Delete from Supabase storage
        const fileName = formatCardFilename(set, order);
        const { error } = await supabaseClient.storage
          .from('card')
          .remove([fileName]);
        
        if (error) {
          console.error(`Failed to delete card ${set}.${order}:`, error);
          return;
        }
        
        // Remove from cache
        const key = `${set}.${order}`;
        cardData.delete(key);
        
        // Remove from DOM
        if (cardToDelete.element) {
          cardToDelete.element.remove();
        }
        
        // Rescan sets to update setInfo
        await scanAllSets();
        
        // Refresh the current set display
        await displaySet(currentSetNumber);
        
        console.log(`Card ${set}.${order} deleted successfully`);
        
      } catch (error) {
        console.error('Error deleting card:', error);
      } finally {
        hideDeleteModal();
      }
    }
    
    // ===== CARD MANAGEMENT FUNCTIONS =====
    async function moveCardToSet(fromSet, cardOrder, toSet) {
      try {
        // Load the card data
        const key = `${fromSet}.${cardOrder}`;
        let cardDataObj = cardData.get(key);
        
        if (!cardDataObj) {
          cardDataObj = await loadCardData(fromSet, cardOrder);
          if (!cardDataObj) return;
        }
        
        // Find next available order number in target set
        const targetSetInfo = setInfo.get(toSet);
        let nextOrder = 1;
        if (targetSetInfo) {
          const usedOrders = targetSetInfo.cards.map(c => c.order);
          while (usedOrders.includes(nextOrder)) {
            nextOrder++;
          }
        }
        
        // Delete old file
        const oldFileName = formatCardFilename(fromSet, cardOrder);
        await supabaseClient.storage.from('card').remove([oldFileName]);
        
        // Reset position for new set
        if (cardDataObj.options) {
          cardDataObj.options.position = null;
        }
        
        // Save to new location
        const newFileName = formatCardFilename(toSet, nextOrder);
        const jsonString = JSON.stringify(cardDataObj, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        await supabaseClient.storage
          .from('card')
          .upload(newFileName, blob, { contentType: 'application/json', upsert: true });
        
        // Update caches
        cardData.delete(key);
        cardData.set(`${toSet}.${nextOrder}`, cardDataObj);
        
        // Rescan sets to update setInfo
        await scanAllSets();
        
        // Switch to the target set and display
        currentSetNumber = toSet;
        await displaySet(toSet);
        
      } catch (error) {
        console.error('Error moving card to set:', error);
      }
    }
    
    // ===== NAVIGATION FUNCTIONS =====
    function goToNextSet() {
      const currentIndex = availableSets.indexOf(currentSetNumber);
      if (currentIndex < availableSets.length - 1) {
        currentSetNumber = availableSets[currentIndex + 1];
        displaySet(currentSetNumber);
      }
    }
    
    function goToPreviousSet() {
      const currentIndex = availableSets.indexOf(currentSetNumber);
      if (currentIndex > 0) {
        currentSetNumber = availableSets[currentIndex - 1];
        displaySet(currentSetNumber);
      }
    }
    
    function findNonFullSet(direction = 'next') {
      const currentIndex = availableSets.indexOf(currentSetNumber);
      const setsToCheck = direction === 'next' 
        ? availableSets.slice(currentIndex + 1)
        : availableSets.slice(0, currentIndex).reverse();
      
      for (const setNum of setsToCheck) {
        const info = setInfo.get(setNum);
        if (info && info.cardCount < 15) {
          return setNum;
        }
      }
      return null; // All sets are full
    }
    
    // ===== INITIALIZATION AND EVENT HANDLERS =====
    document.getElementById('nextSetArea').addEventListener('click', goToNextSet);
    document.getElementById('prevSetArea').addEventListener('click', goToPreviousSet);
    
    // Click on individual card to close it
    document.getElementById('individualCard').addEventListener('click', hideIndividualCard);
    
    // Delete modal event handlers
    document.getElementById('confirmDelete').addEventListener('click', deleteCard);
    document.getElementById('cancelDelete').addEventListener('click', hideDeleteModal);
    
    // Also close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const individualView = document.getElementById('individualCardView');
        const deleteModal = document.getElementById('deleteModal');
        
        if (individualView.style.display === 'flex') {
          hideIndividualCard();
        } else if (deleteModal.style.display === 'flex') {
          hideDeleteModal();
        }
      }
    });
    
    // Initialize: scan all sets and load first one
    async function initialize() {
      await scanAllSets();
      
      // Load the first available set
      if (availableSets.length > 0) {
        currentSetNumber = availableSets[0];
        displaySet(currentSetNumber);
      }
    }
    
    // Start the app
    initialize();
    
  </script>
</body>
</html>

